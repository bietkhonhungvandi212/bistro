This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T17:37:47.699Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
prisma/
  schema.prisma
src/
  domains/
    accounts/
      dto/
        account-change-password.dto.ts
        account-create.dto.ts
        account-detail.dto.ts
        account-update.dto.ts
      response/
        account.response.ts
      account.controller.ts
      account.service.ts
      accounts.module.ts
    audio-call/
      admin/
        dto/
          audio-call-admin-detail.dto.ts
          participant-dto.ts
        request/
          audio-call-admin-create.request.ts
          audio-call-admin-list.request.ts
        response/
          audio-call-admin-detail.response.ts
          audio-call-admin-list.response.ts
        audio-call-admin.controller.ts
        audio-call-admin.module.ts
        audio-call-admin.service.ts
      base/
        audio-call-list-base.request.ts
      client/
        request/
          audio-call-client-list.request.ts
        audio-call-client.controller.ts
        audio-call-client.module.ts
        audio-call-client.service.ts
      dto/
        audio-call-end.dto.ts
        audio-call-join.dto.ts
        audio-call-start.dto.ts
      response/
        audio-call-participant-history.response.ts
      shared/
        helpers.ts
        types.ts
      audio-call.controller.ts
      audio-call.gateway.ts
      audio-call.module.ts
      audio-call.service.spec.ts
      audio-call.service.ts
    auth/
      dto/
        auth-jwt-payload.dto.ts
        auth-login.dto.ts
        auth-request.dto.ts
        auth-user.dto.ts
      request/
        auth-email--reset-password.request.ts
        auth-email-verification.request.ts
        auth-find-password-reset.request.ts
        auth-login.request.ts
        auth-mentor-register.request.ts
        auth-otp-checkout.request.ts
        auth-otp-send.request.ts
        auth-student-register.request.ts
        auth-test-account.request.ts
      response/
        auth-find-password.response.ts
        auth-login.response.ts
        auth-register.response.ts
      auth-jwt.guard.ts
      auth-jwt.strategy.ts
      auth-public.decorator.ts
      auth-role.decorator.ts
      auth-role.guard.ts
      auth.controller.ts
      auth.module.ts
      auth.service.ts
    category/
      admin/
        dto/
          category-cms-detail.dto.ts
        request/
          category-admin-create.request.ts
          category-admin-list.request.ts
          category-admin-reordinal.request.ts
          category-admin-update.request.ts
        response/
          category-admin-detail.response.ts
          category-admin-list.response.ts
        category-admin.controller.ts
        category-admin.service.ts
      client/
        dto/
          category-client-statistics.dto.ts
        request/
          category-client-list.request.ts
          category-client-select-interested-choice.request.ts
        response/
          category-client-list.response.ts
          category-client-statistics.response.ts
        category-client.controller.ts
        category-client.service.ts
      shared/
        enums.ts
        types.ts
      category.module.ts
    chat-message/
      helper/
        chat-room-create.helper.ts
        chat-room-detail.helper.ts
        chat-room-list-helper.ts
        chat-room-read-message.helper.ts
      request/
        chat-message-create.request.ts
        chat-room-create.request.ts
        chat-room-detail.request.ts
        chat-room-list.request.ts
        chat-room-read-message.request.ts
      response/
        chat-room-detail.response.ts
        chat-room-list.response.ts
        message-chat-create.response.ts
      shared/
        types.ts
      chat-message.controller.spec.ts
      chat-message.controller.ts
      chat-message.gateway.ts
      chat-message.module.ts
      chat-message.service.spec.ts
      chat-message.service.ts
    course/
      admin/
        request/
          course-approve.request.ts
        response/
          course-admin-detail.response.ts
          course-admin-list.response.ts
        course-admin.controller.spec.ts
        course-admin.controller.ts
        course-admin.module.ts
        course-admin.service.spec.ts
        course-admin.service.ts
      client/
        request/
          course-client-create.request.ts
          course-client-update.request.ts
          course-section-client-update.request.ts
        response/
          course-client-detail.response.ts
          course-client-list.response.ts
          course-section-client.response.ts
        course-client.controller.spec.ts
        course-client.controller.ts
        course-client.module.ts
        course-client.service.spec.ts
        course-client.service.ts
      dto/
        course-section.dto.ts
      factory/
        list/
          course-admin-list.request.ts
          course-client-list.request.ts
        course-list.factory.ts
      shared/
        helper/
          course-detail-query.helper.ts
          course-list-query.helper.ts
          course-section.helper.ts
          course-update-query.helper.ts
        course-base-list.request.ts
        enums.ts
        types.ts
      course.module.ts
    dashboard/
      admin/
        dashboard-admin.controller.spec.ts
        dashboard-admin.controller.ts
        dashboard-admin.module.ts
        dashboard-admin.service.spec.ts
        dashboard-admin.service.ts
      client/
        dashboard-client.controller.spec.ts
        dashboard-client.controller.ts
        dashboard-client.module.ts
        dashboard-client.service.spec.ts
        dashboard-client.service.ts
      helper/
        statistic-overview-admin-list.helper.ts
        statistic-overview-client-list.helper.ts
        statistic-payment-list.helper.ts
        statistic-subscription-list.helper.ts
      request/
        statistic-base-list.request.ts
        statistic-course-list.request.ts
        statistic-overview-list.request.ts
        statistic-payment-list.request.ts
        statistic-subscription-list.request.ts
        statistic-top-course-list.request.ts
      response/
        statistic-overview-list.response.ts
        statistic-payment-list.response.ts
      shared/
        types.ts
      dashboard.controller.ts
      dashboard.module.ts
      dashboard.service.ts
    feedback/
      admin/
        feedback-admin.controller.spec.ts
        feedback-admin.controller.ts
        feedback-admin.module.ts
        feedback-admin.service.spec.ts
        feedback-admin.service.ts
      client/
        feedback-client.controller.spec.ts
        feedback-client.controller.ts
        feedback-client.module.ts
        feedback-client.service.spec.ts
        feedback-client.service.ts
      helper/
        feedback-create.helper.ts
        feedback-list.helper.ts
        feedback-update.helper.ts
      request/
        feedback-create.request.ts
        feedback-list.request.ts
        feedback-update.request.ts
      response/
        feedback-list.response.ts
      shared/
        type.ts
      feedback.module.ts
    file/
      dto/
        file-link.dto.ts
      request/
        file-create.request.ts
        file-upload-signed-url.request.ts
      response/
        file-create.response.ts
        file.response.ts
      file.controller.spec.ts
      file.controller.ts
      file.module.ts
      file.service.spec.ts
      file.service.ts
    image/
      response/
        image-version.response.ts
        image.response.ts
      image.controller.ts
      image.module.ts
      image.service.ts
    mentor/
      admin/
        dto/
          mentor-admin-detail.dto.ts
          mentor-client-detail.dto.ts
        request/
          mentor-admin-approve.request.ts
          mentor-admin-interview.request.ts
          mentor-admin-list.request.ts
          mentor-client-list.request.ts
        response/
          mentor-admin-detail.response.ts
          mentor-admin-interview.response.ts
          mentor-admin-list.response.ts
          mentor-client-detail.response.ts
          mentor-client-list.response.ts
        mentor-admin.controller.spec.ts
        mentor-admin.controller.ts
        mentor-admin.module.ts
        mentor-admin.service.spec.ts
        mentor-admin.service.ts
      client/
        request/
          mentor-client-achievement-create.request.ts
          mentor-client-achievement-update.request.ts
          mentor-client-course-list.request.ts
          mentor-client-schedule-create.request.ts
          mentor-client-schedule-list.request.ts
          mentor-client-schedule-update.request.ts
          mentor-client-update.request.ts
        response /
          mentor-schedule-list.response.ts
        mentor-client.controller.spec.ts
        mentor-client.controller.ts
        mentor-client.module.ts
        mentor-client.service.spec.ts
        mentor-client.service.ts
        mentor-schedule.service.ts
      shared/
        enums.ts
        types.ts
      mentor.module.ts
    notification/
      helper/
        notification-common.helper.ts
      request/
        notification-create.request.ts
        notification-list.request.ts
        notification-read.request.ts
      response/
        notification.response.ts
      shared/
        interfaces.ts
        transation.enum.ts
        types.ts
      notification.controller.ts
      notification.gateway.ts
      notification.module.ts
      notification.service.ts
    payment/
      client/
        payment-client.controller.spec.ts
        payment-client.controller.ts
        payment-client.module.ts
        payment-client.service.spec.ts
        payment-client.service.ts
      dto/
        payment-continue.request.ts
        payment-create.request.ts
      payment.module.ts
    report/
      helper/
        report-create.helper.ts
        report-detail.helper.ts
        report-list.helper.ts
        report-resolve.helper.ts
      request/
        report-client-feedback-create.request.ts
        report-client-subscription-create.request.ts
        report-list.request.ts
        report-resolve-base.request.ts
        report-resolve-feeback.request.ts
        report-resolve-subscription.request.ts
      response/
        report-detail.response.ts
        report-list.response.ts
      shared/
        interface.ts
        type.ts
        utilities.ts
      report.controller.ts
      report.module.ts
      report.service.spec.ts
      report.service.ts
    student/
      client/
        student-client.controller.spec.ts
        student-client.controller.ts
        student-client.module.ts
        student-client.service.spec.ts
        student-client.service.ts
      shared/
        types.ts
      student.module.ts
    subscription/
      client/
        subscription-client.controller.ts
        subscription-client.module.ts
        subscription-client.service.spec.ts
        subscription-client.service.ts
      dto/
        request/
          subscription-admin-list.request.ts
          subscription-create.request.ts
          subscription-mentor-approve.ts
          subscription-payment-create.ts
        response/
          subscription-admin-list.response.ts
          subscription-detail.response.ts
          subscription-list.response.ts
      helper/
        subcription-create.helper.ts
        subscription-approve.helper.ts
        subscription-common.helper.ts
        subscription-detail.helper.ts
        subscription-list.helper.ts
        subscription-make-payment.helper.ts
      shared/
        types.ts
      subscription-admin/
        subscription-admin.controller.spec.ts
        subscription-admin.controller.ts
        subscription-admin.module.ts
        subscription-admin.service.spec.ts
        subscription-admin.service.ts
      subscription.module.ts
    utility/
      request/
        utility-enum.request.ts
      utility.controller.ts
      utility.module.ts
      utility.service.ts
  interceptors/
    logging.interceptor.ts
    prisma-exception.interceptor.ts
  middlewares/
    http-exception.middlewave.ts
    socket-auth.middleware.ts
  pipes/
    validation-array.pipe.ts
    validation-custom.pipe.ts
    validation.pipe.ts
  services/
    axios/
      axios.module.ts
      axios.service.spec.ts
      axios.service.ts
    email/
      shared/
        types.ts
      email.module.ts
      email.service.ts
    event-emitter/
      event-emitter.interface.ts
      event-emitter.module.ts
      event-emitter.service.ts
    fcm/
      request/
        fcm-register-token.request.ts
        fcm-remove-token.request.ts
      shared/
        helpers.ts
      fcm.controller.ts
      fcm.module.ts
      fcm.service.ts
      fcm.types.ts
    getstream/
      request/
        getstream.request.ts
      getstream.controller.ts
      getstream.module.ts
      getstream.service.spec.ts
      getstream.service.ts
    payment-gateway/
      vn-pay/
        shared/
          vnpay.constant.ts
          vnpay.enum.ts
          vnpay.helper.ts
          vnpay.type.ts
        vnpay.module.ts
        vnpay.service.ts
    prisma/
      transactions/
        transaction-host.spec.ts
        transaction-host.ts
        transaction.constant.ts
        transaction.symbol.ts
        transaction.type.ts
        transactional.decorator.ts
      prisma-raw.service.ts
      prisma.module.ts
      prisma.service.ts
    storage/
      dto/
        storage.dto.ts
      shared/
        interfaces/
          file.interface.ts
          sharp.interface.ts
          signed-upload-url.interface.ts
        types/
          cloudinary-config.types.ts
      storage.module.ts
      storage.provider.ts
      storage.service.spec.ts
      storage.service.ts
      storgare.module-definition.ts
    common.module.ts
  shared/
    constants/
      audio-room.constant.ts
      auth.constant.ts
      category.constant.ts
      chat-message.constant.ts
      common.constant.ts
      course.constant.ts
      dashboard.constant.ts
      date.constant.ts
      event.constant.ts
      notification.constant.ts
      payment.constant.ts
      prisma.constant.ts
      report.constant.ts
      storage.constant.ts
      subscription.constant.ts
    enums/
      common.enum.ts
      query.enum.ts
    exceptions/
      action-failed.exception.ts
      asset-file-not-existed.exception.ts
      database-connnection.exception.ts
      entity-not-found.exception.ts
      key-duplication.exception.ts
      prisma-client-validation.exception.ts
      relation-violation.request.ts
      toss-payment-validate.exception.ts
      unknown-prisma.exception.ts
      write-fail-exception.ts
      write-relation-not-found.exception.ts
    generics/
      base.response.ts
      pagination.request.ts
      pagination.response.ts
      toss-payment-result.response.ts
      type.helper.ts
    helpers/
      add-timestamp.helper.ts
      category.helper.ts
      common.helper.ts
      date-range.helper.ts
      function.helper.ts
      pagination.helper.ts
      path.helper.ts
      prisma.helper.ts
      query.helper.ts
      response.helper.ts
    messages/
      error-messages.ts
    parsers/
      common.parser.ts
      datetime.parse.ts
      io.parser.ts
    request-validator/
      account.validator.ts
      array-not-duplicated.request-validator.ts
      boolean.request-validator.ts
      date-time.request.validator.ts
      hour-min-format.validator.ts
      id.validator.ts
      month-year-compare.request-validator.ts
      only-date.request-validator.ts
      query-array.validate.ts
      query-array.validator.ts
    types/
      payload-prisma.ts
    validators/
      query.validator.ts
  app.config.ts
  app.module.ts
  main.ts
  swagger.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ACCOUNT ====================
model Account {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  email       String      @db.VarChar(255)
  password    String      @db.VarChar(255)
  accountType AccountType @map("account_type")
  phoneNumber String      @map("phone_number") @db.VarChar(20)
  name String @map("name") @db.VarChar(50)
  gender Gender 
  status AccountStatus @default(ACTIVE)
  dob   DateTime @map("dob")
  bio   String? @db.Text
  addressBase    String? @map("address_base") @db.VarChar(255)
  addressDetail  String? @map("address_detail") @db.VarChar(255)
  suspendedAt BigInt? @map("suspended_at")
  suspensionType AccountSuspensionType? @map("suspension_type") @default(ACCOUNT_NOT_SUSPENDED)

  avatarId Int?  @map("avatar_id")  
  Avatar   File? @relation("accoun_avatar", fields: [avatarId], references: [id])
  
  Students Student[] @relation("student_account")
  Mentors Mentor[]  @relation("mentor_account")
  UserInterestedCategories UserInterestedCategory[] @relation("user_interested_category")
  MentorAcceptants Mentor[] @relation("mentor_acceptant")
  Files File[]
  Rooms AudioRoom[]
  Participants AudioRoomParticipant[]
  CourseCreators Course[] @relation("course_creator")
  Subscriptions Subscription[] @relation("account_subscription")
  ChatMessages ChatMessage[] @relation("chat_message_sender")
  ChatRegistrants ChatParticipant[] @relation("conversation_registrant")
  ChatParticipants ChatParticipant[] @relation("conversation_participant")
  Notifications Notification[] @relation("notification_target_account")
  DeviceTokens DeviceToken[] @relation("account_device_token")
  Reviewers Feedback[] @relation("reviewer_account")
  Tokens Token[]
  Reports Report[] @relation("reporter_account")
  
  @@unique([email, phoneNumber, isActive])
  @@map("accounts")
}

enum AccountSuspensionType {
  ACCOUNT_NOT_SUSPENDED
  ACCOUNT_SUSPENDED_3_DAYS
  ACCOUNT_SUSPENDED_7_DAYS
  ACCOUNT_SUSPENDED_PERMANENTLY
}

model Token {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  token String @unique
  accountId Int @map("account_id")
  type TokenType @map("type")
  Account   Account @relation(fields: [accountId], references: [id])

  @@map("tokens")
}

enum TokenType {
  SESSION
  VERIFY
}

enum AccountStatus {
  ACTIVE
  DEACTIVE
  SUSPENSIVE
}

// ==================== STUDENT ====================
model Student {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  major String @db.VarChar(50)
  educationalLevel EducationalLevel @map("educational_level") 

  accountId Int @map("account_id")
  Account   Account @relation("student_account",fields: [accountId], references: [id])

  @@map("students") 
}

model UserInterestedCategory {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  userId Int @map("user_id")
  User   Account @relation("user_interested_category", fields: [userId], references: [id])

  categoryId Int      @map("category_id")
  Category   Category @relation("interested_category_user", fields: [categoryId], references: [id])

  @@id([userId, categoryId])
  @@map("user_interested_categories")
}

// ==================== MENTOR ==================== 
model Mentor {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  status MentorStatus @map("status")
  description String? @db.Text
  accpetedAt BigInt? @map("accepted_at")

  acceptantId    Int?           @map("acceptant_id")
  Acceptant      Account?       @relation("mentor_acceptant", fields: [acceptantId], references: [id])
  fileId Int? @map("file_id")
  File   File? @relation("cv_file",fields: [fileId], references: [id])
  accountId Int @map("account_id")
  Account   Account @relation("mentor_account", fields: [accountId], references: [id])

  ProfileAchievements ProfileAchievement[] @relation("mentor_profile_achievements")
  MentorSchedules MentorSchedule[] @relation("mentor_schedules")

  @@unique([accountId])
  @@map("mentors")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum MentorStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model ProfileAchievement {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")
  
  type           AchievementType // experience, education, certification
  isCurrent     Boolean         @default(false) @map("is_current")
  name          String? //name of the achievement
  isVisible      Boolean         @default(true) @map("is_visible")
  organization   String?         // Can be company or institution or certification body
  position       String?         // For experience
  major          String?         // For education
  startDate      DateTime?
  endDate        DateTime?
  description    String?
  mentorId Int           @map("mentor_id")
  Mentor   Mentor @relation( "mentor_profile_achievements",fields: [mentorId], references: [id])

  @@index([mentorId, type, isVisible,  isActive])
  @@map("profile_achievements")
}

enum AchievementType {
  EXPERIENCE
  EDUCATION
  CERTIFICATION
}

model MentorSchedule {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  dayOfWeek DayOfWeek @map("day_of_week")
  startTime String @map("start_time") // Format: HH:mm
  endTime String @map("end_time") // Format: HH:mm
  // isBooked Boolean @default(false) @map("is_booked")

  mentorId Int @map("mentor_id")
  Mentor   Mentor @relation("mentor_schedules",fields: [mentorId], references: [id])
  courseId Int? @map("course_id")
  Course   Course? @relation("mentor_schedule_subscription",fields: [courseId], references: [id])

  Subscriptions Subscription[] @relation("mentor_schedule_subscription")

  @@map("mentor_schedules")
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}


// ==================== Course ====================
model Course {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  name        String  @db.VarChar(255)
  status CourseStatus @map("status")
  description String? @db.Text 
  totalDuration     Int? @default(0) @map("total_duration")  // In hours
  price            Decimal @default(0) @map("price")  @db.Decimal(14,2)                       // In VND
  isPublic         Boolean           @default(true) @map("is_public") // If course is public, it can be accessed by anyone
  startDate        DateTime?         @map("start_date")// Start date of the course
  endDate          DateTime?         @map("end_date")// End date of the course
  objectives      String[]           // Course objectives
  targetAudiences TargetAudience[] @map("target_audiences")   // Target audiences for the course
  prerequisites    String[]           // Prerequisites for the course
  litmitOfStudents Int?              @default(100) @map("limit_of_students") // Limit of students for the course
  suspendedAt        BigInt?           @map("stopped_at") // Stop date of the course
  suspensionType CourseSuspensionType? @map("suspension_type") // Suspension type of the course

  imageId Int? @map("image_id")
  Image  File? @relation("course_image",fields: [imageId], references: [id])
  categoryId Int @map("category_id")
  Category   Category @relation("course_category", fields: [categoryId], references: [id])
  creatorId  Int @map("creator_id")
  Creator    Account @relation("course_creator",fields: [creatorId], references: [id])

  Sections          CourseSection[]         // Program courses have multiple sections
  Subscriptions Subscription[] @relation("course_subscription")
  MentorSchedules MentorSchedule[] @relation("mentor_schedule_subscription")

  @@map("courses")
}

enum CourseSuspensionType {
  COURSE_NOT_SUSPENDED
  COURSE_SUSPENDED_1_DAY
  COURSE_SUSPENDED_3_DAYS
  COURSE_SUSPENDED_7_DAYS
  COURSE_SUSPENDED_PERMANENTLY
}

enum CourseStatus {
  DRAFT
  PENDING
  STOPPED
  SUSPENDED
  ARCHIVED
  APPROVED
  REJECTED
}

enum TargetAudience { 
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum CourseType {
  SINGLE_EVENT
  PROGRAM
}

model CourseSection {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title       String  @db.VarChar(255)
  isPublic     Boolean  @map("is_public")          @default(false) // If section is public, it can be accessed by anyone
  ordinal     Int               
  description  String? @db.Text
  data         String?              // Additional data for the section

  courseId Int @map("course_id")
  Course   Course @relation(fields: [courseId], references: [id])

  SectionAttachments SectionAttachment[]

  @@map("course_sections")
}

model SectionAttachment {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  isPublic Boolean @default(true) @map("is_public")

  sectionId Int @map("section_id")
  Section   CourseSection @relation(fields: [sectionId], references: [id])
  fileId   Int @map("file_id")
  File     File @relation(fields: [fileId], references: [id])

  @@id([sectionId, fileId])
  @@map("section_attachments")
}

enum AttachmentType {
  VIDEO
  DOCUMENT
  IMAGE
}

// ==================== CATEGORY ====================
model Category {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  name          String  @db.VarChar(255)
  slug          String  @db.VarChar(255)
  description   String? @db.Text
  noOfProduct   Int     @default(0) @map("no_of_product")
  level         Int     @db.SmallInt
  ordinal       Int     @default(0)
  isRecommended Boolean @default(false) @map("is_recommended")

  parentCategoryId Int?      @map("parent_category_id")
  ParentCategory   Category? @relation("CategoryParentChild", fields: [parentCategoryId], references: [id])

  imageId Int? @map("image_id")
  Image   File? @relation("category_image",fields: [imageId], references: [id])

  Courses Course[] @relation("course_category")
  ChildrenCategories        Category[]                  @relation("CategoryParentChild")
  UserInterestedCategory UserInterestedCategory[] @relation("interested_category_user")

  @@index([name, isActive])
  @@map("categories")
}


enum EducationalLevel {
  PRIMARY
  SECONDARY
  HIGH_SCHOOL
  UNIVERSITY
}

enum AccountType {
  STUDENT
  MENTOR
  ADMIN
}


// ==================== File ====================
model File {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  filename String @default("hello_world") @map("file_name") @db.VarChar(255)
  publicId String @unique @map("public_id")
  url      String @map("url")
  version  Int @default(0) @map("version")
  signature String @map("signature")
  resourceType String @map("resource_type")
  size    Int    @default(0) @map("size")
  uploadedAt BigInt @map("uploaded_at")
  isUploaded Boolean @default(false) @map("is_uploaded")

  registrantId Int?     @map("registrant_id") 
  Registrant   Account? @relation(fields: [registrantId], references: [id])

  AccountAvatars Account[] @relation("accoun_avatar")
  Categories Category[] @relation("category_image")
  SectionAttachments SectionAttachment[]
  ImageVersions ImageVersion[]
  CvFileMentors Mentor[] @relation("cv_file")
  CourseImages Course[] @relation("course_image")

  @@map("files")
}


model ImageVersion {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  type ImageVersionType

  fileId  Int   @unique @map("file_id")
  File    File  @relation(fields: [fileId], references: [id])

  @@map("image_versions")
}

enum ImageVersionType {
  THUMBNAIL
  MEDIUM
  LARGE
}

// ==================== ROOM ====================
model AudioRoom {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title          String    @map("title")
  cid            String?    @unique @map("cid")
  type           AudioRoomType  @map("type")
  activeParticipantCount Int @map("active_participant_count") @default(0)
  isPublic       Boolean  @default(false) @map("is_public")
  status         RoomStatus @map("status") @default(SCHEDULED)
  startsAt       BigInt    @map("starts_at")
  roomUrl        String?    @map("room_url")
  duration       BigInt?    @map("duration")
  metadata       Json?      @map("metadata")
  iat            BigInt?    @map("iat")

  creatorId      Int       @map("creator_id")
  Creator        Account   @relation(fields: [creatorId], references: [id])

  Participants   AudioRoomParticipant[]

  Subscription Subscription? 
  ChatRoom ChatRoom?

  @@map("audio_rooms")
}

enum RoomStatus {
  SCHEDULED
  ONGOING
  FINISHED
  CANCELLED
}

model AudioRoomActivityHistory {
  id       Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  joinedAt       BigInt     @map("joined_at")
  leftAt         BigInt?     @map("left_at") @default(0)

  audioRoomParticipantId Int @map("audio_room_participant_id")
  AudioRoomParticipant   AudioRoomParticipant @relation(fields: [audioRoomParticipantId], references: [id])

  @@map("audio_room_activity_histories")
}

model AudioRoomParticipant {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  role           ParticipantAudioRoomRole  @map("role")
  isInCall       Boolean     @default(false) @map("is_in_room")

  roomId         Int        @map("room_id")
  AudioRoom      AudioRoom  @relation(fields: [roomId], references: [id])
  accountId      Int        @map("account_id") 
  Account        Account    @relation(fields: [accountId], references: [id])

  AudioRoomActivityHistories AudioRoomActivityHistory[]

  @@unique([roomId, accountId])
  @@map("audio_room_participants")
}


enum AudioRoomType {
  DEFAULT
  INTERVIEW
  AUDIOROOM
}

enum ParticipantAudioRoomRole {
  ADMIN
  USER
}


// ==================== SUBSCRIPTION ====================
model Subscription {
  id        Int      @id @default(autoincrement())
  isActive  Boolean  @default(true) @map("is_active")
  createdAt BigInt   @default(0) @map("created_at")
  updatedAt BigInt   @default(0) @map("updated_at")

  status         SubscriptionStatus @default(PENDING)
  originalPrice  Decimal            @default(0) @map("original_price") @db.Decimal(14, 2)
  wageStatus   WageStatus? @map("wage_status") 
  message       String?            @db.Text
  courseAccessStartAt BigInt? @map("course_access_start_at")
  courseAccessEndAt   BigInt? @map("course_access_end_at")
  rejectedAt    BigInt? @map("rejected_at")
  canceledAt    BigInt? @map("canceled_at")
  approvedAt    BigInt? @map("approved_at")
  
  courseId       Int                @map("course_id")
  Course         Course             @relation("course_subscription", fields: [courseId], references: [id])
  accountId      Int                @map("account_id")
  Account        Account            @relation("account_subscription", fields: [accountId], references: [id])
  
  mentorScheduleId Int? @map("mentor_schedule_id")
  MentorSchedule   MentorSchedule? @relation("mentor_schedule_subscription", fields: [mentorScheduleId], references: [id])
  audioRoomId Int? @map("audio_room_id") @unique
  AudioRoom   AudioRoom? @relation(fields: [audioRoomId], references: [id])
  Feedback Feedback?
  Report Report?

  Payment Payment? @relation("subscription_payment")

  @@map("subscriptions")
}

enum WageStatus {
  FULL_WAGE
  PARTIAL_30_PERCENT
  PARTIAL_70_PERCENT
  NOT_PAID
}


enum SubscriptionStatus {
  PENDING
  ACCEPTED
  REJECTED
  ACTIVE
  EXPIRED
  CANCELED
  ENDED
}

// ==================== PAYMENT ====================
model Payment {
  id           Int            @id @default(autoincrement())
  isActive     Boolean        @default(true) @map("is_active")
  createdAt    BigInt         @default(0) @map("created_at")
  updatedAt    BigInt         @default(0) @map("updated_at")

  status       PaymentStatus  @default(IN_PROGRESS)
  price        Decimal        @default(0) @map("price") @db.Decimal(14, 2)
  refundedPrice Decimal?      @map("refunded_price") @db.Decimal(14, 2) @default(0)
  refundedAt   BigInt?        @map("refunded_at")

  subscriptionId Int @map("subscription_id") @unique
  Subscription   Subscription @relation("subscription_payment", fields: [subscriptionId], references: [id])

  VnpayProviders VnpayProvider[] @relation("vnpay_payment")

  @@map("payments")
}

enum PaymentStatus {
  IN_PROGRESS
  DONE // Authorization Succeeded
  CANCELED
  REFUNDED
  PARTIAL_REFUNDED
  EXPIRED
}

model VnpayProvider {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  vnp_TxnRef String @map("vnp_TxnRef")
  vnp_OrderInfo String @map("vnp_OrderInfo")
  vnp_Amount Decimal @map("vnp_Amount") @db.Decimal(14,2)
  vnp_BankCode String? @map("vnp_BankCode")
  vnp_CreatedDate BigInt @map("vnp_createdDate")
  vnp_PayDate BigInt? @map("vnp_PayDate")
  vnp_TransactionNo String? @map("vnp_TransactionNo")
  vnp_TransactionStatus String? @map("vnp_TransactionStatus")

  metadata Json? @map("metadata")

  paymentId Int @map("payment_id") @unique
  Payment   Payment @relation("vnpay_payment",fields: [paymentId], references: [id])

  @@map("vnpay_providers")
}

enum VnpayCardType {
  ATM
  QR_CODE
}


// ==================== Chat Message ====================
model ChatMessage {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  message String? @db.Text
  type   ChatMessageType @map("type")
  isRead  Boolean @default(false) @map("is_read")
  readAt  BigInt? @map("read_at")

  senderId       Int          @map("sender_id")
  Sender         Account      @relation("chat_message_sender", fields: [senderId], references: [id])
  chatRoomId Int          @map("chat_room_id")
  ChatRoom   ChatRoom @relation("chat_messages_room", fields: [chatRoomId], references: [id])

  @@map("chat_messages")
}

enum ChatMessageType {
  TEXT
  FILE
}

model ChatRoom {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  numberOfMessages     Int              @default(0) @map("number_of_messages")
  numberOfParticipants Int              @default(0) @map("number_of_participants")
  chatRoomType     ChatRoomType @default(PRIVATE) @map("chat_room_type")
  lastMessageId        Int?             @map("last_message_id")

  audioRoomId Int? @map("audio_room_id") @unique
  AudioRoom   AudioRoom? @relation(fields: [audioRoomId], references: [id])

  ChatMessages             ChatMessage[]             @relation("chat_messages_room")
  ChatParticipants ChatParticipant[] @relation("chat_participants")

  @@map("chat_rooms")
}

enum ChatRoomType {
  PRIVATE
  GROUP
}

model ChatParticipant {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  chatRoomId Int          @map("chat_room_id")
  ChatRoom   ChatRoom @relation("chat_participants", fields: [chatRoomId], references: [id])
  participantId  Int          @map("participant_id")
  Participant    Account      @relation("conversation_participant", fields: [participantId], references: [id])

  registrantId Int?     @map("registrant_id")
  Registrant   Account? @relation("conversation_registrant", fields: [registrantId], references: [id])

  @@id([chatRoomId, participantId])
  @@map("chat_participants")
}

// ==================== NOTIFICATION ====================
model Notification {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title    String @db.VarChar(255)
  content  String @db.Text

  type   NotificationType
  isRead Boolean          @default(false) @map("is_read")
  readAt BigInt?          @map("read_at")

  scopes NotificationScope[] @default([]) @map("scopes")

  relationType NotificationRelationType @map("relation_type")
  relationId   Int? @map("relation_id")

  targetAccountId Int?     @map("target_account_id") // target account id is used to show notifications of specific account
  TargetAccount   Account? @relation("notification_target_account", fields: [targetAccountId], references: [id])


  @@map("notifications")
}

enum NotificationRelationType {
  COURSE
  SUBSCRIPTION
  PAYMENT
  MENTOR
  AUDIO_CALL
  ADMIN
  FEEDBACK
  REPORT
}

enum NotificationType {
  COURSE_CREATED
  COURSE_UPDATED
  COURSE_DELETED
  COURSE_APPROVED
  COURSE_REJECTED
  COURSE_SUSPENDED_WARNING
  COURSE_SUSPENDED_3_DAYS
  COURSE_SUSPENDED_7_DAYS
  COURSE_SUSPENDED_PERMANENTLY
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_APPROVED
  SUBSCRIPTION_REJECTED
  SUBSCRIPTION_EXPIRED
  SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION
  SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION
  SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION
  SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION
  ACCOUNT_SUSPENDED_WARNING
  ACCOUNT_SUSPENDED_1_DAY
  ACCOUNT_SUSPENDED_3_DAYS
  ACCOUNT_SUSPENDED_7_DAYS
  ACCOUNT_SUSPENDED_PERMANENTLY
  AUDIO_CALL_CREATED
  MENTOR_REGISTERD
  MENTOR_APPROVED
  MENTOR_REJECTED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  DISCOUNT_AVAILABLE
  ADMIN_APPROVAL
  GENERAL_NOTIFICATION

  //FOR REPORT
  COURSE_REPORTED
  MENTOR_REPORTED
  FEEDBACK_REPORTED
  FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT
  REPORT_RESOLVED
  REPORT_REJECTED
}


enum NotificationScope {
  ALL
  INDIVIDUAL
}

model DeviceToken {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  token String @unique

  accountId Int?     @map("account_id")
  Account   Account? @relation("account_device_token", references: [id], fields: [accountId])

  @@map("device_tokens")
}

// ==================== Reviews ====================
model Feedback {
  id          Int      @id @default(autoincrement())
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   BigInt   @default(0) @map("created_at")
  updatedAt   BigInt   @default(0) @map("updated_at")

  isVisible   Boolean  @default(true) @map("is_visible") // Whether the review is visible to others
  courseReview String? @db.Text @map("course_review") // Review content
  courseRating Int @map("course_rating") // Rating for the course
  mentorReview String? @db.Text @map("mentor_review") // Review content
  mentorRating Int @map("mentor_rating") // Rating for the mentor

  reviewerId  Int      @map("reviewer_id") // The account ID of the reviewer
  Reviewer    Account  @relation("reviewer_account", fields: [reviewerId], references: [id])

  subscriptionId Int @map("subscription_id") @unique
  Subscription   Subscription @relation(fields: [subscriptionId], references: [id])

  Report Report?

  @@map("feedbacks")
}

enum ReviewType {
  COURSE
  MENTOR
}


//==================== REPORT ====================
model Report {
  id          Int      @id @default(autoincrement())
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   BigInt   @default(0) @map("created_at")
  updatedAt   BigInt   @default(0) @map("updated_at")

  reporterId  Int      @map("reporter_id") // The account ID of the reporter
  Reporter    Account  @relation("reporter_account", fields: [reporterId], references: [id])
  description String @db.Text
  type        ReportType @map("type")
  status     ReportStatus @default(PENDING)
  resolution String? @db.Text

  subscriptionId Int? @map("subscription_id") @unique
  Subscription   Subscription? @relation(fields: [subscriptionId], references: [id])

  feedbackId Int? @map("feedback_id") @unique
  Feedback   Feedback? @relation(fields: [feedbackId], references: [id])

  @@map("reports")
}

enum ReportStatus {
  PENDING
  RESOLVED
  REJECTED
}

enum ReportType {
  COURSE_UNQUALIFIED
  MENTOR_ISSUES
  FEEDBACK_INAPPROPRIATE
}
</file>

<file path="src/domains/accounts/dto/account-change-password.dto.ts">
import { PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AccountChangePasswordDTO {
  @PasswordValidator()
  currentPassword: string;

  @PasswordValidator()
  newPassword: string;
}
</file>

<file path="src/domains/accounts/dto/account-create.dto.ts">
import { AccountType, Gender } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AccountCreateDTO {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @IsEnum(AccountType)
  accountType: AccountType;

  @NameValidator()
  name: string;

  @IsEnum(Gender)
  gender: Gender;

  @OnlyDate()
  dob: Date;

  @IsString()
  @IsOptional()
  bio?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;
}
</file>

<file path="src/domains/accounts/dto/account-detail.dto.ts">
export type AccountDetailDTO = {
  email: string;
  phoneNumber: string;
};
</file>

<file path="src/domains/accounts/dto/account-update.dto.ts">
import { Gender, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, MaxLength } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AccountUpdateDTO {
  @IsString()
  @IsOptional()
  name?: string;

  @EmailValidator()
  @IsOptional()
  email?: string;

  @PhoneNumberValidator()
  @IsOptional()
  phoneNumber?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @AddressDetailValidator()
  @IsOptional()
  addressDetail?: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  bio?: string;

  @IdValidator()
  @IsOptional()
  avatarId?: number;

  @IsEnum(Gender)
  @IsOptional()
  gender?: Gender;

  @OnlyDate()
  @IsOptional()
  dob?: string;

  static toUpdate(user: AuthUserDTO, body: AccountUpdateDTO): Prisma.AccountUpdateArgs {
    return {
      where: { id: user.accountId },
      data: {
        name: body.name,
        email: body.email,
        gender: body.gender,
        bio: body.bio,
        phoneNumber: body.phoneNumber,
        addressBase: body.addressBase,
        addressDetail: body.addressDetail,
        dob: body.dob && parsePrismaDate(body.dob),
        Avatar: body.avatarId && connectRelation(body.avatarId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/accounts/response/account.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';

export class AccountRESP {
  id: number;
  name: string;
  email: string;
  phoneNumber: string;
  gender: string;
  dob: string;
  addressBase: string | null;
  addressDetail: string | null;
  thumbnail?: ImageRESP;

  static fromEntity(e: AccountRESP, thumbnail?: ImageRESP): AccountRESP {
    return {
      id: e.id,
      name: e.name,
      email: e.email,
      gender: e.gender,
      phoneNumber: e.phoneNumber,
      dob: String(parsePrismaDateToEpoch(e.dob)),
      addressBase: e.addressBase,
      addressDetail: e.addressDetail,
      thumbnail,
    };
  }
}
</file>

<file path="src/domains/accounts/account.controller.ts">
import { Body, Controller, Get, Patch, Post, Req, UseGuards } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountChangePasswordDTO } from 'src/domains/accounts/dto/account-change-password.dto';
import { AccountUpdateDTO } from 'src/domains/accounts/dto/account-update.dto';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';

@Controller('accounts')
@UseGuards(AuthJwtGuard)
export class AccountController {
  constructor(private readonly accountService: AccountService) {}

  @Get('me')
  async get(@Req() req: AuthRequestDTO) {
    const { account, thumbnail } = await this.accountService.getMe(req.user.accountId);

    return BaseResponse.of(
      AccountRESP.fromEntity(
        {
          ...account,
          dob: String(account.dob),
        },
        thumbnail,
      ),
    );
  }

  @Patch('me')
  async update(@Req() req: AuthRequestDTO, @Body() body: AccountUpdateDTO) {
    const response = await this.accountService.updateAccount(req.user, body);
    return BaseResponse.of(response.id);
  }

  @Post('change-password')
  async changePassword(@Req() req: AuthRequestDTO, @Body() body: AccountChangePasswordDTO) {
    const response = await this.accountService.changePassword(req.user.accountId, body);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/accounts/account.service.ts">
import { Injectable } from '@nestjs/common';
import bcrypt from 'bcrypt';

import { AccountStatus } from '@prisma/client';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountErrorMessages } from 'src/shared/messages/error-messages';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ImageService } from '../image/image.service';
import { AccountChangePasswordDTO } from './dto/account-change-password.dto';
import { AccountCreateDTO } from './dto/account-create.dto';
import { AccountUpdateDTO } from './dto/account-update.dto';

@Injectable()
export class AccountService {
  private readonly HASH_ROUND = 10;
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async getMe(accountId: number) {
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: accountId },
      select: {
        id: true,
        name: true,
        email: true,
        gender: true,
        phoneNumber: true,
        dob: true,
        accountType: true,
        addressBase: true,
        addressDetail: true,
        avatarId: true,
      },
    });

    const thumbnail = await this.imageService.getImageOriginal(account.avatarId);

    return { account, thumbnail };
  }

  async createAccount(body: AccountCreateDTO) {
    const account = await this.transactionHost.tx.account.create({
      data: {
        name: body.name,
        gender: body.gender,
        email: body.email,
        dob: body.dob,
        bio: body.bio,
        password: this.hashPassword(body.password),
        phoneNumber: body.phoneNumber,
        accountType: body.accountType,
        addressBase: body.addressBase,
        addressDetail: body.addressDetail,
        status: AccountStatus.DEACTIVE,
      },
      select: { id: true, avatarId: true, name: true, email: true, accountType: true, status: true },
    });

    return account;
  }

  async updateAccount(user: AuthUserDTO, body: AccountUpdateDTO) {
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: user.accountId },
      select: { id: true },
    });

    if (!account) throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_FOUND, AccountErrorMessages.MSG01);

    if (body.avatarId) {
      await this.imageService.linkImageToAccount(user.accountId, body.avatarId);
    }

    if (body.email) {
      const existedAccount = await this.transactionHost.tx.account.findFirst({
        where: { email: body.email, id: { not: user.accountId } },
        select: { id: true },
      });

      if (existedAccount) {
        throw new ActionFailedException(ActionFailed.ACCOUNT_EMAIL_EXISTED, AccountErrorMessages.MSG02);
      }
    }

    if (body.phoneNumber) {
      const existedAccount = await this.transactionHost.tx.account.findFirst({
        where: { phoneNumber: body.phoneNumber, id: { not: user.accountId } },
        select: { id: true },
      });

      if (existedAccount) {
        throw new ActionFailedException(ActionFailed.ACCOUNT_PHONE_NUMBER_EXISTED, AccountErrorMessages.MSG03);
      }
    }

    return await this.transactionHost.tx.account.update(AccountUpdateDTO.toUpdate(user, body));
  }

  async changePassword(accountId: number, body: AccountChangePasswordDTO) {
    await this.checkCurrentPassword(accountId, body.currentPassword);

    return await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { password: this.hashPassword(body.newPassword) },
      select: { id: true },
    });
  }

  async resetPassword(accountId: number, password: string) {
    return await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { password: this.hashPassword(password) },
      select: { id: true },
    });
  }

  async checkCurrentPassword(id: number, currentPassword: string) {
    const account = await this.transactionHost.tx.account.findUniqueOrThrow({
      where: { id: id },
      select: { password: true },
    });

    const isMatch = this.verifyPassword(currentPassword, account.password);
    if (!isMatch) {
      throw new ActionFailedException(ActionFailed.INCORRECT_PASSWORD, AccountErrorMessages.MSG04);
    }
  }

  hashPassword(password: string) {
    return bcrypt.hashSync(password, this.HASH_ROUND);
  }

  verifyPassword(password: string, savedPassword: string) {
    return bcrypt.compareSync(password, savedPassword);
  }
}
</file>

<file path="src/domains/accounts/accounts.module.ts">
import { Module } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { AccountController } from 'src/domains/accounts/account.controller';
import { CommonModule } from 'src/services/common.module';
import { AccountService } from './account.service';

@Module({
  imports: [CommonModule],
  providers: [AccountService, JwtService],
  exports: [AccountService],
  controllers: [AccountController],
})
export class AccountModule {}
</file>

<file path="src/domains/audio-call/admin/dto/audio-call-admin-detail.dto.ts">
import { AudioRoomType, Prisma, RoomStatus } from '@prisma/client';

export class AudioCallAdminDetailDTO {
  id: number;
  name: string;
  title: string;
  cid: string;
  status: RoomStatus;
  type: AudioRoomType;
  startsAt: string;
  roomUrl: string;
  duration: string;
  isPublic: boolean;
  creator: { id: number; name: string };
  custom: Record<string, any>;

  static toFindFirst(roomId: number): Prisma.AudioRoomFindFirstOrThrowArgs {
    return {
      where: { id: roomId },
      select: {
        id: true,
        title: true,
        cid: true,
        status: true,
        isPublic: true,
        type: true,
        startsAt: true,
        roomUrl: true,
        duration: true,
        Creator: { select: { id: true, name: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/dto/participant-dto.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class AudioRoomParticipantDTO {
  @IdValidator()
  accountId: number;

  @IsEnum(ParticipantAudioRoomRole)
  @IsOptional()
  role?: ParticipantAudioRoomRole;

  @IsOptional()
  custom?: Record<string, any>;
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-create.request.ts">
import { AudioRoomType, ParticipantAudioRoomRole, Prisma, RoomStatus } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsJSON, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDateTimeRequestToEpoch } from 'src/shared/parsers/datetime.parse';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';
import { AudioRoomParticipantDTO } from '../dto/participant-dto';

export class AudioCallAdminCreateREQ {
  @IsString()
  title: string;

  @IsEnum(AudioRoomType)
  type: AudioRoomType;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  @IsArray()
  @Type(() => AudioRoomParticipantDTO)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  members: AudioRoomParticipantDTO[];

  @IsString()
  @IsOptional()
  roomUrl?: string;

  @IsEnum(RoomStatus)
  status: RoomStatus;

  @IsJSON()
  @IsOptional()
  metadata?: Record<string, any>;

  static toCreateInput(user: AuthUserDTO, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log('🚀 ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(user.accountId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: user.accountId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }

  static toCreateMemberInput(ownerId: number, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log('🚀 ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(ownerId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: ownerId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallAdminListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallAdminListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-detail.response.ts">
import { AccountType, AudioRoomType, Gender, RoomStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../../shared/types';

export class AudioRoomParticipantRESP {
  id: number;
  name: string;
  gender: Gender;
  dob: string;
  accountType: AccountType;
  thumbnail?: ImageRESP;
  cv?: FileRESP;

  static fromEntity(entity: AudioRoomParticipantGetPayload, thumbnail?: ImageRESP, cv?: FileRESP): AudioRoomParticipantRESP {
    return {
      id: entity.Account.id,
      name: entity.Account.name,
      gender: entity.Account.gender,
      accountType: entity.Account.accountType,
      dob: String(parseDateToEpoch(entity.Account.dob)),
      thumbnail: thumbnail,
      cv: cv,
    };
  }
}

export class AudioCallAdminDetailRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminDetailRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      participants: participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-list.response.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomGetPayload } from '../../shared/types';
import { AudioRoomParticipantRESP } from './audio-call-admin-detail.response';

export class AudioCallAdminListRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  activeParticipantCount: number;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminListRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      activeParticipantCount: entity.activeParticipantCount,
      participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../../auth/dto/auth-request.dto';
import { AudioCallAdminService } from './audio-call-admin.service';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';

@Controller('admin/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class AudioCallAdminController {
  constructor(private readonly audioCallAdminService: AudioCallAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallAdminListREQ) {
    const data = await this.audioCallAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) roomId: number) {
    const room = await this.audioCallAdminService.detail(roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallAdminController } from './audio-call-admin.controller';
import { AudioCallAdminService } from './audio-call-admin.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallAdminController],
  providers: [AudioCallAdminService],
  exports: [AudioCallAdminService],
})
export class AudioCallAdminModule {}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { FileService } from 'src/domains/file/file.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { AuthUserDTO } from '../../auth/dto/auth-user.dto';
import { ImageService } from '../../image/image.service';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallAdminDetailDTO } from './dto/audio-call-admin-detail.dto';
import { AudioCallAdminCreateREQ } from './request/audio-call-admin-create.request';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';
import { AudioCallAdminDetailRESP } from './response/audio-call-admin-detail.response';
import { AudioCallAdminListRESP } from './response/audio-call-admin-list.response';

@Injectable()
export class AudioCallAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createAudioCall(user: AuthUserDTO, body: AudioCallAdminCreateREQ) {
    const call = await this.transactionHost.tx.audioRoom.create(AudioCallAdminCreateREQ.toCreateInput(user, body));
    console.log('🚀 ~ AudioCallAdminService ~ createAudioCall ~ call:', call);

    return call;
  }

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallAdminListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          true,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }

  async detail(roomId: number) {
    const call = (await this.transactionHost.tx.audioRoom.findFirstOrThrow(
      AudioCallAdminDetailDTO.toFindFirst(roomId),
    )) as AudioRoomGetPayload;

    const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
      AudioCallAdminDetailDTO.toFindManyParticipants(roomId),
    )) as AudioRoomParticipantGetPayload[];

    const participantDTOs = await participantMapper(
      participants,
      this.imageService,
      this.fileService,
      this.transactionHost,
      true,
    );

    return AudioCallAdminDetailRESP.fromEntity(call, participantDTOs);
  }

  // @Transactional(TRANSACTION_TIMEOUT)
  // async joinAudioCall(user: AuthUserDTO, roomId: number) {
  //   const call = await this.transactionHost.tx.audioRoom.findFirstOrThrow({
  //     where: { id: roomId },
  //     select: { id: true, status: true, isPublic: true, Participants: { select: { accountId: true, isInCall: true } } },
  //   });

  //   const isPartipatedOrInCall = call.Participants.some(
  //     (participant) => participant.accountId === user.accountId && !participant.isInCall,
  //   );

  //   if (!call.isPublic && !isPartipatedOrInCall) {
  //     throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN);
  //   }

  //   if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
  //     throw new ActionFailedException(ActionFailed.CALL_INVALID);
  //   }

  //   const updatedCall = await this.transactionHost.tx.audioRoom.update({
  //     where: { id: roomId },
  //     data: { activeParticipantCount: { increment: isPartipatedOrInCall ? 0 : COMMON_CONSTANT.DEFAULT_INCREMENT } },
  //     select: { id: true },
  //   });

  //   await this.transactionHost.tx.audioRoomParticipant.upsert({
  //     where: { roomId_accountId: { roomId: updatedCall.id, accountId: user.accountId } },
  //     create: {
  //       isInCall: true,
  //       role: ParticipantAudioRoomRole.USER,
  //       Account: connectRelation(user.accountId),
  //       AudioRoom: connectRelation(updatedCall.id),
  //     },
  //     update: { isInCall: true, joinedAt: nowEpoch() },
  //     select: { roomId: true },
  //   });

  //   return updatedCall;
  // }
}
</file>

<file path="src/domains/audio-call/base/audio-call-list-base.request.ts">
import { AccountType, AudioRoomType, Prisma, RoomStatus } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class AudioCallBaseListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  title?: string;

  @IsEnum(AudioRoomType)
  @IsOptional()
  type?: AudioRoomType;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsEnum(RoomStatus)
  @IsOptional()
  status?: RoomStatus;

  static toFilterByAccount(user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    if (!user) return;
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.MENTOR:
        return {
          OR: [{ Creator: { id: user.accountId } }, { Participants: { some: { accountId: user.accountId } } }],
        };
      case AccountType.STUDENT:
        return {
          isPublic: false,
          Participants: {
            some: { accountId: user.accountId },
          },
        };
      default:
        throw new ActionFailedException(ActionFailed.ACCOUNT_INVALID_ROLE);
    }
  }

  static toQueryCondition(query: AudioCallBaseListREQ, user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    const filtetByAccount = this.toFilterByAccount(user);
    return {
      AND: [filtetByAccount, parsePrismaSearch('title', query.title)],
      type: query.type,
      isPublic: query.isPublic,
      status: query.status,
    };
  }
}
</file>

<file path="src/domains/audio-call/client/request/audio-call-client-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallClientListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallClientListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.controller.ts">
import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AudioCallClientService } from './audio-call-client.service';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Controller('client/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class AudioCallClientController {
  constructor(private readonly audioCallClientService: AudioCallClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallClientListREQ) {
    const data = await this.audioCallClientService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallClientController } from './audio-call-client.controller';
import { AudioCallClientService } from './audio-call-client.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallClientController],
  providers: [AudioCallClientService],
})
export class AudioCallClientModule {}
</file>

<file path="src/domains/audio-call/client/audio-call-client.service.ts">
import { Injectable } from '@nestjs/common';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { AudioCallAdminListREQ } from '../admin/request/audio-call-admin-list.request';
import { AudioCallAdminListRESP } from '../admin/response/audio-call-admin-list.response';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Injectable()
export class AudioCallClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallClientListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          false,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-end.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

export class AudioCallEndDTO {
  static toEnd(roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.FINISHED,
        Participants: {
          updateMany: {
            where: { roomId },
            data: addUpdationTimestamps({ isInCall: false }),
          },
        },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-join.dto.ts">
import { ParticipantAudioRoomRole, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { addCreationTimestamps, addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class AudioCallJoinDTO {
  static toUpsertParticipant(user: AuthUserDTO, roomId: number): Prisma.AudioRoomParticipantUpsertArgs {
    return {
      where: { roomId_accountId: { roomId: roomId, accountId: user.accountId } },
      create: addCreationTimestamps({
        isInCall: true,
        role: ParticipantAudioRoomRole.USER,
        Account: connectRelation(user.accountId),
        AudioRoom: connectRelation(roomId),
      }),

      update: addUpdationTimestamps({
        isInCall: true,
      }),
      select: { roomId: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-start.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class AudioCallStartDTO {
  static toStart(user: AuthUserDTO, roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.ONGOING,
        // Participants: {
        //   update: {
        //     where: { roomId_accountId: { roomId, accountId: user.accountId } },
        //     data: addUpdationTimestamps({ joinedAt: nowEpoch(), isInCall: true }),
        //   },
        // },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/response/audio-call-participant-history.response.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomActivityHistoryGetPayload, AudioRoomParticipantAccount } from '../shared/types';

export class AudioCallParticipantHistoryRESP {
  id: number;
  joinedAt: string;
  leftAt: string;
  AudioParticipant: { accountId: number; role: ParticipantAudioRoomRole } & AudioRoomParticipantAccount;

  static fromEntity(
    e: AudioRoomActivityHistoryGetPayload,
    account: AudioRoomParticipantAccount,
  ): AudioCallParticipantHistoryRESP {
    return {
      id: e.id,
      joinedAt: parseEpoch(e.joinedAt),
      leftAt: parseEpoch(e.leftAt),
      AudioParticipant: {
        accountId: e.AudioRoomParticipant.accountId,
        name: account.name,
        thumbnail: account.thumbnail,
        role: e.AudioRoomParticipant.role,
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/shared/helpers.ts">
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { AudioRoomParticipantRESP } from '../admin/response/audio-call-admin-detail.response';
import { AudioRoomParticipantGetPayload } from './types';

export const participantMapper = async (
  participants: AudioRoomParticipantGetPayload[],
  imageService: ImageService,
  fileService: FileService,
  transactionHost: any,
  isCvPublic: boolean = false,
): Promise<AudioRoomParticipantRESP[]> => {
  return await Promise.all(
    participants.map(async (participant: AudioRoomParticipantGetPayload) => {
      const thumbnail = await imageService.getImageOriginal(participant.Account.avatarId);
      let cv: any;
      if (participant.Account.accountType === 'MENTOR') {
        const mentor = await transactionHost.tx.mentor.findFirst({
          where: { accountId: participant.Account.id },
          select: {
            fileId: true,
          },
        });

        cv = isCvPublic ? await fileService.detail(mentor.fileId) : null;
      }

      return AudioRoomParticipantRESP.fromEntity(participant, thumbnail, cv);
    }),
  );
};
</file>

<file path="src/domains/audio-call/shared/types.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';

export type AudioRoomParticipantAccount = Pick<AccountRESP, 'name' | 'thumbnail'>;

export type AudioRoomGetPayload = Prisma.AudioRoomGetPayload<{
  include: {
    Participants: true;
    Creator: true;
    Subscription: true;
  };
}>;

export type AudioRoomParticipantGetPayload = Prisma.AudioRoomParticipantGetPayload<{
  include: { Account: true; AudioRoom: true; AudioRoomActivityHistories: true };
}>;

export type AudioRoomActivityHistoryGetPayload = Prisma.AudioRoomActivityHistoryGetPayload<{
  include: { AudioRoomParticipant: true };
}>;

export type AudioRoomSessionParticipantLeave = {
  call_cid: string;
  participant: { user: { id: number } };
};
</file>

<file path="src/domains/audio-call/audio-call.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Patch, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { AudioCallService } from './audio-call.service';

@Controller('audio-call')
@UseGuards(AuthJwtGuard)
export class AudioCallController {
  constructor(private readonly AudioCallService: AudioCallService) {}

  @Get(':id/histories')
  async histories(@Param('id', ParseIntPipe) roomId: number) {
    const histories = await this.AudioCallService.getAudioCallHistory(roomId);
    return BaseResponse.of(histories);
  }

  @Patch(':id/join')
  async join(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.joinAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/leave')
  async leave(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.leaveAudioCall(req.user.accountId, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/start')
  async start(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.startAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/end')
  async end(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.endAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/audio-call.gateway.ts">
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { AudioCallChannel } from 'src/shared/constants/event.constant';
import { AudioCallService } from './audio-call.service';
import { AudioRoomSessionParticipantLeave } from './shared/types';

@Injectable()
export class AudioCallGateway {
  private readonly logger = new Logger(AudioCallGateway.name);
  constructor(private readonly audioCallService: AudioCallService) {}

  @OnEvent(AudioCallChannel.LEAVE_CALL)
  async handleParticipantSessionLeave(payload: AudioRoomSessionParticipantLeave) {
    const cid = payload.call_cid;
    this.logger.log('🚀 ~ AudioCallGateway ~ handleParticipantSessionLeave ~ cid:', cid);

    const roomId = cid.split('-')[1];
    if (!payload) {
      return;
    }

    await this.audioCallService.leaveAudioCall(Number(payload.participant.user.id), Number(roomId));
  }
}
</file>

<file path="src/domains/audio-call/audio-call.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from './admin/audio-call-admin.module';
import { AudioCallController } from './audio-call.controller';
import { AudioCallGateway } from './audio-call.gateway';
import { AudioCallService } from './audio-call.service';
import { AudioCallClientModule } from './client/audio-call-client.module';

@Module({
  imports: [AudioCallAdminModule, AudioCallClientModule],
  controllers: [AudioCallController],
  providers: [AudioCallService, AudioCallGateway],
  exports: [AudioCallService],
})
export class AudioCallModule {}
</file>

<file path="src/domains/audio-call/audio-call.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AudioCallService } from './admin/audio-call-admin.service';

describe('AudioCallService', () => {
  let service: AudioCallService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AudioCallService],
    }).compile();

    service = module.get<AudioCallService>(AudioCallService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/audio-call/audio-call.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomParticipant,
  AudioRoomType,
  ParticipantAudioRoomRole,
  RoomStatus,
  SubscriptionStatus,
  WageStatus,
} from '@prisma/client';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { AUDIO_ROOM_CONSTANT, AudioRoomActivity } from 'src/shared/constants/audio-room.constant';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { asyncSome } from 'src/shared/helpers/function.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { AudioCallErrorMessages } from 'src/shared/messages/error-messages';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ImageService } from '../image/image.service';
import { AudioCallEndDTO } from './dto/audio-call-end.dto';
import { AudioCallJoinDTO } from './dto/audio-call-join.dto';
import { AudioCallStartDTO } from './dto/audio-call-start.dto';
import { AudioCallParticipantHistoryRESP } from './response/audio-call-participant-history.response';
import { AudioRoomActivityHistoryGetPayload, AudioRoomGetPayload } from './shared/types';

@Injectable()
export class AudioCallService {
  private readonly logger = new Logger(AudioCallService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async getAudioCallHistory(audioRoomId: number) {
    await this.checkExistedRoom(audioRoomId);
    const histories = await this.transactionHost.tx.audioRoomActivityHistory.findMany({
      where: { AudioRoomParticipant: { roomId: audioRoomId } },
      select: {
        id: true,
        joinedAt: true,
        leftAt: true,
        AudioRoomParticipant: { select: { accountId: true, role: true } },
      },
    });

    return await Promise.all(
      histories.map(async (history: AudioRoomActivityHistoryGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(history.AudioRoomParticipant.accountId);
        const account = await this.transactionHost.tx.account.findFirst({
          where: { id: history.AudioRoomParticipant.accountId },
          select: { name: true },
        });

        return AudioCallParticipantHistoryRESP.fromEntity(history, {
          name: account.name,
          thumbnail,
        });
      }),
    );
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async startAudioCall(user: AuthUserDTO, roomId: number) {
    console.log('🚀 ~ AudioCallService ~ startAudioCall ~ user:', user.accountId);
    /* Check existed call */
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const havePermissionToStart = await asyncSome<AudioRoomParticipant>(call.Participants, async (participant) => {
      const isInOtherCall = await this.checkAccountInCall(participant.accountId, roomId);
      console.log('🚀 ~ AudioCallService ~ havePermissionToStart ~ isInOtherCall:', isInOtherCall);

      const tmp =
        participant.accountId === user.accountId &&
        participant.role === ParticipantAudioRoomRole.ADMIN &&
        !participant.isInCall &&
        !isInOtherCall;

      return tmp;
    });

    if (!havePermissionToStart) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG02);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* Update status of call & participant started call */
    const updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallStartDTO.toStart(user, roomId));

    //TODO: Implement push notification to all participants

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async endAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const canEndCall = call.Participants.some(
      (participant) => participant.accountId === user.accountId && participant.role === ParticipantAudioRoomRole.ADMIN,
    );

    if (!canEndCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG03);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const now = nowEpoch();
    let updatedCall: any;
    if (call.Subscription) {
      const courseAccessStartAt = parseEpoch(call.Subscription.courseAccessStartAt);
      const courseAccessEndAt = parseEpoch(call.Subscription.courseAccessEndAt);

      if (now > courseAccessStartAt && now < courseAccessEndAt) {
        throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      } else {
        const subcription = await this.transactionHost.tx.subscription.update({
          where: { id: call.Subscription.id },
          data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
          select: { id: true },
        });

        this.logger.log(`🚀 ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      }

      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      // if (now > courseAccessStartAt && now < courseAccessEndAt) {
      //   throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      // } else if (now < courseAccessStartAt) {
      //   this.logger.log(`🚀 ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      //   updatedCall = await this.transactionHost.tx.audioRoomParticipant.updateMany({
      //     where: { roomId: roomId, isInCall: true },
      //     data: { isInCall: false },
      //   });
      // } else {
      //   const subcription = await this.transactionHost.tx.subscription.update({
      //     where: { id: call.Subscription.id },
      //     data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
      //     select: { id: true },
      //   });

      //   this.logger.log(`🚀 ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      //   updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));
      // }

      /* Update status of call & participant started call */
      this.logger.log(`🚀 ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    } else if (call.type === AudioRoomType.INTERVIEW) {
      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    }

    const callId = updatedCall ? updatedCall.id : roomId;

    await this.transactionHost.tx.audioRoomActivityHistory.updateMany({
      where: { AudioRoomParticipant: { roomId: callId }, leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT },
      data: { leftAt: nowEpoch() },
    });

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async joinAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);
    const isInCall = await this.checkAccountInCall(user.accountId, roomId);

    const isPartipated = call.Participants.some(
      (participant) => participant.accountId === user.accountId && !participant.isInCall,
    );

    if (isInCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG05);
    } else if (!call.isPublic && !isPartipated) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG06);
    }

    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { increment: COMMON_CONSTANT.DEFAULT_INCREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.upsert(AudioCallJoinDTO.toUpsertParticipant(user, roomId));
    await this.createPaticipantHistory(user.accountId, updatedCall.id, AudioRoomActivity.JOIN);

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async leaveAudioCall(accountId: number, roomId: number) {
    /* Check existed audio room */
    const call = await this.checkExistedRoom(roomId);
    const participants = await this.getAllParticipants(roomId);

    /* Check if user is joinning the audio room */
    const isPartipated = participants.some((participant) => participant.accountId === accountId && participant.isInCall);

    if (!isPartipated) {
      this.logger.error(`🚀 ~ AudioCallService ~ leaveAudioCall ~ the user with id ${accountId} is not in call`);
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_LEAVE);
    }

    /* Check the status of room */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      this.logger.error(`🚀 ~ AudioCallService ~ leaveAudioCall ~ the call status is invalid`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* We must decrement the number of participant */
    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { decrement: COMMON_CONSTANT.DEFAULT_DECREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.update({
      where: { roomId_accountId: { roomId: updatedCall.id, accountId: accountId } },
      data: { isInCall: false },
      select: { roomId: true },
    });

    await this.createPaticipantHistory(accountId, updatedCall.id, AudioRoomActivity.LEAVE);

    return updatedCall;
  }

  async createPaticipantHistory(accountId: number, roomId: number, type: AudioRoomActivity) {
    if (!accountId || !roomId) {
      this.logger.error(`🚀 ~ AudioCallService ~ createPaticipantHistory ~ invalid accountId or roomId`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID);
    }

    const participant = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: { accountId, roomId },
      select: { id: true },
    });

    if (!participant) {
      this.logger.error(`🚀 ~ AudioCallService ~ createPaticipantHistory ~ the participant is not existed`);
      throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_NOT_FOUND);
    }

    //Find the lastest record of participant
    const lastestRecord = await this.transactionHost.tx.audioRoomActivityHistory.findFirst({
      where: { leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT, audioRoomParticipantId: participant.id },
      select: { id: true },
    });
    this.logger.log('🚀 ~ AudioCallService ~ createPaticipantHistory ~ lastestRecord:', lastestRecord);

    if (type === AudioRoomActivity.JOIN) {
      //If the lastest record is existed with joinedAt but not leftAt
      // then the user is already in call
      if (lastestRecord) {
        throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_JOINED, AudioCallErrorMessages.MSG08);
      }

      await this.transactionHost.tx.audioRoomActivityHistory.create({
        data: {
          AudioRoomParticipant: connectRelation(participant.id),
          joinedAt: nowEpoch(),
        },
      });
    } else {
      // If the lastest record is existed with joinedAt but not leftAt
      // Then we will update the leftAt field
      await this.transactionHost.tx.audioRoomActivityHistory.update({
        where: { id: lastestRecord.id },
        data: { leftAt: nowEpoch() },
      });
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancelCall(roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    if (call.status === RoomStatus.FINISHED || call.status === RoomStatus.ONGOING) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { status: RoomStatus.CANCELLED },
      select: { id: true },
    });

    return updatedCall;
  }

  private async checkExistedRoom(roomId: number): Promise<AudioRoomGetPayload> {
    const call = (await this.transactionHost.tx.audioRoom.findFirst({
      where: { id: roomId },
      select: {
        id: true,
        status: true,
        type: true,
        isPublic: true,
        Subscription: { select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true } },
        Participants: { select: { accountId: true, isInCall: true, role: true } },
        activeParticipantCount: true,
      },
    })) as AudioRoomGetPayload;

    if (!call) {
      throw new ActionFailedException(ActionFailed.CALL_NOT_FOUND);
    }

    return call;
  }

  private async checkAccountInCall(accountId: number, roomId: number): Promise<boolean> {
    const call = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: {
        accountId,
        isInCall: true,
        roomId: { not: roomId },
        AudioRoom: { status: RoomStatus.ONGOING },
      },
      select: { roomId: true },
    });

    console.log('🚀 ~ AudioCallService ~ checkAccountInCall ~ isInCall:', call);

    return !!call;
  }

  private async getAllParticipants(roomId: number) {
    const participants = await this.transactionHost.tx.audioRoomParticipant.findMany({
      where: { roomId },
      select: { accountId: true, role: true, isInCall: true },
    });

    return participants;
  }
}
</file>

<file path="src/domains/auth/dto/auth-jwt-payload.dto.ts">
import jwt from 'jsonwebtoken';
export type AuthJwtPayloadDTO = Pick<jwt.JwtPayload, 'sub'>;
</file>

<file path="src/domains/auth/dto/auth-login.dto.ts">
import { Prisma } from '@prisma/client';

import { AuthLoginREQ } from '../request/auth-login.request';

export class AuthLoginDTO {
  email: string;
  password: string;
  ipAddress?: string;

  static fromRequest(body: AuthLoginREQ, ipAddress: string): AuthLoginDTO {
    return { email: body.email, password: body.password, ipAddress };
  }

  static toFindAccountUnique(body: AuthLoginDTO): Prisma.AccountFindFirstOrThrowArgs {
    return {
      where: { email: body.email },
      select: {
        name: true,
        id: true,
        email: true,
        password: true,
        accountType: true,
        avatarId: true,
      },
    };
  }
}
</file>

<file path="src/domains/auth/dto/auth-request.dto.ts">
import { Request } from 'express';

import { AuthUserDTO } from './auth-user.dto';

export type AuthRequestDTO = Request & { user: AuthUserDTO };
</file>

<file path="src/domains/auth/dto/auth-user.dto.ts">
import { Account, Prisma } from '@prisma/client';

export class AuthUserDTO {
  accountId: Account['id'];
  email: Account['email'];
  phoneNumber: Account['phoneNumber'];
  accountType: Account['accountType'];

  static fromEntity(a: Prisma.AccountGetPayload<unknown>): AuthUserDTO {
    return {
      accountId: a.id,
      email: a.email,
      phoneNumber: a.phoneNumber,
      accountType: a.accountType,
    };
  }
}
</file>

<file path="src/domains/auth/request/auth-email--reset-password.request.ts">
import { EmailValidator } from 'src/shared/request-validator/account.validator';

export class AuthFindPasswordResetREQ {
  @EmailValidator()
  email: string;
}
</file>

<file path="src/domains/auth/request/auth-email-verification.request.ts">
import { EmailValidator } from 'src/shared/request-validator/account.validator';

export class AuthEmailVerificationREQ {
  @EmailValidator()
  email: string;
}
</file>

<file path="src/domains/auth/request/auth-find-password-reset.request.ts">
import { IsString } from 'class-validator';
import { PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AuthFindPasswordResetREQ {
  @PasswordValidator()
  password: string;

  @IsString()
  token: string;
}
</file>

<file path="src/domains/auth/request/auth-login.request.ts">
import { EmailValidator, PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AuthLoginREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;
}
</file>

<file path="src/domains/auth/request/auth-mentor-register.request.ts">
import { AccountType, AchievementType, Gender, MentorStatus, Prisma } from '@prisma/client';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  ArrayMinSize,
  IsArray,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  MaxLength,
  ValidateIf,
  ValidateNested,
} from 'class-validator';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  OtpValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthMentorRegisterREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @NameValidator()
  name: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @OnlyDate()
  dob: string;

  @IsEnum(Gender)
  gender: Gender;

  @IsArray()
  @IsNotEmpty()
  @ArrayMaxSize(3)
  @ArrayMinSize(1)
  @Type(() => AuthMentorAchievementREQ)
  @ValidateNested({ each: true })
  achievements: AuthMentorAchievementREQ[];

  @OtpValidator()
  @IsOptional()
  phoneOtpCode?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  @IsOptional()
  @IsNumber()
  avatarId?: number;

  static toCreateAccountDto(body: AuthMentorRegisterREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);

    return {
      name: body.name,
      gender: body.gender,
      email: body.email,
      password: body.password,
      phoneNumber: body.phoneNumber,
      addressBase: body.addressBase,
      addressDetail: body.addressDetail,
      dob: new Date(parseDob),
      accountType: AccountType.MENTOR,
    };
  }

  static toCreateMentorArgs(body: AuthMentorRegisterREQ, accountId: number): Prisma.MentorCreateArgs {
    return {
      data: {
        status: MentorStatus.PENDING,
        Account: connectRelation(accountId),
      },
      select: { id: true, accountId: true },
    };
  }

  static toCreateMentorProfileArgs(body: AuthMentorRegisterREQ, mentorId: number): Prisma.ProfileAchievementCreateManyArgs {
    console.log('🚀 ~ AuthMentorRegisterREQ ~ toCreateMentorProfileArgs ~ mentorId:', mentorId);
    console.log('🚀 ~ AuthMentorRegisterREQ ~ toCreateMentorProfileArgs ~ body:', body);
    return {
      data: body.achievements.map((achievement) => {
        return AuthMentorAchievementREQ.ToCreateByAchievementType(achievement, mentorId);
      }),
    };
  }
}

export class AuthMentorAchievementREQ {
  @NameValidator()
  @ValidateIf((o) => o.achievementType === AchievementType.CERTIFICATION)
  name: string;

  @IsString()
  @MaxLength(255)
  organization: string; // Can be company or institution or certification body

  @IsEnum(AchievementType)
  achievementType: AchievementType;

  @IsString()
  @MaxLength(255)
  @IsOptional()
  description?: string;

  @BooleanValidator()
  @IsOptional()
  isCurrent?: boolean = false;

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EXPERIENCE)
  position: string; // For experience

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EDUCATION)
  major: string; // For education

  @OnlyDate()
  startDate: string;

  @OnlyDate()
  @DateMonthYearCompare({ startField: 'startDate' })
  @ValidateIf((o) => !o.isCurrent)
  endDate: string;

  static ToCreateByAchievementType(body: AuthMentorAchievementREQ, mentorId: number): Prisma.ProfileAchievementCreateManyInput {
    const endDate = body.isCurrent ? null : parsePrismaDate(body.endDate);

    switch (body.achievementType) {
      case AchievementType.EXPERIENCE:
        return {
          mentorId: mentorId,
          organization: body.organization,
          description: body.description,
          position: body.position,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          mentorId: mentorId,
          organization: body.organization,
          description: body.description,
          major: body.major,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          mentorId: mentorId,
          name: body.name,
          organization: body.organization,
          description: body.description,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
</file>

<file path="src/domains/auth/request/auth-otp-checkout.request.ts">
import { OtpValidator, PhoneNumberValidator } from 'src/shared/request-validator/account.validator';

export class AuthOtpCheckoutREQ {
  @PhoneNumberValidator()
  phoneNumber: string;

  @OtpValidator()
  otpCode: string;
}
</file>

<file path="src/domains/auth/request/auth-otp-send.request.ts">
import { PhoneNumberValidator } from 'src/shared/request-validator/account.validator';

export class AuthOtpSendREQ {
  @PhoneNumberValidator()
  phoneNumber: string;
}
</file>

<file path="src/domains/auth/request/auth-student-register.request.ts">
import { AccountType, EducationalLevel, Gender, Prisma } from '@prisma/client';
import { IsEnum, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  OtpValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthRegistrationStudentREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @NameValidator()
  name: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @IsString()
  @MaxLength(255)
  major: string;

  @IsEnum(EducationalLevel)
  educationLevel: EducationalLevel;

  @OnlyDate()
  dob: string;

  @IsEnum(Gender)
  gender: Gender;

  @OtpValidator()
  @IsOptional()
  phoneOtpCode?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  static toCreateAccountDto(body: AuthRegistrationStudentREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);

    return {
      name: body.name,
      gender: body.gender,
      email: body.email,
      password: body.password,
      phoneNumber: body.phoneNumber,
      addressBase: body.addressBase,
      addressDetail: body.addressDetail,
      dob: new Date(parseDob),
      accountType: AccountType.STUDENT,
    };
  }

  static toCreateStudentArgs(body: AuthRegistrationStudentREQ, accountId: number): Prisma.StudentCreateArgs {
    return {
      data: {
        Account: connectRelation(accountId),
        major: body.major,
        educationalLevel: body.educationLevel,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/auth/request/auth-test-account.request.ts">
import { AccountType, Gender } from '@prisma/client';
import { IsOptional } from 'class-validator';
import { random } from 'lodash';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { EmailValidator, NameValidator, PasswordValidator } from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthTestAccountREQ {
  @EmailValidator()
  email: string;

  @NameValidator()
  name: string;

  @OnlyDate()
  dob: string;

  @PasswordValidator()
  password: string;

  @IsOptional()
  accountType?: AccountType = AccountType.STUDENT;

  static toAccountDto(body: AuthTestAccountREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);
    return {
      name: body.name,
      dob: new Date(parseDob),
      gender: Gender.MALE,
      email: body.email,
      password: body.password,
      phoneNumber: `628${random(1000000000)}`,
      accountType: body.accountType,
    };
  }
}
</file>

<file path="src/domains/auth/response/auth-find-password.response.ts">
export class AuthFindPasswordRESP {
  phoneNumber: string;
  verificationCode: string;

  static fromBuyer(phoneNumber: string, verificationCode: string): AuthFindPasswordRESP {
    return { phoneNumber, verificationCode };
  }
}
</file>

<file path="src/domains/auth/response/auth-login.response.ts">
import { Prisma } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';

export class AuthLoginRESP {
  id: number;
  accessToken: string;
  accountType: string;
  name: string;
  avatar: ImageRESP;

  static fromAccount(account: Prisma.AccountGetPayload<unknown>, accessToken: string, avatar: ImageRESP): AuthLoginRESP {
    return {
      id: account.id,
      name: account.name,
      accessToken,
      accountType: account.accountType,
      avatar: avatar,
    };
  }
}
</file>

<file path="src/domains/auth/response/auth-register.response.ts">
import { AccountStatus, AccountType, Prisma } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';

export class AuthRegisterRESP {
  id: number;
  accountType: AccountType;
  name: string;
  status: AccountStatus;
  avatar: ImageRESP;
  token?: string;

  static fromAccount(account: Prisma.AccountGetPayload<unknown>, avatar: ImageRESP, token?: string): AuthRegisterRESP {
    return {
      id: account.id,
      name: account.name,
      avatar: avatar,
      status: account.status,
      accountType: account.accountType,
      token,
    };
  }
}
</file>

<file path="src/domains/auth/auth-jwt.guard.ts">
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';
import { IS_PUBLIC_KEY } from './auth-public.decorator';

@Injectable()
export class AuthJwtGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    // const token = this.extractTokenFromHeader(request);

    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [context.getHandler(), context.getClass()]);
    if (isPublic) return true;

    return super.canActivate(context);
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers['authorization']?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
</file>

<file path="src/domains/auth/auth-jwt.strategy.ts">
import { Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { AccountStatus, TokenType } from '@prisma/client';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { JWT_SECRET_KEY } from 'src/app.config';
import { PrismaService } from 'src/services/prisma/prisma.service';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AuthJwtPayloadDTO } from './dto/auth-jwt-payload.dto';
import { AuthUserDTO } from './dto/auth-user.dto';

@Injectable()
export class AuthJwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  private readonly logger = new Logger(AuthJwtStrategy.name);
  constructor(private readonly prismaService: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: JWT_SECRET_KEY,
      ignoreExpiration: false,
      passReqToCallback: true,
    });
  }

  async validate(req: Request, payload: AuthJwtPayloadDTO): Promise<AuthUserDTO> {
    const accessToken = req.headers['authorization'].split(' ')[1];
    const existedToken = await this.prismaService.token.findFirst({
      where: { token: accessToken, type: TokenType.VERIFY },
      select: { id: true },
    });

    if (existedToken) {
      this.logger.warn(`Token ${accessToken} is taken by another account, this token will be revoked`);
      await this.prismaService.token.delete({ where: { id: existedToken.id } });
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID);
    }

    const account = await this.prismaService.account.findUnique({
      where: { id: Number(payload.sub) },
      select: {
        id: true,
        email: true,
        phoneNumber: true,
        accountType: true,
        status: true,
      },
    });

    if (!account) throw new UnauthorizedException('Account not found');
    if (account.status === AccountStatus.SUSPENSIVE) throw new ActionFailedException(ActionFailed.ACCOUNT_SUSPENDED);
    if (account.status !== AccountStatus.ACTIVE) throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_VERIFIED);

    return AuthUserDTO.fromEntity(account as any);
  }
}
</file>

<file path="src/domains/auth/auth-public.decorator.ts">
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
</file>

<file path="src/domains/auth/auth-role.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { AccountType } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: AccountType[]) => SetMetadata(ROLES_KEY, roles);
</file>

<file path="src/domains/auth/auth-role.guard.ts">
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { IS_PUBLIC_KEY } from './auth-public.decorator';
import { AuthRequestDTO } from './dto/auth-request.dto';
import { AccountType } from '.prisma/client';
import { ROLES_KEY } from './auth-role.decorator';

@Injectable()
export class AuthRoleGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  canActivate(context: ExecutionContext): boolean {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [context.getHandler(), context.getClass()]);
    if (isPublic) return true;

    const requiredRoles = this.reflector.getAllAndOverride<AccountType[]>(ROLES_KEY, [context.getHandler(), context.getClass()]);
    if (!requiredRoles) return true;
    const { user } = context.switchToHttp().getRequest<AuthRequestDTO>();
    return requiredRoles.some((role) => role === user?.accountType);
  }
}
</file>

<file path="src/domains/auth/auth.controller.ts">
import { Body, Controller, Get, HttpCode, HttpStatus, Ip, Logger, Param, Patch, Post, Req } from '@nestjs/common';
import { ApiResponse, ApiTags } from '@nestjs/swagger';

import { BaseResponse } from 'src/shared/generics/base.response';
import { ImageService } from '../image/image.service';
import { AuthService } from './auth.service';
import { AuthLoginDTO } from './dto/auth-login.dto';
import { AuthEmailVerificationREQ } from './request/auth-email-verification.request';
import { AuthFindPasswordResetREQ } from './request/auth-find-password-reset.request';
import { AuthLoginREQ } from './request/auth-login.request';
import { AuthMentorRegisterREQ } from './request/auth-mentor-register.request';
import { AuthRegistrationStudentREQ } from './request/auth-student-register.request';
import { AuthTestAccountREQ } from './request/auth-test-account.request';
import { AuthRegisterRESP } from './response/auth-register.response';

@Controller('auth')
@ApiTags('Auth')
export class AuthController {
  private readonly logger = new Logger(AuthController.name);
  constructor(
    private readonly authService: AuthService,
    private readonly imageService: ImageService,
  ) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Login successfully',
    type: BaseResponse<AuthLoginDTO>,
    example: {
      data: {
        accessToken:
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiaWF0IjoxNzI1NDczOTg2LCJleHAiOjE3MjgwNjU5ODZ9.Um00Niu0CP6WsaaS4jRjWUKbelFkgqMCP4COBKI-xYk',
        accountType: 'STUDENT',
      },
      message: 'OK',
    },
  })
  async login(@Body() body: AuthLoginREQ, @Ip() ip: string, @Req() req) {
    const ipAddress = req.headers['x-forwarded-for'] || ip;
    return await this.authService.login(AuthLoginDTO.fromRequest(body, ipAddress));
  }

  @Post('students/register')
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'Register student successfully',
    type: BaseResponse,
    example: {
      data: 201,
      message: 'OK',
    },
  })
  async registerStudent(@Body() body: AuthRegistrationStudentREQ) {
    const { account, imageId } = await this.authService.registerStudent(body);

    return BaseResponse.of(AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId)));
  }

  @Post('mentors/register')
  async registerMentor(@Body() body: AuthMentorRegisterREQ) {
    const { account, imageId } = await this.authService.registerMentor(body);
    this.logger.log('🚀 ~ AuthController ~ registerMentor ~ imageId:', imageId);

    return BaseResponse.of(AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId)));
  }

  @Patch('verification/:token')
  async verifyEmail(@Param('token') token: string) {
    const { account, jwtToken, imageId } = await this.authService.verifyEmail(token);

    return BaseResponse.of(
      AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId), jwtToken),
    );
  }

  @Get('tokens/:token')
  async verifyToken(@Param('token') token: string) {
    await this.authService.verifyToken(token);

    return BaseResponse.ok();
  }

  @Post('email/forgot-password')
  async sendEmailResetPassword(@Body() body: AuthEmailVerificationREQ) {
    await this.authService.sendEmailForgotPassword(body);

    return BaseResponse.ok();
  }

  @Patch('/reset-password')
  @ApiResponse({ description: 'Reset password successfully' })
  async findPasswordReset(@Body() body: AuthFindPasswordResetREQ) {
    await this.authService.resetPassword(body);

    return BaseResponse.ok();
  }

  @Post('test-accounts')
  async createTestAccount(@Body() body: AuthTestAccountREQ) {
    const account = await this.authService.createTestAccount(body);
    return account;
  }
}
</file>

<file path="src/domains/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { JWT_ACCESS_TOKEN_EXPIRE_HOURS, JWT_SECRET_KEY } from 'src/app.config';

import { CommonModule } from 'src/services/common.module';
import { AccountModule } from '../accounts/accounts.module';
import { AuthJwtStrategy } from './auth-jwt.strategy';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

@Module({
  imports: [
    CommonModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: JWT_SECRET_KEY,
      signOptions: { algorithm: 'HS256', expiresIn: JWT_ACCESS_TOKEN_EXPIRE_HOURS },
      verifyOptions: { algorithms: ['HS256'] },
    }),
    AccountModule,
  ],
  controllers: [AuthController],
  providers: [AuthJwtStrategy, AuthService],
  exports: [AuthService],
})
export class AuthModule {}
</file>

<file path="src/domains/auth/auth.service.ts">
import { BadRequestException, Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { AccountStatus, AccountType, NotificationRelationType, NotificationType, Token, TokenType } from '@prisma/client';
import { EMAIL_VERIFY_URL } from 'src/app.config';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { PrismaRawService } from 'src/services/prisma/prisma-raw.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { EMAIL_NOTIFICATION, EMAIL_PATH, EMAIL_TEMPLATES } from 'src/shared/constants/notification.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { BaseResponse } from 'src/shared/generics/base.response';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { AccountErrorMessages } from 'src/shared/messages/error-messages';
import { AccountService } from '../accounts/account.service';
import { FileService } from '../file/file.service';
import { ImageService } from '../image/image.service';
import { NotificationHelper } from '../notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel, NotificationEmailPayload } from '../notification/shared/types';
import { AuthJwtPayloadDTO } from './dto/auth-jwt-payload.dto';
import { AuthLoginDTO } from './dto/auth-login.dto';
import { AuthEmailVerificationREQ } from './request/auth-email-verification.request';
import { AuthFindPasswordResetREQ } from './request/auth-find-password-reset.request';
import { AuthMentorRegisterREQ } from './request/auth-mentor-register.request';
import { AuthRegistrationStudentREQ } from './request/auth-student-register.request';
import { AuthTestAccountREQ } from './request/auth-test-account.request';
import { AuthLoginRESP } from './response/auth-login.response';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  constructor(
    private readonly jwtService: JwtService,
    private readonly transactionHost: TransactionHost,
    private readonly prismaRawService: PrismaRawService,
    private readonly accountService: AccountService,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  async login(body: AuthLoginDTO) {
    /* 1. Validate credential */
    try {
      const account = await this.transactionHost.tx.account.findFirstOrThrow(AuthLoginDTO.toFindAccountUnique(body));
      const isMatched = this.accountService.verifyPassword(body.password, account.password);
      if (!isMatched) throw new BadRequestException('Wrong password or username');

      /* 2. Validate login request (SKIP for SUPER_ADMIN) */
      const jwtToken = this.jwtService.sign({
        sub: String(account.id),
      } as AuthJwtPayloadDTO);

      return BaseResponse.of(
        AuthLoginRESP.fromAccount(account as any, jwtToken, await this.imageService.getImageOriginal(account.avatarId)),
      );
    } catch (e) {
      this.logger.error('🚀 ~ AuthService ~ login ~ e:', e);
      throw new UnauthorizedException();
    }
  }

  @Transactional()
  async createTestAccount(body: AuthTestAccountREQ) {
    const account = await this.accountService.createAccount(AuthTestAccountREQ.toAccountDto(body));

    return account;
  }

  async validateEmail(body: AuthEmailVerificationREQ) {
    const account = await this.transactionHost.tx.account.findFirst({ where: { email: body.email } });
    if (account) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, 'Email existed');
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async registerStudent(body: AuthRegistrationStudentREQ) {
    /* 2. Check email duplicate */
    const existedAccount = await this.transactionHost.tx.account.findFirst({
      where: { email: body.email, status: AccountStatus.ACTIVE },
      select: { id: true },
    });

    if (existedAccount) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, AccountErrorMessages.MSG02);

    /* 3. Create account */
    const account = await this.accountService.createAccount(AuthRegistrationStudentREQ.toCreateAccountDto(body));

    await this.transactionHost.tx.student.create(AuthRegistrationStudentREQ.toCreateStudentArgs(body, account.id));
    let imageId: number;
    if (body.fileId) imageId = await this.imageService.linkImageToAccount(account.id, body.fileId);

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    await this.registerTokenVerification(account.id, jwtToken);

    /* 4. Send Email */
    runFunctionWithCondition(!!account, () => {
      this.eventEmitterService.emit<NotificationEmailPayload>(
        NotificationChannel.EMAIL,
        this.createEmailVerificationPayload(
          account.email,
          account.name,
          EMAIL_VERIFY_URL + EMAIL_PATH.EMAIL_VERIFICATION + jwtToken,
        ),
      );
    });

    return { account, imageId };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async registerMentor(body: AuthMentorRegisterREQ) {
    /* 1. Check email duplicate */
    const existedAccount = await this.transactionHost.tx.account.findFirst({
      where: { email: body.email, status: AccountStatus.ACTIVE },
      select: { id: true },
    });

    if (existedAccount) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, AccountErrorMessages.MSG02);

    /* 2. Create mentor account */
    const account = await this.accountService.createAccount(AuthMentorRegisterREQ.toCreateAccountDto(body));

    const mentor = await this.transactionHost.tx.mentor.create(AuthMentorRegisterREQ.toCreateMentorArgs(body, account.id));

    /* 3. Create profile/ achivement */
    if (body.achievements && body.achievements.length > 0) {
      let isOneCurrent = false;

      body.achievements.forEach((achievement) => {
        if (achievement.isCurrent) {
          if (isOneCurrent)
            throw new ActionFailedException(
              ActionFailed.AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED,
              'Current achievement duplicated',
            );
          isOneCurrent = true;
        }
      });

      await this.transactionHost.tx.profileAchievement.createMany(
        AuthMentorRegisterREQ.toCreateMentorProfileArgs(body, mentor.id),
      );
    }

    let imageId: number;
    if (body.avatarId) imageId = await this.imageService.linkImageToAccount(account.id, body.avatarId);

    //TODO: Check file in the format PDF, WORD
    if (body.fileId) await this.linkCVToMentor(mentor.id, body.fileId);

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    await this.registerTokenVerification(account.id, jwtToken);

    //NOTIFICATION: Send notification to admin
    const appPayload = NotificationHelper.makeAppNotificationPayload(
      { id: mentor.id, type: NotificationRelationType.MENTOR },
      admin.id,
      NotificationType.MENTOR_REGISTERD,
    );

    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, appPayload);
      this.eventEmitterService.emit<NotificationEmailPayload>(
        NotificationChannel.EMAIL,
        this.createEmailVerificationPayload(
          account.email,
          account.name,
          EMAIL_VERIFY_URL + EMAIL_PATH.EMAIL_VERIFICATION + jwtToken,
        ),
      );
    });

    return { account, imageId };
  }

  async registerTokenVerification(accountId: number, token: string) {
    await this.transactionHost.tx.token.create({
      data: {
        token: token,
        type: TokenType.VERIFY,
        Account: connectRelation(accountId),
      },
      select: { id: true },
    });
  }

  createEmailVerificationPayload(email: string, name: string, url: string): NotificationEmailPayload {
    return {
      data: {
        email: email,
        ...EMAIL_NOTIFICATION.ACCOUNT_REGISTERED,
      },
      template: {
        path: EMAIL_TEMPLATES.EMAIL_VERIFICATION,
        context: {
          url: url,
          name: name,
        },
      },
    };
  }

  async verifyEmail(token: string) {
    try {
      await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      });
    } catch (e) {
      this.logger.error('🚀 ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    const newAccount = await this.transactionHost.tx.account.update({
      where: { id: this.getAccountIdFromToken(token) },
      data: { status: AccountStatus.ACTIVE },
      select: { id: true, avatarId: true, name: true, email: true, accountType: true, status: true },
    });

    const deletedAccountCondition = { email: newAccount.email, status: AccountStatus.DEACTIVE };

    await this.prismaRawService.profileAchievement.deleteMany({
      where: { Mentor: { Account: deletedAccountCondition } },
    });

    await this.prismaRawService.mentor.deleteMany({
      where: { Account: deletedAccountCondition },
    });

    await this.prismaRawService.student.deleteMany({
      where: { Account: deletedAccountCondition },
    });

    await this.prismaRawService.account.deleteMany({
      where: deletedAccountCondition,
    });

    await this.prismaRawService.token.deleteMany({
      where: {
        OR: [{ accountId: this.getAccountIdFromToken(token) }, { Account: deletedAccountCondition }],
      },
    });

    return { account: newAccount, jwtToken: token, imageId: newAccount.avatarId };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async sendEmailForgotPassword(body: AuthEmailVerificationREQ) {
    let account: any;
    try {
      account = await this.transactionHost.tx.account.findFirstOrThrow({
        where: { email: body.email, status: AccountStatus.ACTIVE },
        select: { id: true, email: true },
      });
    } catch (e) {
      this.logger.error('🚀 ~ AuthService ~ sendEmailResetPassword ~ e:', e);
      throw new ActionFailedException(ActionFailed.ACCOUNT_EMAIL_NOT_FOUND, 'Email not found');
    }

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    await this.registerTokenVerification(account.id, jwtToken);

    const emailPayload: NotificationEmailPayload = {
      data: {
        email: account.email,
        ...EMAIL_NOTIFICATION.ACCOUNT_RESET_PASSWORD,
      },
      template: {
        path: EMAIL_TEMPLATES.RESET_PASSWORD,
        context: {
          url: EMAIL_VERIFY_URL + EMAIL_PATH.RESET_PASSWORD + jwtToken,
        },
      },
    };

    this.eventEmitterService.emit<NotificationEmailPayload>(NotificationChannel.EMAIL, emailPayload);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async verifyToken(token: string) {
    let existedToken: Token;
    try {
      existedToken = (await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      })) as Token;
    } catch (e) {
      this.logger.error('🚀 ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    await this.prismaRawService.token.deleteMany({
      where: { AND: [{ id: { not: existedToken.id } }, { accountId: this.getAccountIdFromToken(token) }] },
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resetPassword(body: AuthFindPasswordResetREQ) {
    let token: Token;
    try {
      token = (await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: body.token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      })) as Token;
    } catch (e) {
      this.logger.error('🚀 ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    await this.accountService.resetPassword(token.accountId, body.password);

    await this.prismaRawService.token.deleteMany({
      where: { accountId: token.accountId },
    });
  }

  getAccountIdFromToken(token: string) {
    if (!token) return null;

    const accountId = this.jwtService.decode(token, { json: true }).sub;

    return Number(accountId);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkCVToMentor(mentorId: number, fileId: number) {
    await this.fileService.checkAttachmentUploadedOrThrow([fileId]);
    await this.fileService.checkFileLinked([fileId]);

    /* Create and link file */
    await this.fileService.enableUploaded([fileId]);
    await this.transactionHost.tx.mentor.update({
      where: { id: mentorId },
      data: { File: connectRelation(fileId) },
      select: { id: true },
    });
  }
}
</file>

<file path="src/domains/category/admin/dto/category-cms-detail.dto.ts">
import { Prisma } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class CategoryCMSDetailDTO {
  static findUnique(id: number): Prisma.CategoryFindUniqueOrThrowArgs {
    return {
      where: { id },
      include: { Courses: { where: IS_ACTIVE_NESTED } },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-create.request.ts">
import { Prisma } from '@prisma/client';
import { IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { generateSlug } from 'src/shared/helpers/category.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { CategoryErrorMessages } from '../../../../shared/messages/error-messages';

export class CategoryAdminCreateREQ {
  @IsString()
  @MaxLength(255)
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;

  @IsOptional()
  @IdValidator()
  parentCategoryId?: number;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  static toFindMaxOrdinal(parentCategoryId?: number): Prisma.CategoryAggregateArgs {
    return {
      where: parentCategoryId ? { parentCategoryId: parentCategoryId } : { parentCategoryId: { equals: null } },
      _max: { ordinal: true },
    };
  }

  static toCreateInput(body: CategoryAdminCreateREQ, level: number, maxOrdinal: number): Prisma.CategoryCreateInput {
    if (level > MAX_CATEGORY_LEVEL)
      throw new ActionFailedException(ActionFailed.CATEGORY_LEVEL_EXCEED_MAXIMUM, CategoryErrorMessages.MSG01);

    return {
      name: body.name,
      slug: generateSlug(body.name),
      description: body.description,
      ordinal: maxOrdinal + 1,
      level,
      ParentCategory: connectRelation(body.parentCategoryId),
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-list.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CategorySortableFields } from '../../shared/enums';

export class CategoryAdminListREQ extends PaginationREQ {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsEnum(CategorySortableFields)
  sortBy?: CategorySortableFields;

  @IsOptional()
  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  static toOrderBy(
    query: CategoryAdminListREQ,
  ): Prisma.CategoryOrderByWithAggregationInput | Prisma.CategoryOrderByWithAggregationInput[] {
    if (!query.sortBy) return [{ level: SortOrder.ASC }, { ordinal: SortOrder.ASC }];
    return { [query.sortBy]: query.sortOrder };
  }

  static toQueryCondition(query: CategoryAdminListREQ) {
    const searchName = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    return {
      ...searchName,
    } as Prisma.CategoryFindManyArgs['where'];
  }

  static toFindMany(query: CategoryAdminListREQ): Prisma.CategoryFindManyArgs {
    const orderBy = this.toOrderBy(query);
    const condition: Prisma.CategoryFindManyArgs['where'] = this.toQueryCondition(query);
    return {
      ...QueryPagingHelper.queryPaging(query),
      where: condition,
      orderBy,
      include: { Courses: { where: IS_ACTIVE_NESTED } },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-reordinal.request.ts">
import { Prisma } from '@prisma/client';
import { Type } from 'class-transformer';
import { IsArray, IsNumber, IsOptional, Min, ValidateNested } from 'class-validator';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class CategoryAdminOrdinalREQ {
  @IdValidator()
  categoryId: number;

  @IsNumber()
  @Min(1)
  ordinal: number;
}

export class CategoryCmsReOrdinalREQ {
  @IsArray()
  @Type(() => CategoryAdminOrdinalREQ)
  @ValidateNested({ each: true })
  categoryOrdinals: CategoryAdminOrdinalREQ[];

  @IsOptional()
  @IdValidator()
  parentCategoryId: number;

  static toFindByOrdinal(categoryIds: number[], ordinal: number, parentCategoryId?: number): Prisma.CategoryFindFirstArgs {
    const isRearrangeParent = Boolean(parentCategoryId);

    return {
      where: {
        id: { notIn: categoryIds },
        ordinal: ordinal,
        ...(isRearrangeParent ? { level: 1 } : { parentCategoryId: parentCategoryId }),
      },
      select: { id: true },
    };
  }

  static toFindBySubCategoryOrdinal(
    categoryIds: number[],
    ordinal: number,
    parentCategoryId: number,
  ): Prisma.CategoryFindFirstArgs {
    return {
      where: { id: { notIn: categoryIds }, ordinal: ordinal, parentCategoryId: parentCategoryId },
      select: { id: true },
    };
  }

  static validateOrdinal(body: CategoryCmsReOrdinalREQ) {
    const ordinals = body.categoryOrdinals.map(({ ordinal }) => ordinal);

    const hasDuplicates = ordinals.length !== new Set(ordinals).size;
    if (hasDuplicates) throw new ActionFailedException(ActionFailed.CATEGORY_ORDINAL_OVERLAP, CategoryErrorMessages.MSG03);
  }

  static toUpdateOrdinal(body: CategoryAdminOrdinalREQ): Prisma.CategoryUpdateArgs {
    return {
      where: { id: body.categoryId },
      data: { ordinal: body.ordinal },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-update.request.ts">
import { Prisma } from '@prisma/client';
import { IsBoolean, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { isNull } from 'lodash';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { generateSlug } from 'src/shared/helpers/category.helper';
import { connectRelation, removeRelation } from 'src/shared/helpers/prisma.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class CategoryAdminUpdateREQ {
  @IsOptional()
  @IsString()
  @MaxLength(255)
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;

  @IsOptional()
  @IdValidator()
  parentCategoryId?: number;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  @IsBoolean()
  @IsOptional()
  isRecommended?: boolean;

  static toUpdateInput(body: CategoryAdminUpdateREQ, level: number): Prisma.CategoryUpdateInput {
    if (level > MAX_CATEGORY_LEVEL)
      throw new ActionFailedException(ActionFailed.CATEGORY_LEVEL_EXCEED_MAXIMUM, CategoryErrorMessages.MSG01);

    return {
      name: body.name,
      slug: generateSlug(body.name),
      description: body.description,
      level,
      ParentCategory: isNull(body.parentCategoryId) ? removeRelation() : connectRelation(body.parentCategoryId),
      isRecommended: body.isRecommended,
    };
  }
}
</file>

<file path="src/domains/category/admin/response/category-admin-detail.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryAdminDetailRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  noOfProduct: number;
  isRecommended: boolean;
  level: number;
  ordinal: number;
  thumbnail: ImageRESP;
  parentCategoryId: number | null;
  childCategories: CategoryAdminDetailRESP[];

  private constructor(e: CategoryGetPayload, thumbnail?: ImageRESP) {
    this.id = e.id;
    this.name = e.name;
    this.slug = e.slug;
    this.description = e.description;
    this.noOfProduct = e.Courses?.length || 0;
    this.level = e.level;
    this.ordinal = e.ordinal;
    this.isRecommended = e.isRecommended;
    this.thumbnail = thumbnail;
    this.parentCategoryId = e.parentCategoryId;
    this.childCategories = [];
  }

  static fromEntity(e: CategoryGetPayload, thumbnail?: ImageRESP): CategoryAdminDetailRESP {
    return new CategoryAdminDetailRESP(e, thumbnail);
  }

  addChildCategory(child: CategoryAdminDetailRESP) {
    this.childCategories.push(child);
  }
}
</file>

<file path="src/domains/category/admin/response/category-admin-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryAdminListRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  level: number;
  ordinal: number;
  thumbnail: ImageRESP;
  createdAt: string;
  noOfCourse: number;
  parentCategoryId: number | null;
  childCategories: CategoryAdminListRESP[] = [];

  static fromEntity(e: CategoryGetPayload, noOfCourse: number, thumbnail?: ImageRESP): CategoryAdminListRESP {
    return {
      id: e.id,
      name: e.name,
      slug: e.slug,
      description: e.description,
      level: e.level,
      ordinal: e.ordinal,
      thumbnail: thumbnail,
      noOfCourse: noOfCourse || 0,
      createdAt: parseEpoch(e.createdAt),
      parentCategoryId: e.parentCategoryId,
      childCategories: [],
    };
  }

  static addChildCategory(child: CategoryAdminListRESP) {
    const childCategories: CategoryAdminListRESP[] = [];
    childCategories.push(child);
    return childCategories;
  }
}
</file>

<file path="src/domains/category/admin/category-admin.controller.ts">
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { CategoryAdminService } from './category-admin.service';
import { CategoryAdminCreateREQ } from './request/category-admin-create.request';
import { CategoryAdminListREQ } from './request/category-admin-list.request';
import { CategoryCmsReOrdinalREQ } from './request/category-admin-reordinal.request';
import { CategoryAdminUpdateREQ } from './request/category-admin-update.request';

@Controller('admin/categories')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class CategoryAdminController {
  constructor(private readonly categoryService: CategoryAdminService) {}

  @Get()
  async list(@Query() query: CategoryAdminListREQ) {
    return await this.categoryService.list(query);
  }

  @HttpCode(HttpStatus.CREATED)
  @Post()
  async create(@Body() body: CategoryAdminCreateREQ) {
    const category = await this.categoryService.create(body);
    return BaseResponse.of(category.id);
  }

  @Patch(':id')
  async update(@Param('id', ParseIntPipe) id: number, @Body() body: CategoryAdminUpdateREQ) {
    const category = await this.categoryService.update(id, body);
    return BaseResponse.of(category.id);
  }

  @Delete(':id')
  async deleteCategory(@Param('id', ParseIntPipe) id: number) {
    const category = await this.categoryService.delete(id);

    return BaseResponse.of(category.id);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const category = await this.categoryService.detail(id);

    return BaseResponse.of(category);
  }

  @Patch('re-ordinal')
  async rearrangeOrdinal(@Body() body: CategoryCmsReOrdinalREQ) {
    await this.categoryService.rearrangeOrdinal(body);
  }
}
</file>

<file path="src/domains/category/admin/category-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus, Prisma, PrismaClient } from '@prisma/client';

import { isUndefined } from 'lodash';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { CategoryGetPayload } from '../shared/types';
import { CategoryCMSDetailDTO } from './dto/category-cms-detail.dto';
import { CategoryAdminCreateREQ } from './request/category-admin-create.request';
import { CategoryAdminListREQ } from './request/category-admin-list.request';
import { CategoryCmsReOrdinalREQ } from './request/category-admin-reordinal.request';
import { CategoryAdminUpdateREQ } from './request/category-admin-update.request';
import { CategoryAdminDetailRESP } from './response/category-admin-detail.response';
import { CategoryAdminListRESP } from './response/category-admin-list.response';

@Injectable()
export class CategoryAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async findCategoryLevel(categoryParentId?: number) {
    if (!categoryParentId) return 1;
    const parent = await this.transactionHost.tx.category.findUniqueOrThrow({
      where: { id: categoryParentId },
      select: { level: true },
    });
    return parent.level + 1;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkImageToCategory(categoryId: number, fileId: number) {
    //   /* 1. Remove old image */
    const category = await this.transactionHost.tx.category.findUniqueOrThrow({
      where: { id: categoryId },
      select: { Image: { select: { id: true } } },
    });
    if (category.Image) await this.imageService.deleteImage(category.Image.id);

    //   /* 2. Create and link image */
    await this.transactionHost.tx.category.update({
      where: { id: categoryId },
      data: { Image: connectRelation(fileId) },
    });

    /* 3. Enable Image & File */
    await this.imageService.enableImages([fileId]);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(body: CategoryAdminCreateREQ) {
    /* 1. Check if attachment uploaded & create image */
    if (body.fileId) await this.imageService.verifyImages([body.fileId]);

    const level = await this.findCategoryLevel(body.parentCategoryId);
    const ordinal = await this.transactionHost.tx.category.aggregate(
      CategoryAdminCreateREQ.toFindMaxOrdinal(body.parentCategoryId),
    );

    const maxOrdinal = ordinal._max.ordinal || 0;
    /* 2. Create and link image */
    const category = await this.transactionHost.tx.category.create({
      data: CategoryAdminCreateREQ.toCreateInput(body, level, maxOrdinal),
      select: { id: true },
    });

    if (body.fileId) await this.linkImageToCategory(category.id, body.fileId);

    return category;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(id: number, body: CategoryAdminUpdateREQ) {
    /* 1. Check if attachment uploaded & create image */
    // if (body.fileId) await this.imageService.verifyImages([body.fileId]);

    const category = await this.transactionHost.tx.category.findUniqueOrThrow({ where: { id } });
    const parentCategoryId = isUndefined(body.parentCategoryId) ? category.parentCategoryId : body.parentCategoryId;
    const level = await this.findCategoryLevel(parentCategoryId);

    /* 2. Update and link image */
    const updatedCategory = await this.transactionHost.tx.category.update({
      where: { id },
      data: CategoryAdminUpdateREQ.toUpdateInput(body, level),
      select: { id: true },
    });

    // if (body.fileId) await this.linkImageToCategory(category.id, body.fileId, tx);

    return updatedCategory;
  }

  async list(query: CategoryAdminListREQ) {
    const condition = CategoryAdminListREQ.toQueryCondition(query);
    const count = await this.transactionHost.tx.category.count({ where: condition });
    const categories = await this.transactionHost.tx.category.findMany(CategoryAdminListREQ.toFindMany(query));
    const cateResponses = await Promise.all(
      categories.map(async (c: CategoryGetPayload) => {
        const noOfCourses = await this.transactionHost.tx.course.count({
          where: { categoryId: c.id, isPublic: true, status: CourseStatus.APPROVED },
        });

        return CategoryAdminListRESP.fromEntity(c, noOfCourses, await this.imageService.getImageOriginal(c.imageId));
      }),
    );

    cateResponses.forEach((r) => {
      if (r.parentCategoryId) {
        const parent = cateResponses.find((c) => c.id === r.parentCategoryId);
        parent.childCategories.push(r);
      }
    });

    const parentCateResponses = cateResponses.filter((r) => r.parentCategoryId === null);
    return PaginationResponse.ofWithTotal<CategoryAdminListRESP>(parentCateResponses, count);
  }

  async detail(id: number) {
    const category = (await this.transactionHost.tx.category.findUniqueOrThrow(
      CategoryCMSDetailDTO.findUnique(id),
    )) as CategoryGetPayload;
    const childCategories = await this.transactionHost.tx.category.findMany({ where: { parentCategoryId: id } });
    const childCateResponses = await Promise.all(
      childCategories.map(async (c: CategoryGetPayload) =>
        CategoryAdminDetailRESP.fromEntity(c, await this.imageService.getImageOriginal(c.imageId)),
      ),
    );

    const cateResponse = CategoryAdminDetailRESP.fromEntity(category);
    cateResponse.childCategories = childCateResponses;
    return cateResponse;
  }

  async delete(id: number) {
    const category = await this.transactionHost.tx.category.findUniqueOrThrow({ where: { id }, select: { id: true } });
    const childCategories = await this.transactionHost.tx.category.findMany({ where: { parentCategoryId: id } });

    if (childCategories.length > 0)
      throw new ActionFailedException(ActionFailed.CATEGORY_PARENT_DELETE_FAILED, CategoryErrorMessages.MSG04);

    /* Delete parent & children categories */
    const categoryIds = [category.id, ...childCategories.map((c) => c.id)];
    await this.transactionHost.tx.$executeRaw`DELETE FROM categories WHERE id IN (${Prisma.join(categoryIds)})`;
    return category;
  }

  private async validateExistedOrdinal(body: CategoryCmsReOrdinalREQ) {
    const rearrangedCategoryIds = body.categoryOrdinals.map(({ categoryId }) => categoryId);

    for (const category of body.categoryOrdinals) {
      const existedCategory = await this.transactionHost.tx.category.findFirst(
        CategoryCmsReOrdinalREQ.toFindByOrdinal(rearrangedCategoryIds, category.ordinal, body.parentCategoryId),
      );

      if (existedCategory)
        throw new ActionFailedException(
          ActionFailed.CATEGORY_ORDINAL_OVERLAP,
          `Ordinal number ${category.ordinal} already existed with banner ${existedCategory.id}`,
        );
    }
  }

  async rearrangeOrdinal(body: CategoryCmsReOrdinalREQ) {
    CategoryCmsReOrdinalREQ.validateOrdinal(body);
    await this.validateExistedOrdinal(body);

    await this.transactionHost.tx.$transaction(async (tx: PrismaClient) => {
      for (const category of body.categoryOrdinals) {
        await tx.category.update(CategoryCmsReOrdinalREQ.toUpdateOrdinal(category));
      }
    });
  }
}
</file>

<file path="src/domains/category/client/dto/category-client-statistics.dto.ts">
import { CourseStatus, Prisma } from '@prisma/client';
import { CATEGORY_DEFAULT_LEVEL } from 'src/shared/constants/category.constant';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

type CategoryClientStatisticsCountProduct = {
  _count: {
    Products: number;
  };
};

export type CategoryClientStatisticsCountPayload = Prisma.CategoryGetPayload<{
  include: { ChildrenCategories: true };
}> &
  CategoryClientStatisticsCountProduct;

export class CategoryClientStatisticsDTO {
  static toFindMany(): Prisma.CategoryFindManyArgs {
    return {
      where: { level: CATEGORY_DEFAULT_LEVEL },
      select: {
        id: true,
        name: true,
        level: true,
        ChildrenCategories: {
          select: {
            id: true,
            name: true,
            level: true,
            _count: {
              select: { Courses: { where: { status: CourseStatus.APPROVED, ...IS_ACTIVE_NESTED } } },
            },
          },
          where: IS_ACTIVE_NESTED,
        },
      },
    };
  }
}
</file>

<file path="src/domains/category/client/request/category-client-list.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { leanObject } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { CategorySortableFields } from '../../shared/enums';

export class CategoryClientListREQ extends PaginationREQ {
  @BooleanValidator()
  @IsOptional()
  isRecommended: boolean;

  @IsOptional()
  @IsEnum(CategorySortableFields)
  sortBy?: CategorySortableFields;

  @IsOptional()
  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  static toQueryCondition(query: CategoryClientListREQ): Prisma.CategoryWhereInput {
    const recommendedCategoryFiltered = orUndefinedWithCondition(query.isRecommended, {
      level: MAX_CATEGORY_LEVEL,
      isRecommended: true,
    });
    return leanObject({ ...recommendedCategoryFiltered });
  }

  static toOrderBy(
    query: CategoryClientListREQ,
  ): Prisma.CategoryOrderByWithRelationInput | Prisma.CategoryOrderByWithRelationInput[] {
    if (!query.sortBy) return [{ level: SortOrder.ASC }, { ordinal: SortOrder.ASC }];
    return { [query.sortBy]: query.sortOrder };
  }

  static toFindMany(query: CategoryClientListREQ): Prisma.CategoryFindManyArgs {
    const orderBy = this.toOrderBy(query);
    const condition = this.toQueryCondition(query);
    return {
      where: condition,
      include: { Courses: true },
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
    };
  }
}
</file>

<file path="src/domains/category/client/request/category-client-select-interested-choice.request.ts">
import { ArrayMinSize, IsNumber } from 'class-validator';

export class CategoryClientSelectInterestedChoiceREQ {
  @IsNumber({}, { each: true })
  @ArrayMinSize(1)
  categoryIds?: number[] = [];
}
</file>

<file path="src/domains/category/client/response/category-client-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryClientListRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  thumbnail: ImageRESP;
  noOfCourses: number;
  createdAt: string;
  parentCategoryId: number | null;
  childCategories: CategoryClientListRESP[];

  private constructor(e: CategoryGetPayload, noOfCourses?: number, thumbnail?: ImageRESP) {
    this.id = e.id;
    this.name = e.name;
    this.slug = e.slug;
    this.description = e.description;
    this.thumbnail = thumbnail;
    this.parentCategoryId = e.parentCategoryId;
    this.noOfCourses = noOfCourses || 0;
    this.createdAt = parseEpoch(e.createdAt);
    this.childCategories = [];
  }

  static fromEntity(e: CategoryGetPayload, noOfCourses?: number, thumbnail?: ImageRESP): CategoryClientListRESP {
    return new CategoryClientListRESP(e, noOfCourses, thumbnail);
  }

  addChildCategory(child: CategoryClientListRESP) {
    this.childCategories.push(child);
  }
}
</file>

<file path="src/domains/category/client/response/category-client-statistics.response.ts">
import { CategoryClientStatisticsCountPayload } from '../dto/category-client-statistics.dto';

export class CategoryClientStatisticsRESP {
  id: number;
  name: string;
  level: number;
  noOfProducts?: number;
  childrenCategories: Partial<CategoryClientStatisticsRESP>[];

  static fromEntity(e: CategoryClientStatisticsCountPayload): CategoryClientStatisticsRESP {
    return {
      id: e.id,
      name: e.name,
      level: e.level,
      childrenCategories: e.ChildrenCategories.map((category: CategoryClientStatisticsCountPayload) => ({
        id: category.id,
        name: category.name,
        level: category.level,
        noOfProducts: category._count.Products,
      })),
    };
  }
}
</file>

<file path="src/domains/category/client/category-client.controller.ts">
import { Body, Controller, Get, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { CategoryClientService } from './category-client.service';
import { CategoryClientListREQ } from './request/category-client-list.request';
import { CategoryClientSelectInterestedChoiceREQ } from './request/category-client-select-interested-choice.request';

@Controller('client/categories')
@UseGuards(AuthJwtGuard)
export class CategoryClientController {
  constructor(private readonly categoryEcmService: CategoryClientService) {}

  @Get()
  @Public()
  async list(@Query() query: CategoryClientListREQ) {
    return await this.categoryEcmService.list(query);
  }

  @Patch('update-ordinal')
  async updateCategoryOrdinal() {
    await this.categoryEcmService.updateCategoryOrdinal();
  }

  @Post('students')
  async chooseInterestedCategories(@Req() req: AuthRequestDTO, @Body() body: CategoryClientSelectInterestedChoiceREQ) {
    await this.categoryEcmService.chooseInterestedCategories(req.user, body);
    return BaseResponse.ok();
  }

  @Get('statistics')
  async statistics() {
    return await this.categoryEcmService.statistics();
  }
}
</file>

<file path="src/domains/category/client/category-client.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus } from '@prisma/client';
import { isEmpty } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { CategoryGetPayload } from '../shared/types';
import { CategoryClientStatisticsDTO } from './dto/category-client-statistics.dto';
import { CategoryClientListREQ } from './request/category-client-list.request';
import { CategoryClientSelectInterestedChoiceREQ } from './request/category-client-select-interested-choice.request';
import { CategoryClientListRESP } from './response/category-client-list.response';
import { CategoryClientStatisticsRESP } from './response/category-client-statistics.response';

@Injectable()
export class CategoryClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async statistics() {
    const categories = await this.transactionHost.tx.category.findMany(CategoryClientStatisticsDTO.toFindMany());
    return PaginationResponse.of(categories.map(CategoryClientStatisticsRESP.fromEntity));
  }

  async list(query: CategoryClientListREQ) {
    const condition = CategoryClientListREQ.toQueryCondition(query);
    const count = await this.transactionHost.tx.category.count({ where: condition });
    const categories = await this.transactionHost.tx.category.findMany(CategoryClientListREQ.toFindMany(query));
    const cateResponses = await Promise.all(
      categories.map(async (c: CategoryGetPayload) => {
        const noOfCourses = await this.transactionHost.tx.course.count({
          where: { categoryId: c.id, isPublic: true, status: CourseStatus.APPROVED },
        });

        return CategoryClientListRESP.fromEntity(c, noOfCourses, await this.imageService.getImageOriginal(c.imageId));
      }),
    );
    // if just getting category, should return list of sub category
    if (query.isRecommended) return PaginationResponse.ofWithTotal<CategoryClientListRESP>(cateResponses, count);

    cateResponses.forEach((r) => {
      const parent = cateResponses.find((c) => c.id === r.parentCategoryId);
      if (parent) parent.addChildCategory(r);
    });
    const parentCateResponses = cateResponses.filter((r) => r.parentCategoryId === null);
    return PaginationResponse.ofWithTotal<CategoryClientListRESP>(parentCateResponses, count);
  }

  async chooseInterestedCategories(user: AuthUserDTO, body: CategoryClientSelectInterestedChoiceREQ) {
    await this.validateCategories(body);
    await this.transactionHost.tx.userInterestedCategory.createMany({
      data: body.categoryIds.map((categoryId) =>
        addCreationTimestamps({
          userId: user.accountId,
          categoryId: categoryId,
        }),
      ),
      skipDuplicates: true,
    });
  }

  async validateCategories(body: CategoryClientSelectInterestedChoiceREQ) {
    if (!body.categoryIds || isEmpty(body.categoryIds)) return;
    const categories = await this.transactionHost.tx.category.findMany({ where: { id: { in: body.categoryIds } } });
    if (categories.length !== body.categoryIds.length)
      throw new ActionFailedException(ActionFailed.CATEGORY_NOT_FOUND, CategoryErrorMessages.MSG05);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateCategoryOrdinal() {
    const parentCategories = await this.transactionHost.tx.category.findMany({ where: { level: 1 }, select: { id: true } });
    const parentIds = parentCategories.map((cate) => cate.id);

    for (const [index, parentId] of parentIds.entries()) {
      await this.transactionHost.tx.category.update({
        where: { id: parentId },
        data: { ordinal: index + 1 },
      });
      const childrenCategories = await this.transactionHost.tx.category.findMany({
        where: { parentCategoryId: parentId },
        select: { id: true },
      });
      for (const [index, child] of childrenCategories.entries()) {
        await this.transactionHost.tx.category.update({
          where: { id: child.id },
          data: { ordinal: index + 1 },
        });
      }
    }
  }
}
</file>

<file path="src/domains/category/shared/enums.ts">
export enum CategorySortableFields {
  ID = 'id',
  NAME = 'name',
  CREATED_AT = 'createdAt',
}
</file>

<file path="src/domains/category/shared/types.ts">
import { Prisma } from '@prisma/client';

export type CategoryGetPayload = Prisma.CategoryGetPayload<{ include: { Courses: true } }>;
</file>

<file path="src/domains/category/category.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { CategoryAdminController } from './admin/category-admin.controller';
import { CategoryAdminService } from './admin/category-admin.service';
import { CategoryClientController } from './client/category-client.controller';
import { CategoryClientService } from './client/category-client.service';

@Module({
  imports: [CommonModule],
  controllers: [CategoryAdminController, CategoryClientController],
  providers: [CategoryAdminService, CategoryClientService],
})
export class CategoryModule {}
</file>

<file path="src/domains/chat-message/helper/chat-room-create.helper.ts">
import { ChatRoomType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { NUMBER_OF_MESSAGE_DEFAULT } from 'src/shared/constants/chat-message.constant';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

export class ChatRoomCreateHelper {
  static toCreateInput(user: AuthUserDTO, receiverId: number): Prisma.ChatRoomCreateArgs {
    const participants = [
      addCreationTimestamps({ participantId: user.accountId }),
      addCreationTimestamps({ participantId: receiverId }),
    ];

    return {
      data: {
        numberOfMessages: NUMBER_OF_MESSAGE_DEFAULT,
        numberOfParticipants: participants.length,
        chatRoomType: ChatRoomType.PRIVATE,
        ChatParticipants: { createMany: { data: participants } },
      },
      select: {
        id: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }

  static toFindFirst(user: AuthUserDTO, receiverId: number): Prisma.ChatRoomFindFirstArgs {
    return {
      where: {
        chatRoomType: ChatRoomType.PRIVATE,
        ChatParticipants: {
          every: { participantId: { in: [user.accountId, receiverId] } },
        },
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-detail.helper.ts">
import { Prisma } from '@prisma/client';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortAsc } from 'src/shared/helpers/query.helper';
import { ChatRoomDetailREQ } from '../request/chat-room-detail.request';

export class ChatRoomDetailHelper {
  static toFindUnique(roomId: number): Prisma.ChatRoomFindUniqueArgs {
    return {
      where: { id: roomId },
      select: {
        id: true,
        chatRoomType: true,
        numberOfMessages: true,
        numberOfParticipants: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }

  static toFindManyMessages(roomId: number, body: ChatRoomDetailREQ): Prisma.ChatMessageFindManyArgs {
    return {
      where: { chatRoomId: roomId },
      ...QueryPagingHelper.queryPaging(body),
      orderBy: defaultSortAsc,
      select: {
        id: true,
        Sender: { select: { id: true, accountType: true } },
        message: true,
        isRead: true,
        chatRoomId: true,
        updatedAt: true,
        createdAt: true,
        readAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-list-helper.ts">
import { AccountType, ChatRoomType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { SortOrder } from 'src/shared/enums/query.enum';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { ChatRoomListREQ } from '../request/chat-room-list.request';

export class ChatRoomListHelper {
  static toFilterByAccountType(user: AuthUserDTO): Prisma.ChatRoomWhereInput {
    switch (user.accountType) {
      case AccountType.MENTOR:
      case AccountType.STUDENT:
        return {
          ChatParticipants: {
            some: { participantId: user.accountId },
          },
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACCOUNT_FORBIDDEN);
    }
  }

  static toQueryCondition(user: AuthUserDTO, query: ChatRoomListREQ): Prisma.ChatRoomWhereInput {
    const receiverName = orUndefinedWithCondition(!!query.receiverName, {
      Creator: { Buyer: parsePrismaSearch('name', query.receiverName) },
    });

    const chatRoomType = orUndefinedWithCondition(!!query.chatRoomType, { chatRoomType: query.chatRoomType });
    const toFilterByAccountType = this.toFilterByAccountType(user);

    return leanObject({ ...toFilterByAccountType, ...receiverName, ...chatRoomType });
  }

  static findMany(user: AuthUserDTO): Prisma.ChatRoomFindManyArgs {
    return {
      where: this.toFilterByAccountType(user),
      select: { id: true },
    };
  }
  static toFindManyPrivateRoom(user: AuthUserDTO, query: ChatRoomListREQ): Prisma.ChatRoomFindManyArgs {
    const condition = this.toQueryCondition(user, query);

    return {
      where: { ...condition, chatRoomType: ChatRoomType.PRIVATE },
      orderBy: { lastMessageId: SortOrder.DESC },
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        lastMessageId: true,
        numberOfMessages: true,
        numberOfParticipants: true,
        chatRoomType: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-read-message.helper.ts">
import { WsException } from '@nestjs/websockets';
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { ChatRoomReadMessageREQ } from '../request/chat-room-read-message.request';

export class ChatRoomReadMessageHelper {
  static toFilterAccountReadMessage(user: AuthUserDTO, body: ChatRoomReadMessageREQ): Prisma.ChatMessageUpdateManyArgs['where'] {
    if (!body.chatRoomId) throw new WsException('Conversation ID is required');

    return {
      chatRoomId: body.chatRoomId,
      Sender: { id: { not: user.accountId } },
    };
  }

  static toUpdateInput(user: AuthUserDTO, body: ChatRoomReadMessageREQ): Prisma.ChatMessageUpdateManyArgs {
    const filterAccount = this.toFilterAccountReadMessage(user, body);
    return {
      where: {
        ...filterAccount,
        isRead: false,
      },
      data: { isRead: true, readAt: nowEpoch() },
    };
  }
}
</file>

<file path="src/domains/chat-message/request/chat-message-create.request.ts">
import { ChatMessageType, Prisma } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class ChatMessageCreateREQ {
  @IsString()
  @IsNotEmpty()
  message: string;

  @IsEnum(ChatMessageType)
  type: ChatMessageType;

  @IdValidator()
  receiverId: number;

  static toCreateInput(user: AuthUserDTO, chatRoomId: number, body: ChatMessageCreateREQ): Prisma.ChatMessageCreateArgs {
    return {
      data: {
        message: body.message,
        Sender: connectRelation(user.accountId),
        type: body.type,
        ChatRoom: connectRelation(chatRoomId),
      },
      select: {
        id: true,
        message: true,
        isRead: true,
        createdAt: true,
        chatRoomId: true,
        Sender: { select: { id: true, name: true } },
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/request/chat-room-create.request.ts">
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class ChatRoomCreateREQ {
  @IdValidator()
  receiverId: number;
}
</file>

<file path="src/domains/chat-message/request/chat-room-detail.request.ts">
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ChatRoomDetailREQ extends PaginationREQ {}
</file>

<file path="src/domains/chat-message/request/chat-room-list.request.ts">
import { ChatRoomType } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ChatRoomListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  receiverName?: string;

  @IsOptional()
  @IsEnum(ChatRoomType)
  chatRoomType?: ChatRoomType;
}
</file>

<file path="src/domains/chat-message/request/chat-room-read-message.request.ts">
import { IsNumber } from 'class-validator';

export class ChatRoomReadMessageREQ {
  @IsNumber()
  chatRoomId: number;
}
</file>

<file path="src/domains/chat-message/response/chat-room-detail.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload, ChatRoomGetPayload, ChatRoomReceiverRESP } from '../shared/types';

export class ChatMessageDetailRESP {
  id: number;
  content: string;
  senderId: number;
  isReceiver: boolean;
  isRead: boolean;
  createdAt: Date;
  readAt: Date;
  chatRoomId: number;

  static fromEntity(e: ChatMessageGetPayload, isReceiver: boolean): ChatMessageDetailRESP {
    return {
      id: e.id,
      content: e.message,
      senderId: e.Sender.id,
      isReceiver: isReceiver,
      createdAt: parseEpoch(e.createdAt),
      readAt: parseEpoch(e.readAt),
      chatRoomId: e.chatRoomId,
      isRead: e.isRead,
    };
  }
}

export class ChatRoomDetailRESP {
  id: number;
  receiver: ChatRoomReceiverRESP;
  noOfMessages: number;
  messages: ChatMessageDetailRESP[];

  static fromEntity(
    chatRoom: ChatRoomGetPayload,
    messages: ChatMessageDetailRESP[],
    receiver: ChatRoomReceiverRESP,
  ): ChatRoomDetailRESP {
    return {
      id: chatRoom.id,
      receiver: receiver,
      noOfMessages: chatRoom.numberOfMessages,
      messages: messages,
    };
  }
}
</file>

<file path="src/domains/chat-message/response/chat-room-list.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload, ChatRoomGetPayload, ChatRoomReceiverRESP } from '../shared/types';

export class ChatRoomListRESP {
  id: number;
  receiver: ChatRoomReceiverRESP;
  isSeen: boolean;
  lastMessage: {
    isReceiver: boolean;
    content: string;
  };
  lastMessageAt: string;
  numOfUnreadMessage: number;

  static fromEntity(
    entity: ChatRoomGetPayload,
    lastMessage: ChatMessageGetPayload,
    numOfUnreadMessage: number,
    receiver: ChatRoomReceiverRESP,
  ): ChatRoomListRESP {
    return {
      id: entity.id,
      numOfUnreadMessage: numOfUnreadMessage,
      lastMessage: {
        isReceiver: lastMessage && lastMessage.senderId === receiver.id,
        content: lastMessage && lastMessage.message,
      },
      lastMessageAt: lastMessage && parseEpoch(lastMessage.createdAt),
      isSeen: numOfUnreadMessage === 0,
      receiver: receiver,
    };
  }
}
</file>

<file path="src/domains/chat-message/response/message-chat-create.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload } from '../shared/types';

export class ChatMessageCreateRESP {
  id: number;
  content: string;
  senderId: number;
  isRead: boolean;
  createdAt: Date;
  name: string;
  chatRoomId: number;

  static fromEntity(e: ChatMessageGetPayload): ChatMessageCreateRESP {
    return {
      id: e.id,
      content: e.message,
      senderId: e.Sender?.id,
      name: e.Sender?.name,
      createdAt: parseEpoch(e.createdAt),
      chatRoomId: e.chatRoomId,
      isRead: e.isRead,
    };
  }
}
</file>

<file path="src/domains/chat-message/shared/types.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';

export type ChatMessageGetPayload = Prisma.ChatMessageGetPayload<{ include: { Sender: true; ChatRoom: true } }>;

export type ChatRoomGetPayload = Prisma.ChatRoomGetPayload<{ include: { ChatMessages: true; ChatParticipants: true } }>;

export type ChatRoomReceiverRESP = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;
</file>

<file path="src/domains/chat-message/chat-message.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ChatMessageController } from './chat-message.controller';
import { ChatMessageService } from './chat-message.service';

describe('ChatMessageController', () => {
  let controller: ChatMessageController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ChatMessageController],
      providers: [ChatMessageService],
    }).compile();

    controller = module.get<ChatMessageController>(ChatMessageController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/chat-message/chat-message.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { ChatMessageService } from './chat-message.service';
import { ChatRoomDetailREQ } from './request/chat-room-detail.request';
import { ChatRoomListREQ } from './request/chat-room-list.request';

@Controller('chat-messages')
@UseGuards(AuthJwtGuard)
export class ChatMessageController {
  constructor(private readonly chatMessageService: ChatMessageService) {}

  @Get('rooms')
  async findAll(@Req() req: AuthRequestDTO, @Query() query: ChatRoomListREQ) {
    const { chatRoomDtos, count } = await this.chatMessageService.findAll(req.user, query);

    return PaginationResponse.ofWithTotal(chatRoomDtos, count);
  }

  @Get('rooms/:roomId')
  async detail(@Req() req: AuthRequestDTO, @Param('roomId', ParseIntPipe) roomId: number, @Query() query: ChatRoomDetailREQ) {
    const response = await this.chatMessageService.getAllMessagesByRoomId(req.user, roomId, query);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/chat-message/chat-message.gateway.ts">
import { Logger, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import {
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
  WsException,
} from '@nestjs/websockets';
import { Namespace, Socket } from 'socket.io';
import { AuthSocket, SocketAuthMiddleware } from 'src/middlewares/socket-auth.middleware';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { SOCKET_CHAT_MESSAGE_EVENT } from 'src/shared/constants/chat-message.constant';
import { BaseResponse } from 'src/shared/generics/base.response';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { parseRoomChatId } from 'src/shared/parsers/io.parser';
import { AuthJwtPayloadDTO } from '../auth/dto/auth-jwt-payload.dto';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ChatMessageService } from './chat-message.service';
import { ChatRoomListHelper } from './helper/chat-room-list-helper';
import { ChatMessageCreateREQ } from './request/chat-message-create.request';
import { ChatRoomCreateREQ } from './request/chat-room-create.request';
import { ChatRoomReadMessageREQ } from './request/chat-room-read-message.request';

@WebSocketGateway({
  namespace: 'message-chat',
  cors: {
    credentials: true,
    origin: ['http://localhost:3000', 'https://bksharing.social', 'https://www.bksharing.social'],
  },
})
export class ChatMessageGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(ChatMessageGateway.name);
  constructor(
    private readonly jwtService: JwtService,
    private readonly transactionHost: TransactionHost,
    private readonly chatMessageService: ChatMessageService,
  ) {}

  @WebSocketServer()
  server: Namespace;

  connectedUsers: Map<string, AuthUserDTO> = new Map();

  afterInit(client: Socket) {
    const middleware = SocketAuthMiddleware(this.jwtService, this.logger);

    client.use(middleware as any); // because types are broken
    this.logger.log('Message Chat Gateway initialized');
  }

  handleDisconnect(client: Socket) {
    client.disconnect();
    this.connectedUsers.delete(client.id);
    this.logger.log(`Client with id ${client.id} disconnected at ${nowEpoch()} `);
  }

  async handleConnection(client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    if (!user) {
      this.logger.log(
        `🚀 ~ MessageChatGateway ~ handleConnection ~  Client with id ${client.id} cannot connect due to error with identification`,
      );
      client.disconnect();
      return;
    }

    this.connectedUsers.set(client.id, user);

    this.logger.log(
      `🚀 ~ MessageChatGateway ~ handleConnection ~  Client with id ${client.id} connected at ${new Date().toDateString()}`,
    );
    await this.onConnectRoom(user, client);
  }

  // ==================== MESSAGE CHAT EVENT ====================
  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.SEND_MESSAGE)
  async onSendMessage(@MessageBody() body: ChatMessageCreateREQ, @ConnectedSocket() client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    // const isMemberConversation = user.accountType === AccountType.COMPANY_ADMIN && !isUndefined(body.chatRoomId);

    const chatRoomId = await this.onJoinRoom(client, { receiverId: body.receiverId });

    const message = await this.chatMessageService.createMessageChat(user, chatRoomId, body);

    this.server.to(parseRoomChatId(message.chatRoomId)).emit(SOCKET_CHAT_MESSAGE_EVENT.NEW_MESSAGE, message);
    return BaseResponse.of(message);
  }

  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.JOIN_ROOM)
  async onJoinRoom(@ConnectedSocket() client: AuthSocket, @MessageBody() body: ChatRoomCreateREQ) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    const { chatRoom, isNewConversation } = await this.chatMessageService.joinConversation(user, body.receiverId);

    await client.join(parseRoomChatId(chatRoom.id));

    //loop hashmap key connectedUsers
    if (isNewConversation) await this.connectReceiverToConversation(chatRoom.id, body.receiverId);

    return chatRoom.id;
  }

  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.READ_MESSAGE)
  async onReadMessage(@MessageBody() body: ChatRoomReadMessageREQ, @ConnectedSocket() client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    await this.chatMessageService.readMessage(user, body);
    this.logger.log(
      `🚀 ~ ChatMessageGateway ~ onReadMessage ~ chatMessageService: User ${user.accountId} read message in room ${body.chatRoomId}`,
    );
  }

  private async onConnectRoom(user: AuthUserDTO, @ConnectedSocket() client: AuthSocket) {
    const rooms = await this.connectConversation(user);
    if (rooms && rooms.length !== 0) {
      for (const room of rooms) {
        await client.join(parseRoomChatId(room.id));
      }
    }

    return rooms;
  }

  private async connectConversation(user: AuthUserDTO) {
    const conservations = await this.transactionHost.tx.chatRoom.findMany(ChatRoomListHelper.findMany(user));

    return conservations;
  }

  private async connectReceiverToConversation(chatRoomId: number, receiverId: number) {
    for (const clientId of this.connectedUsers.keys()) {
      const account = this.connectedUsers.get(clientId);

      if (account.accountId === receiverId) {
        await this.server.sockets.get(clientId).join(parseRoomChatId(chatRoomId));
      }
    }
  }

  private async getAccountFromJWTPayload(payload: AuthJwtPayloadDTO): Promise<AuthUserDTO> {
    if (!payload) throw new WsException(UnauthorizedException);
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: Number(payload.sub) },
      select: {
        id: true,
        name: true,
        email: true,
        phoneNumber: true,
        accountType: true,
      },
    });

    if (!account) throw new UnauthorizedException('Account not found');
    return AuthUserDTO.fromEntity(account as any);
  }
}
</file>

<file path="src/domains/chat-message/chat-message.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { JWT_ACCESS_TOKEN_EXPIRE_HOURS, JWT_SECRET_KEY } from 'src/app.config';
import { AccountModule } from '../accounts/accounts.module';
import { ChatMessageController } from './chat-message.controller';
import { ChatMessageGateway } from './chat-message.gateway';
import { ChatMessageService } from './chat-message.service';

@Module({
  imports: [
    AccountModule,
    JwtModule.register({
      secret: JWT_SECRET_KEY,
      signOptions: { algorithm: 'HS256', expiresIn: JWT_ACCESS_TOKEN_EXPIRE_HOURS },
      verifyOptions: { algorithms: ['HS256'] },
    }),
  ],
  controllers: [ChatMessageController],
  providers: [ChatMessageService, ChatMessageGateway],
})
export class ChatMessageModule {}
</file>

<file path="src/domains/chat-message/chat-message.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ChatMessageService } from './chat-message.service';

describe('ChatMessageService', () => {
  let service: ChatMessageService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ChatMessageService],
    }).compile();

    service = module.get<ChatMessageService>(ChatMessageService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/chat-message/chat-message.service.ts">
import { Injectable } from '@nestjs/common';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { NUMBER_MESSAGE_INCREMENT_DEFAULT } from 'src/shared/constants/chat-message.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountService } from '../accounts/account.service';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ChatRoomCreateHelper } from './helper/chat-room-create.helper';
import { ChatRoomDetailHelper } from './helper/chat-room-detail.helper';
import { ChatRoomListHelper } from './helper/chat-room-list-helper';
import { ChatRoomReadMessageHelper } from './helper/chat-room-read-message.helper';
import { ChatMessageCreateREQ } from './request/chat-message-create.request';
import { ChatRoomDetailREQ } from './request/chat-room-detail.request';
import { ChatRoomListREQ } from './request/chat-room-list.request';
import { ChatRoomReadMessageREQ } from './request/chat-room-read-message.request';
import { ChatMessageDetailRESP, ChatRoomDetailRESP } from './response/chat-room-detail.response';
import { ChatRoomListRESP } from './response/chat-room-list.response';
import { ChatMessageCreateRESP } from './response/message-chat-create.response';
import { ChatMessageGetPayload, ChatRoomGetPayload } from './shared/types';

@Injectable()
export class ChatMessageService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
  ) {}

  async findAll(user: AuthUserDTO, query: ChatRoomListREQ) {
    const conversations = await this.transactionHost.tx.chatRoom.findMany(ChatRoomListHelper.toFindManyPrivateRoom(user, query));

    const count = await this.transactionHost.tx.chatRoom.count({
      where: ChatRoomListHelper.toQueryCondition(user, query),
    });

    const chatRoomDtos = await Promise.all(
      conversations.map(async (chatRoom: ChatRoomGetPayload) => {
        const lastMessage =
          chatRoom.lastMessageId &&
          ((await this.transactionHost.tx.chatMessage.findFirst({
            where: { id: chatRoom.lastMessageId },
            select: { message: true, createdAt: true, senderId: true },
          })) as ChatMessageGetPayload);

        const numOfUnreadMessage = await this.transactionHost.tx.chatMessage.count({
          where: { chatRoomId: chatRoom.id, isRead: false },
        });

        const receiverParticipant = chatRoom.ChatParticipants.find((participant) => participant.participantId !== user.accountId);
        const receiver = await this.accountService.getMe(receiverParticipant.participantId);
        const result = ChatRoomListRESP.fromEntity(chatRoom, lastMessage, numOfUnreadMessage, {
          id: receiver.account.id,
          name: receiver.account.name,
          thumbnail: receiver.thumbnail,
        });

        return result;
      }),
    );

    return { chatRoomDtos, count: count };
  }

  async joinConversation(user: AuthUserDTO, receiverId: number) {
    const chatRoom = (await this.transactionHost.tx.chatRoom.findFirst(
      ChatRoomCreateHelper.toFindFirst(user, receiverId),
    )) as ChatRoomGetPayload;

    if (chatRoom) {
      return { chatRoom: chatRoom, isNewConversation: false };
    }

    const newConversation = await this.transactionHost.tx.chatRoom.create(ChatRoomCreateHelper.toCreateInput(user, receiverId));

    return { chatRoom: newConversation, isNewConversation: true };
  }

  async createMessageChat(user: AuthUserDTO, chatRoomId: number, body: ChatMessageCreateREQ) {
    const message = await this.transactionHost.tx.chatMessage.create(ChatMessageCreateREQ.toCreateInput(user, chatRoomId, body));

    await this.transactionHost.tx.chatRoom.update({
      where: { id: chatRoomId },
      data: { numberOfMessages: { increment: NUMBER_MESSAGE_INCREMENT_DEFAULT }, lastMessageId: message.id },
      select: { id: true },
    });

    return ChatMessageCreateRESP.fromEntity(message as ChatMessageGetPayload);
  }

  async getAllMessagesByRoomId(user: AuthUserDTO, roomId: number, body: ChatRoomDetailREQ) {
    const isPaticipated = await this.isParticipantBelongToConversation(user.accountId, roomId);
    if (!isPaticipated) {
      throw new ActionFailedException(ActionFailed.CHAT_ROOM_NOT_INCLUDE_USER, 'You are not allowed to view this conversation');
    }

    const chatRoom = (await this.transactionHost.tx.chatRoom.findUniqueOrThrow(
      ChatRoomDetailHelper.toFindUnique(roomId),
    )) as ChatRoomGetPayload;

    const messages = await this.transactionHost.tx.chatMessage.findMany(
      ChatRoomDetailHelper.toFindManyMessages(chatRoom.id, body),
    );

    const receiverParticipant = chatRoom.ChatParticipants.find((participant) => participant.participantId !== user.accountId);
    const receiver = await this.accountService.getMe(receiverParticipant.participantId);

    const messageDTOs = messages.map((e: ChatMessageGetPayload) => {
      return ChatMessageDetailRESP.fromEntity(e, user.accountId !== e.Sender.id);
    });

    return ChatRoomDetailRESP.fromEntity(chatRoom, messageDTOs, {
      id: receiver.account.id,
      name: receiver.account.name,
      thumbnail: receiver.thumbnail,
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async readMessage(user: AuthUserDTO, body: ChatRoomReadMessageREQ) {
    const isParticipated = await this.isParticipantBelongToConversation(user.accountId, body.chatRoomId);
    if (!isParticipated) {
      throw new ActionFailedException(ActionFailed.CHAT_ROOM_NOT_INCLUDE_USER, 'You are not allowed to view this conversation');
    }

    const messages = await this.transactionHost.tx.chatMessage.updateMany(ChatRoomReadMessageHelper.toUpdateInput(user, body));
    console.log('🚀 ~ ChatMessageService ~ readMessage ~ messages:', messages);
  }

  async isParticipantBelongToConversation(accountId: number, roomId: number) {
    const conversation = await this.transactionHost.tx.chatParticipant.findFirst({
      where: { chatRoomId: roomId, participantId: accountId },
      select: { chatRoomId: true },
    });

    return Boolean(conversation);
  }
}
</file>

<file path="src/domains/course/admin/request/course-approve.request.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class CourseApproveREQ {
  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/course/admin/response/course-admin-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseAdminDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  image: ImageRESP;

  static fromEntity(course: CourseGetPayload, sections: CourseSectionDTO[], image: ImageRESP): CourseAdminDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/admin/response/course-admin-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';

export class CourseAdminListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: {
    id: number;
    name: string;
  };
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseAdminListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: {
        id: e.Creator.id,
        name: e.Creator.name,
      },
    };
  }
}
</file>

<file path="src/domains/course/admin/course-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminController', () => {
  let controller: CourseAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseAdminController],
      providers: [CourseAdminService],
    }).compile();

    controller = module.get<CourseAdminController>(CourseAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseAdminService } from './course-admin.service';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminDetailRESP } from './response/course-admin-detail.response';

@Controller('admin/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class CourseAdminController {
  constructor(private readonly courseAdminService: CourseAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseAdminListREQ) {
    const { dtos, count } = await this.courseAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { course, sectionDtos, image } = await this.courseAdminService.detail(id);

    const response = CourseAdminDetailRESP.fromEntity(course, sectionDtos, image);
    return BaseResponse.of(response);
  }

  @Patch(':id/approve')
  async approve(@Param('id', ParseIntPipe) id: number, @Body() body: CourseApproveREQ) {
    const course = await this.courseAdminService.approve(id, body);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/admin/course-admin.module.ts">
import { Module } from '@nestjs/common';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

@Module({
  controllers: [CourseAdminController],
  providers: [CourseAdminService, CourseListFactory],
})
export class CourseAdminModule {}
</file>

<file path="src/domains/course/admin/course-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminService', () => {
  let service: CourseAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseAdminService],
    }).compile();

    service = module.get<CourseAdminService>(CourseAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus, NotificationRelationType, NotificationType } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseErrorMessages } from 'src/shared/messages/error-messages';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminListRESP } from './response/course-admin-list.response';

@Injectable()
export class CourseAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly courseListFactory: CourseListFactory,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  async list(user: AuthUserDTO, query: CourseAdminListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.ADMIN, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
    const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
          _avg: { courseRating: true },
        });

        return CourseAdminListRESP.fromEntity(course, thumbnail, {
          noOfFeedbacks,
          noOfSubscriptions: course._count.Subscriptions,
          rateOfCourse: ratingOfCourse._avg.courseRating,
        });
      }),
    );

    return { dtos, count };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    const image = await this.imageService.getImageOriginal(course.imageId);

    return { course, sectionDtos, image };
  }

  async approve(id: number, body: CourseApproveREQ) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    if (course.status !== CourseStatus.PENDING) {
      throw new ActionFailedException(ActionFailed.COURSE_STATUS_CANNOT_UPDATE, CourseErrorMessages.MSG02);
    }

    const updatedCourse = await this.transactionHost.tx.course.update({
      where: { id: course.id },
      data: { status: body.isApproved ? CourseStatus.APPROVED : CourseStatus.REJECTED },
      select: { id: true, creatorId: true },
    });

    //Notification: Send notification to course owner
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      updatedCourse.creatorId,
      body.isApproved ? NotificationType.COURSE_APPROVED : NotificationType.COURSE_REJECTED,
    );

    runFunctionWithCondition(!!updatedCourse, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedCourse;
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/client/request/course-client-create.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  ArrayMinSize,
  IsArray,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Max,
  MaxLength,
  Min,
} from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseClientCreateREQ {
  @NameValidator()
  name: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @IsNumber()
  @Min(1)
  @Max(10)
  totalDuration: number;

  @Min(0)
  @IsNumber()
  price: number;

  @IdValidator()
  categoryId: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @BooleanValidator()
  isPublic: boolean;

  @IsEnum([CourseStatus.DRAFT, CourseStatus.PENDING])
  status: CourseStatus;

  @IsArray()
  @Type(() => String)
  prerequisites: string[];

  @IsArray()
  @Type(() => String)
  @ArrayNotDuplicated(String)
  objectives: string[];

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences: TargetAudience[];

  @IsArray()
  @IsOptional()
  @Type(() => CourseSectionDTO)
  sections?: CourseSectionDTO[] = [];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;

  static toCreateInput(user: AuthUserDTO, body: CourseClientCreateREQ): Prisma.CourseCreateArgs {
    return {
      data: {
        name: body.name,
        status: body.status,
        description: body.description,
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        totalDuration: body.totalDuration,
        price: body.price,
        startDate: parsePrismaDate(body.startDate),
        endDate: parsePrismaDate(body.endDate),
        Creator: connectRelation(user.accountId),
        Category: connectRelation(body.categoryId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/client/request/course-client-update.request.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class CourseClientUpdateREQ {
  @NameValidator()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description?: string;

  @IsNumber()
  @IsOptional()
  totalDuration?: number;

  @Min(0)
  @IsNumber()
  @IsOptional()
  price?: number;

  @IdValidator()
  @IsOptional()
  categoryId?: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsOptional()
  @IsEnum([CourseStatus.PENDING, CourseStatus.STOPPED, CourseStatus.ARCHIVED, CourseStatus.DRAFT])
  status?: CourseStatus;

  @IsNumber()
  @IsOptional()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  litmitOfStudents?: number;

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  prerequisites?: string[];

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  objectives: string[] = [];

  @IsArray()
  @IsOptional()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;
}
</file>

<file path="src/domains/course/client/request/course-section-client-update.request.ts">
import { PartialType } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ArrayMinSize, IsArray, IsOptional } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionUpdateDTO extends PartialType(CourseSectionDTO) {}

export class CourseSectionAddREQ extends CourseSectionDTO {}

export class CourseSectionRemoveREQ {
  @IsArray()
  @IsOptional()
  @Type(() => Number)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  removeSectionIds: number[] = [];
}
</file>

<file path="src/domains/course/client/response/course-client-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  mentor: CourseMentorDetailRESP;
  image: ImageRESP;

  static fromEntity(
    course: CourseGetPayload,
    sections: CourseSectionDTO[],
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
  ): CourseClientDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      mentor: mentor,
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-client-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  countOfSections: number;
  price: number;
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: CourseMentorDetailRESP;
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseClientListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      price: parseDecimalNumber(e.price),
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      countOfSections: e._count.Sections,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: mentor,
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-section-client.response.ts">
import { FileRESP } from 'src/domains/file/response/file.response';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionClientRESP {
  id: number;
  title: string;
  description: string;
  isPublic: boolean;
  files: FileRESP[];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionClientRESP {
    return {
      id: e.id,
      title: e.title,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/client/course-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

describe('CourseClientController', () => {
  let controller: CourseClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseClientController],
      providers: [CourseClientService],
    }).compile();

    controller = module.get<CourseClientController>(CourseClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthService } from 'src/domains/auth/auth.service';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseClientService } from './course-client.service';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionUpdateDTO } from './request/course-section-client-update.request';

@Controller('client/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR, AccountType.STUDENT)
export class CourseClientController {
  constructor(
    private readonly courseClientService: CourseClientService,
    private readonly authService: AuthService,
  ) {}

  @Get()
  @Public()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const { dtos, count } = await this.courseClientService.list(query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get('students')
  @Roles(AccountType.STUDENT)
  async getAllCoursesLearnedByStudent(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const dtos = await this.courseClientService.listCoursesLearnedByAccountId(req.user, query);

    return BaseResponse.of(dtos);
  }

  @Post()
  @Roles(AccountType.MENTOR)
  async create(@Req() req: AuthRequestDTO, @Body() body: CourseClientCreateREQ) {
    const course = await this.courseClientService.create(req.user, body);

    return BaseResponse.of(course);
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const jwtToken = req.headers['authorization']?.slice(7);
    const accountId = this.authService.getAccountIdFromToken(jwtToken);

    const course = await this.courseClientService.getPublicCourseDetail(id, accountId);

    return BaseResponse.of(course);
  }

  @Patch(':id')
  @Roles(AccountType.MENTOR)
  async update(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number, @Body() body: CourseClientUpdateREQ) {
    const course = await this.courseClientService.update(id, req.user, body);

    return BaseResponse.of(course);
  }

  @Delete(':id')
  @Roles(AccountType.MENTOR)
  async delete(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.courseClientService.delete(id, req.user);

    return BaseResponse.ok();
  }

  @Post(':courseId/sections')
  @Roles(AccountType.MENTOR)
  async createSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: CourseSectionDTO,
  ) {
    const course = await this.courseClientService.createSectionByCourseId(courseId, body, req.user);

    return BaseResponse.of(course);
  }

  @Patch(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async updateSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
    @Body() body: CourseSectionUpdateDTO,
  ) {
    const course = await this.courseClientService.updateSectionByCourseId(courseId, sectionId, body, req.user);

    return BaseResponse.of(course);
  }

  @Delete(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async deleteSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
  ) {
    const course = await this.courseClientService.deleteSectionByCourseId(courseId, sectionId, req.user);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/client/course-client.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from 'src/domains/auth/auth.module';
import { CommonModule } from 'src/services/common.module';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

@Module({
  imports: [CommonModule, AuthModule],
  controllers: [CourseClientController],
  providers: [CourseClientService, CourseListFactory],
  exports: [CourseClientService],
})
export class CourseClientModule {}
</file>

<file path="src/domains/course/client/course-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientService } from './course-client.service';

describe('CourseClientService', () => {
  let service: CourseClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseClientService],
    }).compile();

    service = module.get<CourseClientService>(CourseClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AccountType,
  CourseStatus,
  MentorStatus,
  NotificationRelationType,
  NotificationType,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { COURSE_PUBLIC_STATUS } from 'src/shared/constants/course.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseSectionHelper } from '../shared/helper/course-section.helper';
import { CourseUpdateHelper } from '../shared/helper/course-update-query.helper';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionAddREQ, CourseSectionUpdateDTO } from './request/course-section-client-update.request';
import { CourseClientDetailRESP } from './response/course-client-detail.response';
import { CourseClientListRESP } from './response/course-client-list.response';

@Injectable()
export class CourseClientService {
  private readonly logger: Logger = new Logger(CourseClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
    private readonly courseListFactory: CourseListFactory,
  ) {}

  async list(query: CourseClientListREQ) {
    query.courseStatus = CourseStatus.APPROVED;
    const courses = await this.transactionHost.tx.course.findMany(CourseListQueryHelper.toFindMany(query));
    const count = await this.transactionHost.tx.course.count({
      where: { ...CourseListQueryHelper.toQueryCondition(query), isPublic: true, status: CourseStatus.APPROVED },
    });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          { noOfSubscriptions: course._count.Subscriptions, noOfFeedbacks, rateOfCourse: await this.getRateOfCourse(course.id) },
        );
      }),
    );

    return { dtos, count };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async delete(id: number, user: AuthUserDTO) {
    //Check course belong to user
    let course: CourseGetPayload;
    try {
      course = (await this.transactionHost.tx.course.findUniqueOrThrow({
        where: { id: id, creatorId: user.accountId },
        select: {
          id: true,
          Sections: { select: { id: true, ...IS_ACTIVE_NESTED } },
          MentorSchedules: { select: { id: true, ...IS_ACTIVE_NESTED } },
        },
      })) as CourseGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    //Check if any subscription is active so throw error
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { courseId: id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
      select: { id: true },
    });

    if (!isEmpty(subscriptions)) throw new ActionFailedException(ActionFailed.COURSE_HAS_ACTIVE_SUBSCRIPTION);

    const sectionIds = await this.transactionHost.tx.courseSection.deleteMany({ where: { courseId: id } });
    if (!isEmpty(sectionIds)) {
      await Promise.all([
        //Delete course sections
        course.Sections.map(async (section) => {
          await this.transactionHost.tx.sectionAttachment.deleteMany({ where: { sectionId: section.id } });
        }),
        //Delete course schedules
        course.MentorSchedules.map(async (schedule) => {
          await this.transactionHost.tx.mentorSchedule.delete({ where: { id: schedule.id } });
        }),
      ]);
    }
    //Delete course
    await this.transactionHost.tx.course.delete({ where: { id } });
  }

  async listCoursesLearnedByAccountId(user: AuthUserDTO, query: CourseClientListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfSubscriptions: course._count.Subscriptions,
            noOfFeedbacks,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  // async getAllCoursesByAccount(user: AuthUserDTO, query: CourseClientListREQ) {
  //   const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
  //   const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
  //   const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

  //   const dtos = await Promise.all(
  //     courses.map(async (course: CourseGetPayload) => {
  //       const thumbnail = await this.imageService.getImageOriginal(course.imageId);
  //       return CourseClientListRESP.fromEntity(course, thumbnail);
  //     }),
  //   );

  //   return { dtos, count };
  // }

  async getPublicCourseDetail(id: number, accountId: number) {
    const { course, sectionDtos } = await this.detail(id);
    const isCoursePublic = COURSE_PUBLIC_STATUS.includes(course.status) && course.isPublic;

    if (!isCoursePublic && course.creatorId !== accountId) {
      throw new ActionFailedException(ActionFailed.COURSE_CANNOT_VIEW_DETAIL);
    }

    //TODO: Check if  course not public but student subcribed

    const image = await this.imageService.getImageOriginal(course.imageId);

    const { mentor, thumbnail } = await this.getMentorByAccountId(course.creatorId);

    return CourseClientDetailRESP.fromEntity(course, sectionDtos, image, {
      id: mentor.id,
      accountId: mentor.accountId,
      name: mentor.Account.name,
      thumbnail: thumbnail,
    });
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);

    return { mentor, thumbnail };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    return { course, sectionDtos };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(id: number, user: AuthUserDTO, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update course */
    const updatedCourse = await this.transactionHost.tx.course.update(CourseUpdateHelper.toUpdate(id, body));

    await this.imageService.linkImageToCourse(id, body.imageId);

    /* 3. TODO: Update notification to admin, and student subcribed */

    return updatedCourse;
  }

  async getAllbyCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ) {
    const courses = await this.transactionHost.tx.course.findMany(
      CourseListQueryHelper.toListByCreatorId(creatorId, isOwner, query),
    );

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfFeedbacks,
            noOfSubscriptions: course._count.Subscriptions,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  private async getRateOfCourse(courseId: number) {
    const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
      where: { Subscription: { courseId, ...IS_ACTIVE_NESTED } },
      _avg: { courseRating: true },
    });

    return ratingOfCourse._avg.courseRating;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, body: CourseClientCreateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { accountId: user.accountId },
      select: { id: true, status: true },
    });

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    if (body.categoryId) await this.checkExistedCategory(body.categoryId);

    const course = await this.transactionHost.tx.course.create(CourseClientCreateREQ.toCreateInput(user, body));
    await this.imageService.linkImageToCourse(course.id, body.imageId);

    /* create course sections  */
    //TODO: Handle files in each
    for (const section of body.sections) {
      await this.createSection(course.id, section);
    }

    //Notification: send Notification to admin
    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      admin.id,
      NotificationType.COURSE_CREATED,
    );

    runFunctionWithCondition(!!course, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return course;
  }

  // ==================== METHOD ====================
  private async createSection(courseId: number, section: CourseSectionDTO) {
    if (!courseId) return;

    if (!isEmpty(section.files)) {
      const fileIds = section.files.map((item) => item.fileId);
      await this.checkFiles(fileIds);
    }

    const ordinal = await this.transactionHost.tx.courseSection.aggregate(CourseSectionHelper.toFindMaxOrdinal(courseId));
    const maxOrdinal = ordinal._max.ordinal || 0;

    const courseSection = await this.transactionHost.tx.courseSection.create({
      data: CourseSectionHelper.toCreateInput(courseId, section, maxOrdinal),
      select: { id: true },
    });

    return courseSection;
  }

  private async checkExistedCategory(categoryId: number) {
    const category = await this.transactionHost.tx.category.findFirst({
      where: { id: categoryId },
      select: { id: true, parentCategoryId: true },
    });

    if (!category) throw new ActionFailedException(ActionFailed.CATEGORY_NOT_FOUND);

    return category;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateStatus(id: number, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow(CourseDetailQueryHelper.toFindUnique(id));

    await this.transactionHost.tx.course.update({
      where: { id },
      data: { status: body.status },
    });

    return course.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async createSectionByCourseId(courseId: number, body: CourseSectionAddREQ, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.createSection(courseId, body);

    return { courseId: course.id, sectionId: section.id };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateSectionByCourseId(courseId: number, sectionId: number, body: CourseSectionUpdateDTO, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.transactionHost.tx.courseSection.update({
      where: { id: sectionId, courseId },
      data: CourseSectionHelper.toUpdateInput(body),
      select: { id: true },
    });

    const fileIds = body.files.map((item) => item.fileId);
    await this.updateSectionAttachments(sectionId, fileIds);

    return { courseId: course.id, sectionId: section.id };
  }

  async updateSectionAttachments(sectionId: number, fileIds: number[]) {
    if (isEmpty(fileIds)) return;

    const attachments = await this.transactionHost.tx.sectionAttachment.findMany({
      where: { sectionId },
      select: { fileId: true },
    });

    const existedFileIds = attachments.map((item) => item.fileId);
    const notSectionFileIds = fileIds.filter((id) => !existedFileIds.includes(id));
    if (!isEmpty(notSectionFileIds)) {
      await this.checkFiles(notSectionFileIds);
      await this.transactionHost.tx.sectionAttachment.createMany({
        data: notSectionFileIds.map((fileId) => addCreationTimestamps({ sectionId, fileId })),
      });
    }

    for (const file of existedFileIds) {
      if (!fileIds.includes(file)) {
        const numberOfRecords = await this.transactionHost.tx.$executeRaw`DELETE FROM section_attachments WHERE file_id=${file}`;
        runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.delete(file));
      }
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async deleteSectionByCourseId(courseId: number, sectionId: number, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);
    const sectionIds = course.Sections.map((section) => section.id);

    if (isEmpty(sectionIds) || !sectionIds.includes(sectionId))
      throw new ActionFailedException(ActionFailed.COURSE_SECTION_NOT_FOUND_IN_COURSE);

    const section = await this.transactionHost.tx.courseSection.findFirst({
      where: { id: sectionId, courseId },
      select: { id: true, SectionAttachments: { select: { fileId: true } } },
    });

    /* 2. delete section attachments */
    const fileIds = section.SectionAttachments.map((item) => item.fileId);

    if (!isEmpty(fileIds)) {
      const numberOfRecords = await this.transactionHost.tx
        .$executeRaw`DELETE FROM section_attachments WHERE section_id=${sectionId}`;

      runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.checkAttachmentUploadedOrThrow(fileIds));
    }

    /* 3. delete course sections */
    await this.transactionHost.tx.courseSection.delete({
      where: { id: sectionId, courseId: courseId },
    });

    return { courseId: course.id, sectionId: section.id };
  }

  // async updateTotalDuration(courseId: number) {
  //   const totalDuration = await this.transactionHost.tx.courseSection.aggregate({
  //     where: { courseId, ...IS_ACTIVE_NESTED },
  //     _sum: { duration: true },
  //   });

  //   await this.transactionHost.tx.course.update({
  //     where: { id: courseId },
  //     data: { totalDuration: totalDuration._sum.duration },
  //   });
  // }

  @Transactional(TRANSACTION_TIMEOUT)
  async checkFiles(fileIds: number[]) {
    await this.fileService.checkAttachmentUploadedOrThrow(fileIds);
    // await this.fileService.checkFileLinked(fileIds);

    /* Create and link file */
    await this.fileService.enableUploaded(fileIds);
  }

  async checkCourseCreator(accountId: number, creatorId: number) {
    if (accountId !== creatorId) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/dto/course-section.dto.ts">
import { Type } from 'class-transformer';
import { ArrayMaxSize, IsArray, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { FileRESP } from 'src/domains/file/response/file.response';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { orNull } from 'src/shared/parsers/io.parser';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionAttachmentDTO {
  @IdValidator()
  fileId: number;

  @IsOptional()
  @BooleanValidator()
  isPublic: boolean = false;
}

export class CourseSectionDTO {
  @IdValidator()
  @IsOptional()
  id?: number;

  @NameValidator()
  title: string;

  @IsNumber()
  @IsOptional()
  ordinal?: number;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @BooleanValidator()
  isPublic: boolean = false;

  @IsArray()
  @Type(() => CourseSectionAttachmentDTO)
  @IsOptional()
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  files?: CourseSectionAttachmentDTO[] = [];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionDTO {
    return {
      id: e.id,
      title: e.title,
      ordinal: e.ordinal,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-admin-list.request.ts">
import { PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseAdminListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseAdminListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: condition,
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        status: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-client-list.request.ts">
import { AccountStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseClientListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseClientListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount(user: AuthUserDTO, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: { ...condition, Creator: { status: { not: AccountStatus.SUSPENSIVE } } },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/course-list.factory.ts">
import { Injectable } from '@nestjs/common';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { CourseBaseListREQ } from '../shared/course-base-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseAdminListREQ } from './list/course-admin-list.request';
import { CourseClientListREQ } from './list/course-client-list.request';

@Injectable()
export class CourseListFactory {
  getClass<T extends CourseBaseListREQ>(classType: CourseListDTOType, data: T): CourseBaseListREQ {
    switch (classType) {
      case CourseListDTOType.CLIENT:
        return new CourseClientListREQ(data);
      case CourseListDTOType.ADMIN:
        return new CourseAdminListREQ(data);
      default:
        throw new ActionFailedException(ActionFailed.CLASS_TYPE_NOT_FOUND);
    }
  }
}
</file>

<file path="src/domains/course/shared/helper/course-detail-query.helper.ts">
import { Prisma } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class CourseDetailQueryHelper {
  static toFindUnique(id: number): Prisma.CourseFindUniqueOrThrowArgs {
    // const isCourseOwner = user.accountType === AccountType.MENTOR;

    // const creator = orUndefinedWithCondition(isCourseOwner, {
    //   creatorId: user.accountId,
    // });

    return {
      where: { id },
      select: {
        id: true,
        name: true,
        status: true,
        description: true,
        totalDuration: true,
        price: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        litmitOfStudents: true,
        creatorId: true,
        categoryId: true,
        createdAt: true,
        imageId: true,
        Category: {
          select: { id: true, name: true },
        },
        Sections: {
          where: { ...IS_ACTIVE_NESTED },
          orderBy: { ordinal: 'asc' },
          select: { id: true, title: true, description: true, ordinal: true, isPublic: true },
        },
        Creator: { select: { id: true, name: true } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-list-query.helper.ts">
import { AccountStatus, AccountType, CourseStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientListREQ } from '../../factory/list/course-client-list.request';
import { CourseBaseListREQ } from '../course-base-list.request';
import { CourseSortableFields } from '../enums';

export class CourseListQueryHelper {
  static toFilterByAccountType = (user: AuthUserDTO): Prisma.CourseWhereInput => {
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.STUDENT:
        return {
          status: CourseStatus.APPROVED,
          Subscriptions: { some: { Account: { id: user.accountId, accountType: AccountType.STUDENT }, ...IS_ACTIVE_NESTED } },
        };
      case AccountType.MENTOR:
        return {
          OR: [
            { Creator: { id: user.accountId, accountType: AccountType.MENTOR } },
            { isPublic: true, status: CourseStatus.APPROVED },
          ],
        };
      default:
        return { isPublic: true, status: CourseStatus.APPROVED };
    }
  };

  static toQueryCondition = (query: CourseBaseListREQ): Prisma.CourseWhereInput => {
    const creatorName = orUndefinedWithCondition(!!query.creatorName, { Creator: parsePrismaSearch('name', query.creatorName) });
    const courseName = orUndefinedWithCondition(!!query.courseName, parsePrismaSearch('name', query.courseName));
    const targetAudiences = orUndefinedWithCondition(!!query.targetAudiences, {
      targetAudiences: { hasEvery: query.targetAudiences },
    });
    const categoryIds = orUndefinedWithCondition(!!query.categoryIds, {
      Category: { id: { in: query.categoryIds } },
    });

    return leanObject({
      status: query.courseStatus,
      ...courseName,
      ...creatorName,
      ...targetAudiences,
      ...categoryIds,
    });
  };

  static toOrderBy = (query: CourseBaseListREQ): Prisma.CourseOrderByWithRelationInput => {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case CourseSortableFields.CREATOR_NAME:
        return { Creator: { name: query.sortOrder } };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  };

  static toListByCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const condition = isOwner ? this.toQueryCondition(query) : { status: CourseStatus.APPROVED };

    return {
      where: { Creator: { id: creatorId }, ...condition },
      orderBy: defaultSortDesc,
      select: {
        id: true,
        name: true,
        status: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,

        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }

  static toFindMany(query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const orderBy = CourseListQueryHelper.toOrderBy(query);
    const condition = CourseListQueryHelper.toQueryCondition(query);

    return {
      where: {
        ...condition,
        isPublic: true,
        status: CourseStatus.APPROVED,
        Creator: {
          status: { not: AccountStatus.SUSPENSIVE },
        },
      },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        imageId: true,
        createdAt: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true, avatarId: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-section.helper.ts">
import { Prisma } from '@prisma/client';
import { isEmpty } from 'lodash';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseSectionUpdateDTO } from '../../client/request/course-section-client-update.request';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionHelper {
  static toCreateInput(courseId: number, body: CourseSectionDTO, maxOrdinal: number): Prisma.CourseSectionCreateInput {
    //TODO: Add fileData
    const fileData = orUndefinedWithCondition(!isEmpty(body.files), {
      SectionAttachments: {
        createMany: {
          data: body.files.map((item) => addCreationTimestamps({ fileId: item.fileId, isPublic: item.isPublic })),
        },
      },
    });

    return {
      title: body.title,
      ordinal: maxOrdinal + 1,
      description: body.description,
      isPublic: body.isPublic,
      Course: connectRelation(courseId),
      ...fileData,
    };
  }

  static toUpdateInput(body: CourseSectionUpdateDTO): Prisma.CourseSectionUpdateInput {
    return {
      title: body.title,
      description: body.description,
      isPublic: body.isPublic,
    };
  }

  static toFindMaxOrdinal(courseId: number): Prisma.CourseSectionAggregateArgs {
    return {
      where: { courseId },
      _max: { ordinal: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-update-query.helper.ts">
import { Prisma } from '@prisma/client';
import { connectRelation, removeRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientUpdateREQ } from '../../client/request/course-client-update.request';

export class CourseUpdateHelper {
  static toUpdate(id: number, body: CourseClientUpdateREQ): Prisma.CourseUpdateArgs {
    return {
      where: { id },
      data: {
        name: body.name,
        description: body.description,
        price: body.price,
        isPublic: body.isPublic,
        startDate: parsePrismaDate(body.startDate),
        status: body.status,
        endDate: parsePrismaDate(body.endDate),
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        litmitOfStudents: body.litmitOfStudents,
        Category: connectRelation(body.categoryId),
        ...orUndefinedWithCondition(!!body.imageId, { Image: removeRelation() }),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/course-base-list.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { QueryArray } from 'src/shared/request-validator/query-array.validator';
import { CourseSortableFields } from './enums';

export abstract class CourseBaseListREQ extends PaginationREQ {
  @IsOptional()
  @NameValidator()
  courseName?: string;

  @IsOptional()
  @IsEnum(CourseStatus)
  courseStatus?: CourseStatus;

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(4)
  @IsOptional()
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @IsOptional()
  @ArrayNotDuplicated(Number)
  @QueryArray({ fieldType: 'number', minSize: COMMON_CONSTANT.ARRAY_MIN_SIZE })
  categoryIds?: number[];

  @NameValidator()
  @IsOptional()
  creatorName?: string;

  @IsOptional()
  @IsEnum(CourseSortableFields)
  sortBy?: CourseSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  abstract toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs;
}
</file>

<file path="src/domains/course/shared/enums.ts">
export enum CourseSortableFields {
  CREATOR_NAME = 'creatorName',
  COURSE_NAME = 'name',
  COURSE_STATUS = 'status',
  COURSE_TYPE = 'courseType',
}

export enum CourseListDTOType {
  CLIENT = 'client',
  ADMIN = 'admin',
}
</file>

<file path="src/domains/course/shared/types.ts">
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
export enum TargetAudienceLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  ADVANCED = 'ADVANCED',
  EXPERT = 'EXPERT',
}

export type CourseSectionUpdateDTO = {
  id: number;
} & CourseSectionDTO;

export type CourseMentorDetailRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
</file>

<file path="src/domains/course/course.module.ts">
import { Module } from '@nestjs/common';
import { CourseAdminModule } from './admin/course-admin.module';
import { CourseClientModule } from './client/course-client.module';

@Module({
  imports: [CourseClientModule, CourseAdminModule],
  exports: [CourseClientModule],
})
export class CourseModule {}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardAdminController } from './dashboard-admin.controller';
import { DashboardAdminService } from './dashboard-admin.service';

describe('DashboardAdminController', () => {
  let controller: DashboardAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DashboardAdminController],
      providers: [DashboardAdminService],
    }).compile();

    controller = module.get<DashboardAdminController>(DashboardAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.controller.ts">
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { DashboardAdminService } from './dashboard-admin.service';

@Controller('admin/dashboard')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class DashboardAdminController {
  constructor(private readonly dashboardAdminService: DashboardAdminService) {}

  @Get('overview')
  async getOverviewStatistic(@Query() query: StatisticOverviewListREQ) {
    const res = await this.dashboardAdminService.getOverviewStatistic(query);

    return BaseResponse.of(res);
  }

  @Get('payments')
  async getPaymentStatistic(@Query() query: StatisticPaymentListREQ) {
    const res = await this.dashboardAdminService.getPaymentStatistic(query);

    return BaseResponse.of(res);
  }

  @Get('subscriptions')
  async getSubscriptionStatistic(@Query() query: StatisticSubscriptionListREQ) {
    const res = await this.dashboardAdminService.listSubscription(query);

    return BaseResponse.of(res);
  }
}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { DashboardAdminController } from './dashboard-admin.controller';
import { DashboardAdminService } from './dashboard-admin.service';

@Module({
  imports: [AccountModule, MentorClientModule],
  controllers: [DashboardAdminController],
  providers: [DashboardAdminService],
})
export class DashboardAdminModule {}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardAdminService } from './dashboard-admin.service';

describe('DashboardAdminService', () => {
  let service: DashboardAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DashboardAdminService],
    }).compile();

    service = module.get<DashboardAdminService>(DashboardAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { StudentGetPayload } from 'src/domains/student/shared/types';
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { getDiffDaysOfDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { getMillisecondsFromCurrentDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticOverviewAdminListHelper } from '../helper/statistic-overview-admin-list.helper';
import { StatisticPaymentListHelper } from '../helper/statistic-payment-list.helper';
import { StatisticSubscriptionListHelper } from '../helper/statistic-subscription-list.helper';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticOverviewListRESP } from '../response/statistic-overview-list.response';
import { StatisticPaymentListRESP } from '../response/statistic-payment-list.response';
import { StatisticSubscriptionListRESP } from '../shared/types';

@Injectable()
export class DashboardAdminService {
  private readonly logger = new Logger(DashboardAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
    private readonly mentorClientService: MentorClientService,
  ) {}

  async getOverviewStatistic(query: StatisticOverviewListREQ): Promise<StatisticOverviewListRESP> {
    const mentors = await this.transactionHost.tx.mentor.findMany(StatisticOverviewAdminListHelper.toFindManyMentor(query));
    const students = await this.transactionHost.tx.student.findMany(StatisticOverviewAdminListHelper.toFindManyStudent(query));
    const courses = await this.transactionHost.tx.course.findMany(StatisticOverviewAdminListHelper.toFindManyCourse(query));
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      StatisticOverviewAdminListHelper.toFindManySubscription(query),
    );
    const reports = await this.transactionHost.tx.report.findMany(StatisticOverviewAdminListHelper.toFindManyReport(query));
    const revenue = await this.transactionHost.tx.payment.findMany(StatisticOverviewAdminListHelper.toFindManyPayment(query));

    return {
      mentorOverview: StatisticOverviewAdminListHelper.getMentorOverview(mentors),
      courseOverview: StatisticOverviewAdminListHelper.getCourseOverview(courses),
      studentOverview: StatisticOverviewAdminListHelper.getStudentOverview(students as StudentGetPayload[]),
      subscriptionOverview: StatisticOverviewAdminListHelper.getSubscriptionOverview(subscriptions),
      reportOverview: StatisticOverviewAdminListHelper.getReportOverview(reports),
      revenueOverview: StatisticOverviewAdminListHelper.getPaymentOverview(revenue),
    };
  }

  async getPaymentStatistic(query: StatisticPaymentListREQ): Promise<StatisticPaymentListRESP[]> {
    const diffDays = getDiffDaysOfDateRange(query.dateRange);
    const numbers = Array.from({ length: diffDays + 1 }, (_, i) => i);
    const result = [];
    // Iterate over the numbers using for...of
    for (const number of numbers) {
      const beginDate = getMillisecondsFromCurrentDate({ days: number, fromBeginning: true });
      const endDate = getMillisecondsFromCurrentDate({ days: number, fromEnding: true });

      const paymentAggre = await this.transactionHost.tx.payment.aggregate(
        StatisticPaymentListHelper.toAggregate(query, beginDate, endDate),
      );
      const noOfPayments = await this.transactionHost.tx.payment.count({
        where: StatisticPaymentListHelper.toQueryPaymentCondition(query, beginDate, endDate),
      });

      const value: StatisticPaymentListRESP = { totalAmount: parseDecimalNumber(paymentAggre._sum.price), noOfPayments };
      const date = getMillisecondsFromCurrentDate({ days: number });
      result.push({ [String(date)]: value });
    }

    return result;
  }

  async listSubscription(query: StatisticSubscriptionListREQ): Promise<StatisticSubscriptionListRESP[]> {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(StatisticSubscriptionListHelper.toFindMany(query));

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );
  }
}
</file>

<file path="src/domains/dashboard/client/dashboard-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardClientController } from './dashboard-client.controller';
import { DashboardClientService } from './dashboard-client.service';

describe('DashboardClientController', () => {
  let controller: DashboardClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DashboardClientController],
      providers: [DashboardClientService],
    }).compile();

    controller = module.get<DashboardClientController>(DashboardClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/client/dashboard-client.controller.ts">
import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticTopCourseListREQ } from '../request/statistic-top-course-list.request';
import { DashboardClientService } from './dashboard-client.service';

@Controller('client/dashboard')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR)
export class DashboardClientController {
  constructor(private readonly dashboardClientService: DashboardClientService) {}

  @Get('overview')
  async getOverviewStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticOverviewListREQ) {
    const res = await this.dashboardClientService.getOverviewStatistic(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('payments')
  async getPaymentStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticPaymentListREQ) {
    const res = await this.dashboardClientService.getPaymentStatistic(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('subscriptions')
  async getSubscriptionStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticSubscriptionListREQ) {
    const res = await this.dashboardClientService.listSubscription(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('top-courses')
  async getTopCourses(@Req() req: AuthRequestDTO, @Query() query: StatisticTopCourseListREQ) {
    const res = await this.dashboardClientService.getTopCourses(req.user, query);

    console.log('🚀 ~ DashboardClientController ~ getTopCourses ~ res:', res);

    return BaseResponse.of(res);
  }
}
</file>

<file path="src/domains/dashboard/client/dashboard-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { DashboardClientController } from './dashboard-client.controller';
import { DashboardClientService } from './dashboard-client.service';

@Module({
  imports: [AccountModule],
  controllers: [DashboardClientController],
  providers: [DashboardClientService],
})
export class DashboardClientModule {}
</file>

<file path="src/domains/dashboard/client/dashboard-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardClientService } from './dashboard-client.service';

describe('DashboardClientService', () => {
  let service: DashboardClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DashboardClientService],
    }).compile();

    service = module.get<DashboardClientService>(DashboardClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/client/dashboard-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { SubscriptionStatus } from '@prisma/client';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { getDiffDaysOfDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { getMillisecondsFromCurrentDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticOverviewClientListHelper } from '../helper/statistic-overview-client-list.helper';
import { StatisticPaymentListHelper } from '../helper/statistic-payment-list.helper';
import { StatisticSubscriptionListHelper } from '../helper/statistic-subscription-list.helper';
import { StatisticCourseListHelper } from '../request/statistic-course-list.request';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticTopCourseListREQ } from '../request/statistic-top-course-list.request';
import { StatisticOverviewClientListRESP } from '../response/statistic-overview-list.response';
import { StatisticPaymentListRESP } from '../response/statistic-payment-list.response';
import { StatisticSubscriptionListRESP, TopCourseType } from '../shared/types';

@Injectable()
export class DashboardClientService {
  private readonly logger = new Logger(DashboardClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
  ) {}

  async getOverviewStatistic(user: AuthUserDTO, query: StatisticOverviewListREQ): Promise<StatisticOverviewClientListRESP> {
    const courses = await this.transactionHost.tx.course.findMany(
      StatisticOverviewClientListHelper.toFindManyCourse(user.accountId, query),
    );
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      StatisticOverviewClientListHelper.toFindManySubscription(user.accountId, query),
    );
    const revenue = await this.transactionHost.tx.payment.findMany(
      StatisticOverviewClientListHelper.toFindManyPayment(user.accountId, query),
    );

    return {
      courseOverview: StatisticOverviewClientListHelper.getCourseOverview(courses),
      subscriptionOverview: StatisticOverviewClientListHelper.getSubscriptionOverview(subscriptions),
      revenueOverview: StatisticOverviewClientListHelper.getPaymentOverview(revenue),
    };
  }

  async getPaymentStatistic(user: AuthUserDTO, query: StatisticPaymentListREQ): Promise<StatisticPaymentListRESP[]> {
    const diffDays = getDiffDaysOfDateRange(query.dateRange);
    const numbers = Array.from({ length: diffDays + 1 }, (_, i) => i);
    const result = [];
    // Iterate over the numbers using for...of
    for (const number of numbers) {
      const beginDate = getMillisecondsFromCurrentDate({ days: number, fromBeginning: true });
      const endDate = getMillisecondsFromCurrentDate({ days: number, fromEnding: true });

      const paymentAggre = await this.transactionHost.tx.payment.aggregate(
        StatisticPaymentListHelper.toAggregateByAccountId(user.accountId, query, beginDate, endDate),
      );
      const noOfPayments = await this.transactionHost.tx.payment.count({
        where: {
          ...StatisticPaymentListHelper.toQueryPaymentCondition(query, beginDate, endDate),
          Subscription: { Course: { creatorId: user.accountId } },
        },
      });

      const value: StatisticPaymentListRESP = { totalAmount: parseDecimalNumber(paymentAggre._sum.price), noOfPayments };
      const date = getMillisecondsFromCurrentDate({ days: number });
      result.push({ [String(date)]: value });
    }

    return result;
  }

  async listSubscription(user: AuthUserDTO, query: StatisticSubscriptionListREQ): Promise<StatisticSubscriptionListRESP[]> {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      ...StatisticSubscriptionListHelper.toFindMany(query),
      where: { Course: { creatorId: user.accountId } },
    });

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
        );
      }),
    );
  }

  async getTopCourses(user: AuthUserDTO, query: StatisticTopCourseListREQ) {
    if (query.topCourseType === TopCourseType.TOP_RATE) {
      const courses = await this.transactionHost.tx.course.findMany(
        StatisticCourseListHelper.toGetTopCoursesByRate(user.accountId),
      );

      this.logger.log('🚀 ~ DashboardClientService ~ getTopCourses ~ subscriptions:', courses);

      return courses
        .map((course) => {
          const courseRating =
            course.Subscriptions.map((sub) => sub.Feedback.courseRating).reduce((a, b) => a + b, 0) / course._count.Subscriptions;

          return {
            id: course.id,
            name: course.name,
            rate: courseRating,
          };
        })
        .sort((a, b) => b.rate - a.rate)
        .slice(0, 6);
    }

    const courses = await this.transactionHost.tx.course.findMany({
      where: { creatorId: user.accountId },
      select: {
        id: true,
        name: true,
        _count: {
          select: { Subscriptions: { where: { status: SubscriptionStatus.ENDED, ...IS_ACTIVE_NESTED } } },
        },
      },
    });

    this.logger.log('🚀 ~ DashboardClientService ~ getTopCourses ~ subscriptions:', courses);

    return courses
      .map((course) => {
        return {
          id: course.id,
          name: course.name,
          noOfSubscription: course._count.Subscriptions,
        };
      })
      .sort((a, b) => b.noOfSubscription - a.noOfSubscription)
      .slice(0, 6);
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-overview-admin-list.helper.ts">
import {
  AccountStatus,
  Course,
  CourseStatus,
  Mentor,
  MentorStatus,
  Payment,
  Prisma,
  Report,
  ReportStatus,
  Subscription,
  SubscriptionStatus,
} from '@prisma/client';
import { StudentGetPayload } from 'src/domains/student/shared/types';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { filterByDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import {
  StatisticCourseOverviewRESP,
  StatisticMentorOverviewRESP,
  StatisticReportOverviewRESP,
  StatisticRevenueOverviewRESP,
  StatisticStudentOverviewRESP,
  StatisticSubscriptionOverviewRESP,
} from '../response/statistic-overview-list.response';

export class StatisticOverviewAdminListHelper {
  static toCountConditionQuery(query: StatisticOverviewListREQ) {
    const filterDateRange = filterByDateRange(query.dateRange);

    return { ...filterDateRange };
  }

  static toFindManyMentor(query: StatisticOverviewListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Account: { status: AccountStatus.ACTIVE, ...IS_ACTIVE_NESTED } },
      select: { status: true },
    };
  }

  // static toFindManyStudent(query: StatisticOverviewListREQ): Prisma.StudentFindManyArgs {
  //   const condition = this.toCountConditionQuery(query);

  //   return {
  //     where: { ...condition, Account: { status: AccountStatus.ACTIVE, ...IS_ACTIVE_NESTED } },
  //     select: {}
  //   };
  // }

  static toFindManyCourse(query: StatisticOverviewListREQ): Prisma.CourseFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManySubscription(query: StatisticOverviewListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManyReport(query: StatisticOverviewListREQ): Prisma.ReportFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManyPayment(query: StatisticOverviewListREQ): Prisma.PaymentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true, price: true, refundedPrice: true },
    };
  }

  static toFindManyStudent(query: StatisticOverviewListREQ): Prisma.StudentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { Account: { select: { status: true } } },
    };
  }

  static getMentorOverview(mentors: Mentor[]): StatisticMentorOverviewRESP {
    const mentorOverview: StatisticMentorOverviewRESP = {
      approvedMentor: 0,
      pendingMentor: 0,
    };

    mentors.forEach((mentor) => {
      if (mentor.status === MentorStatus.ACCEPTED) {
        mentorOverview.approvedMentor++;
      } else if (mentor.status === MentorStatus.PENDING) {
        mentorOverview.pendingMentor++;
      }
      //  else if (mentor.status ===  MentorStatus.) {
      //   mentorOverview.interviewScheduledMentor++;
      // }
    });

    return mentorOverview;
  }

  static getCourseOverview(courses: Course[]): StatisticCourseOverviewRESP {
    const courseOverview: StatisticCourseOverviewRESP = {
      approvedCourse: 0,
      pendingCourse: 0,
      suspendedCourse: 0,
    };

    courses.forEach((course) => {
      if (course.status === CourseStatus.APPROVED) {
        courseOverview.approvedCourse++;
      } else if (course.status === CourseStatus.PENDING) {
        courseOverview.pendingCourse++;
      } else if (course.status === CourseStatus.SUSPENDED) {
        courseOverview.suspendedCourse++;
      }
    });

    return courseOverview;
  }

  static getSubscriptionOverview(subscriptions: Subscription[]): StatisticSubscriptionOverviewRESP {
    const subscriptionOverview: StatisticSubscriptionOverviewRESP = {
      activeSubscription: 0,
      pendingSubscription: 0,
      expiredSubscription: 0,
      cancelledSubscription: 0,
    };

    subscriptions.forEach((subscription) => {
      if (subscription.status === SubscriptionStatus.ACTIVE) {
        subscriptionOverview.activeSubscription++;
      } else if (subscription.status === SubscriptionStatus.PENDING) {
        subscriptionOverview.pendingSubscription++;
      } else if (subscription.status === SubscriptionStatus.EXPIRED) {
        subscriptionOverview.expiredSubscription++;
      } else if (subscription.status === SubscriptionStatus.CANCELED) {
        subscriptionOverview.cancelledSubscription++;
      }
    });

    return subscriptionOverview;
  }

  static getReportOverview(reports: Report[]): StatisticReportOverviewRESP {
    const reportOverview: StatisticReportOverviewRESP = {
      pendingReport: 0,
      resolvedReport: 0,
    };

    reports.forEach((report) => {
      if (report.status === ReportStatus.PENDING) {
        reportOverview.pendingReport++;
      } else if (report.status === ReportStatus.RESOLVED) {
        reportOverview.resolvedReport++;
      }
    });

    return reportOverview;
  }

  static getPaymentOverview(payments: Payment[]): StatisticRevenueOverviewRESP {
    const paymentOverview: StatisticRevenueOverviewRESP = {
      totalRevenue: 0,
      refundAmount: 0,
    };

    return payments.reduce((acc, payment) => {
      const revenue = parseDecimalNumber(payment.price) - parseDecimalNumber(payment.refundedPrice ?? 0);
      const refundAmount = parseDecimalNumber(payment.refundedPrice);

      return { totalRevenue: acc.totalRevenue + revenue, refundAmount: acc.refundAmount + refundAmount };
    }, paymentOverview);
  }

  static getStudentOverview(students: StudentGetPayload[]): StatisticStudentOverviewRESP {
    const studentOverview: StatisticStudentOverviewRESP = {
      activeStudent: 0,
      suspendedStudent: 0,
    };

    students.forEach((student) => {
      if (student.Account.status === AccountStatus.ACTIVE) {
        studentOverview.activeStudent++;
      } else if (student.Account.status === AccountStatus.SUSPENSIVE) {
        studentOverview.suspendedStudent++;
      }
    });

    return studentOverview;
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-overview-client-list.helper.ts">
import { Course, CourseStatus, Payment, Prisma, Subscription, SubscriptionStatus } from '@prisma/client';
import { filterByDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import {
  StatisticCourseOverviewRESP,
  StatisticRevenueOverviewRESP,
  StatisticSubscriptionOverviewRESP,
} from '../response/statistic-overview-list.response';

export class StatisticOverviewClientListHelper {
  static toCountConditionQuery(query: StatisticOverviewListREQ) {
    const filterDateRange = filterByDateRange(query.dateRange);

    return { ...filterDateRange };
  }

  static toFindManyCourse(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.CourseFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, creatorId: mentorAccountId },
      select: { status: true },
    };
  }

  static toFindManySubscription(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Course: { creatorId: mentorAccountId } },
      select: { status: true },
    };
  }

  static toFindManyPayment(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.PaymentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Subscription: { Course: { creatorId: mentorAccountId } } },
      select: { status: true, price: true, refundedPrice: true },
    };
  }

  static getCourseOverview(courses: Course[]): StatisticCourseOverviewRESP {
    const courseOverview: StatisticCourseOverviewRESP = {
      approvedCourse: 0,
      pendingCourse: 0,
      suspendedCourse: 0,
    };

    courses.forEach((course) => {
      if (course.status === CourseStatus.APPROVED) {
        courseOverview.approvedCourse++;
      } else if (course.status === CourseStatus.PENDING) {
        courseOverview.pendingCourse++;
      } else if (course.status === CourseStatus.SUSPENDED) {
        courseOverview.suspendedCourse++;
      }
    });

    return courseOverview;
  }

  static getSubscriptionOverview(subscriptions: Subscription[]): StatisticSubscriptionOverviewRESP {
    const subscriptionOverview: StatisticSubscriptionOverviewRESP = {
      activeSubscription: 0,
      pendingSubscription: 0,
      expiredSubscription: 0,
      cancelledSubscription: 0,
    };

    subscriptions.forEach((subscription) => {
      if (subscription.status === SubscriptionStatus.ACTIVE) {
        subscriptionOverview.activeSubscription++;
      } else if (subscription.status === SubscriptionStatus.PENDING) {
        subscriptionOverview.pendingSubscription++;
      } else if (subscription.status === SubscriptionStatus.EXPIRED) {
        subscriptionOverview.expiredSubscription++;
      } else if (subscription.status === SubscriptionStatus.CANCELED) {
        subscriptionOverview.cancelledSubscription++;
      }
    });

    return subscriptionOverview;
  }

  static getPaymentOverview(payments: Payment[]): StatisticRevenueOverviewRESP {
    const paymentOverview: StatisticRevenueOverviewRESP = {
      totalRevenue: 0,
      refundAmount: 0,
    };

    return payments.reduce((acc, payment) => {
      const revenue = parseDecimalNumber(payment.price) - parseDecimalNumber(payment.refundedPrice ?? 0);
      const refundAmount = parseDecimalNumber(payment.refundedPrice);

      return { totalRevenue: acc.totalRevenue + revenue, refundAmount: acc.refundAmount + refundAmount };
    }, paymentOverview);
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-payment-list.helper.ts">
import { PaymentStatus, Prisma } from '@prisma/client';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';

export class StatisticPaymentListHelper {
  static toQueryPaymentCondition(query: StatisticPaymentListREQ, beginDate: number, endDate: number): Prisma.PaymentWhereInput {
    const paymentStatus = !!query.status ? query.status : PaymentStatus.DONE;

    return {
      status: paymentStatus,
      AND: [{ createdAt: { gte: beginDate } }, { createdAt: { lte: endDate } }],
    };
  }

  static toAggregate(query: StatisticPaymentListREQ, beginDate: number, endDate: number): Prisma.PaymentAggregateArgs {
    const condition = this.toQueryPaymentCondition(query, beginDate, endDate);

    return {
      where: condition,
      _sum: { price: true },
    };
  }

  static toAggregateByAccountId(
    accountId: number,
    query: StatisticPaymentListREQ,
    beginDate: number,
    endDate: number,
  ): Prisma.PaymentAggregateArgs {
    const condition = this.toQueryPaymentCondition(query, beginDate, endDate);

    return {
      where: { ...condition, Subscription: { Course: { creatorId: accountId } } },
      _sum: { price: true },
    };
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-subscription-list.helper.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { SubscriptionGetPlayload, SubscriptionMentorListRESP } from 'src/domains/subscription/shared/types';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticSubscriptionListRESP } from '../shared/types';

export class StatisticSubscriptionListHelper {
  static toFindMany(query: StatisticSubscriptionListREQ): Prisma.SubscriptionFindManyArgs {
    return {
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static fromEntity(
    e: SubscriptionGetPlayload,
    studentInfo: AccountRESP,
    mentorInfo?: SubscriptionMentorListRESP,
  ): StatisticSubscriptionListRESP {
    return {
      id: e.id,
      status: e.status,
      originalPrice: parseDecimalNumber(e.originalPrice),
      courseStartAt: parseEpoch(e.courseAccessStartAt),
      courseEndAt: parseEpoch(e.courseAccessEndAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      course: { id: e.Course.id, name: e.Course.name },
      payment: orNullWithCondition(!!e.Payment, {
        id: e.Payment?.id,
        status: e.Payment?.status,
        price: parseDecimalNumber(e.Payment?.price),
      }),
    };
  }
}
</file>

<file path="src/domains/dashboard/request/statistic-base-list.request.ts">
import { IsEnum } from 'class-validator';
import { DateRangeFilter } from 'src/shared/enums/common.enum';

export class StatisticBaseListREQ {
  @IsEnum(DateRangeFilter)
  dateRange: DateRangeFilter = DateRangeFilter.ALL;
}
</file>

<file path="src/domains/dashboard/request/statistic-course-list.request.ts">
import { SubscriptionStatus } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class StatisticCourseListHelper {
  static toGetTopCoursesByRate(accountId: number) {
    return {
      where: {
        creatorId: accountId,
        Subscriptions: { some: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED } },
      },
      select: {
        id: true,
        name: true,
        Subscriptions: {
          where: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED },
          select: { id: true, Feedback: { select: { courseRating: true } } },
        },
        _count: {
          select: {
            Subscriptions: { where: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED } },
          },
        },
      },
    };
  }
}
</file>

<file path="src/domains/dashboard/request/statistic-overview-list.request.ts">
import { StatisticBaseListREQ } from './statistic-base-list.request';

export class StatisticOverviewListREQ extends StatisticBaseListREQ {}
</file>

<file path="src/domains/dashboard/request/statistic-payment-list.request.ts">
import { PaymentStatus } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { StatisticPaymentStatus } from 'src/shared/constants/dashboard.constant';
import { StatisticBaseListREQ } from './statistic-base-list.request';

export class StatisticPaymentListREQ extends StatisticBaseListREQ {
  @IsEnum(StatisticPaymentStatus)
  @IsOptional()
  status?: PaymentStatus;
}
</file>

<file path="src/domains/dashboard/request/statistic-subscription-list.request.ts">
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class StatisticSubscriptionListREQ extends PaginationREQ {}
</file>

<file path="src/domains/dashboard/request/statistic-top-course-list.request.ts">
import { IsEnum } from 'class-validator';
import { TopCourseType } from '../shared/types';
import { StatisticOverviewListREQ } from './statistic-overview-list.request';

export class StatisticTopCourseListREQ extends StatisticOverviewListREQ {
  @IsEnum(TopCourseType)
  topCourseType: TopCourseType;
}
</file>

<file path="src/domains/dashboard/response/statistic-overview-list.response.ts">
export class StatisticMentorOverviewRESP {
  approvedMentor: number;
  pendingMentor: number;
}

export class StatisticCourseOverviewRESP {
  approvedCourse: number;
  pendingCourse: number;
  suspendedCourse: number;
}

export class StatisticReportOverviewRESP {
  pendingReport: number;
  resolvedReport: number;
}

export class StatisticSubscriptionOverviewRESP {
  activeSubscription: number;
  pendingSubscription: number;
  expiredSubscription: number;
  cancelledSubscription: number;
}

export class StatisticRevenueOverviewRESP {
  totalRevenue: number;
  refundAmount: number;
}

export class StatisticStudentOverviewRESP {
  activeStudent: number;
  suspendedStudent: number;
}

export class StatisticOverviewListRESP {
  mentorOverview: StatisticMentorOverviewRESP;
  courseOverview: StatisticCourseOverviewRESP;
  reportOverview: StatisticReportOverviewRESP;
  subscriptionOverview: StatisticSubscriptionOverviewRESP;
  revenueOverview: StatisticRevenueOverviewRESP;
  studentOverview: StatisticStudentOverviewRESP;
}

export class StatisticOverviewClientListRESP {
  courseOverview: StatisticCourseOverviewRESP;
  subscriptionOverview: StatisticSubscriptionOverviewRESP;
  revenueOverview: StatisticRevenueOverviewRESP;
}
</file>

<file path="src/domains/dashboard/response/statistic-payment-list.response.ts">
export class StatisticPaymentListRESP {
  totalAmount: number;
  noOfPayments: number;
}
</file>

<file path="src/domains/dashboard/shared/types.ts">
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';

export type StatisticSubscriptionListRESP = Omit<
  SubscriptionListRESP,
  'audiCall' | 'feedback' | 'report' | 'canceledAt' | 'approvedAt' | 'rejectedAt'
>;

export type CourseTopRates = {
  courseId: number;
  courseName: string;
  avgRate?: number;
  noOfSubscription?: number;
};

export enum TopCourseType {
  TOP_RATE = 'TOP_RATE',
  TOP_NUMBER_OF_SUBSCRIPTION = 'TOP_NUMBER_OF_SUBSCRIPTION',
}
</file>

<file path="src/domains/dashboard/dashboard.controller.ts">
import { Controller } from '@nestjs/common';
import { DashboardService } from './dashboard.service';

@Controller('dashboard')
export class DashboardController {
  constructor(private readonly dashboardService: DashboardService) {}
}
</file>

<file path="src/domains/dashboard/dashboard.module.ts">
import { Module } from '@nestjs/common';
import { DashboardAdminModule } from './admin/dashboard-admin.module';
import { DashboardClientModule } from './client/dashboard-client.module';
import { DashboardController } from './dashboard.controller';
import { DashboardService } from './dashboard.service';

@Module({
  controllers: [DashboardController],
  providers: [DashboardService],
  imports: [DashboardAdminModule, DashboardClientModule],
})
export class DashboardModule {}
</file>

<file path="src/domains/dashboard/dashboard.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class DashboardService {}
</file>

<file path="src/domains/feedback/admin/feedback-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackAdminController } from './feedback-admin.controller';
import { FeedbackAdminService } from './feedback-admin.service';

describe('FeedbackAdminController', () => {
  let controller: FeedbackAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FeedbackAdminController],
      providers: [FeedbackAdminService],
    }).compile();

    controller = module.get<FeedbackAdminController>(FeedbackAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/admin/feedback-admin.controller.ts">
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackAdminService } from './feedback-admin.service';

@Controller('admin/feedbacks')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class FeedbackAdminController {
  constructor(private readonly feedbackAdminService: FeedbackAdminService) {}

  @Get('relations')
  async listFeedbackByRelationId(@Query() query: FeedbackListREQ) {
    const data = await this.feedbackAdminService.listByRelation(query);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }
}
</file>

<file path="src/domains/feedback/admin/feedback-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { FeedbackAdminController } from './feedback-admin.controller';
import { FeedbackAdminService } from './feedback-admin.service';

@Module({
  imports: [AccountModule],
  controllers: [FeedbackAdminController],
  providers: [FeedbackAdminService],
})
export class FeedbackAdminModule {}
</file>

<file path="src/domains/feedback/admin/feedback-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackAdminService } from './feedback-admin.service';

describe('FeedbackAdminService', () => {
  let service: FeedbackAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FeedbackAdminService],
    }).compile();

    service = module.get<FeedbackAdminService>(FeedbackAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/admin/feedback-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { FeedbackListHelper } from '../helper/feedback-list.helper';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackGetPayload } from '../shared/type';

@Injectable()
export class FeedbackAdminService {
  private readonly logger: Logger = new Logger(FeedbackAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountSevice: AccountService,
  ) {}

  async listByRelation(query: FeedbackListREQ) {
    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.toFindMany(query));
    const count = await this.transactionHost.tx.feedback.count({ where: FeedbackListHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  async listAllFeedback(query) {}
}
</file>

<file path="src/domains/feedback/client/feedback-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackClientController } from './feedback-client.controller';
import { FeedbackClientService } from './feedback-client.service';

describe('FeedbackClientController', () => {
  let controller: FeedbackClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FeedbackClientController],
      providers: [FeedbackClientService],
    }).compile();

    controller = module.get<FeedbackClientController>(FeedbackClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/client/feedback-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Post, Put, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { FeedbackCreateREQ } from '../request/feedback-create.request';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';
import { FeedbackClientService } from './feedback-client.service';

@Controller('client/feedbacks')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class FeedbackClientController {
  constructor(private readonly feedbackClientService: FeedbackClientService) {}

  @Get()
  @Public()
  async listFeedback(@Query() query: FeedbackListREQ) {
    const data = await this.feedbackClientService.list(query);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }

  @Post()
  @Roles(AccountType.STUDENT)
  async createFeedback(@Req() req: AuthRequestDTO, @Body() body: FeedbackCreateREQ) {
    const feedback = await this.feedbackClientService.create(req.user.accountId, body);

    return BaseResponse.of(feedback);
  }

  @Put(':id')
  @Roles(AccountType.STUDENT)
  async updateFeedback(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number, @Body() body: FeedbackUpdateREQ) {
    const feedback = await this.feedbackClientService.update(req.user.accountId, id, body);

    return BaseResponse.of(feedback);
  }

  @Delete(':id')
  @Roles(AccountType.STUDENT)
  async delete(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.feedbackClientService.delete(req.user.accountId, id);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/domains/feedback/client/feedback-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { FeedbackClientController } from './feedback-client.controller';
import { FeedbackClientService } from './feedback-client.service';

@Module({
  imports: [AccountModule],
  controllers: [FeedbackClientController],
  providers: [FeedbackClientService],
  exports: [FeedbackClientService],
})
export class FeedbackClientModule {}
</file>

<file path="src/domains/feedback/client/feedback-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackClientService } from './feedback-client.service';

describe('FeedbackClientService', () => {
  let service: FeedbackClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FeedbackClientService],
    }).compile();

    service = module.get<FeedbackClientService>(FeedbackClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/client/feedback-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { FeedbackCreateHelper } from '../helper/feedback-create.helper';
import { FeedbackListHelper } from '../helper/feedback-list.helper';
import { FeedbackUpdateHelper } from '../helper/feedback-update.helper';
import { FeedbackCreateREQ } from '../request/feedback-create.request';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';
import { FeedbackGetPayload } from '../shared/type';

@Injectable()
export class FeedbackClientService {
  private readonly logger: Logger = new Logger(FeedbackClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountSevice: AccountService,
  ) {}

  async list(query: FeedbackListREQ) {
    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.toFindMany(query));
    const count = await this.transactionHost.tx.feedback.count({ where: FeedbackListHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  async listFeedbackByMentorId(mentorId: number) {
    const mentor = await this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { id: mentorId },
      select: { accountId: true },
    });

    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.findManyByAccountId(mentor.accountId));
    const count = await this.transactionHost.tx.feedback.count({
      where: { Subscription: { Course: { Creator: { id: mentor.accountId } } } },
    });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(reviewerId: number, body: FeedbackCreateREQ) {
    const feedback = await this.findBySubscriptionId(body.subscriptionId);
    if (feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_ALREADY_EXISTS);

    const subscription = await this.transactionHost.tx.subscription.findUnique({
      where: { id: body.subscriptionId },
      select: { accountId: true },
    });

    if (!subscription && subscription.accountId !== reviewerId)
      throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_ENOUGH_PERMISSION);

    // Ensure the student is subscribed to the course or mentor
    return this.transactionHost.tx.feedback.create(FeedbackCreateHelper.toCreate(reviewerId, body));
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(reviewerId: number, feedbackId: number, body: FeedbackUpdateREQ) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, reviewerId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);

    if (feedback.reviewerId !== reviewerId) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);

    return this.transactionHost.tx.feedback.update(FeedbackUpdateHelper.toUpdate(feedback.id, body));
  }

  async findBySubscriptionId(subscriptionId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { subscriptionId },
      select: { id: true, reviewerId: true },
    });

    return feedback;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async delete(reviewerId: number, feedbackId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, reviewerId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);

    if (feedback.reviewerId !== reviewerId) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);

    return this.transactionHost.tx.feedback.delete({ where: { id: feedbackId } });
  }

  async requestReviewModeration(feedbackId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, subscriptionId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-create.helper.ts">
import { Prisma } from '@prisma/client';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { FeedbackCreateREQ } from '../request/feedback-create.request';

export class FeedbackCreateHelper {
  static toCreate(reviewerId: number, body: FeedbackCreateREQ): Prisma.FeedbackCreateArgs {
    return {
      data: {
        courseRating: body.courseRating,
        mentorRating: body.mentorRating,
        courseReview: body.courseReview,
        mentorReview: body.mentorReview,
        Reviewer: connectRelation(reviewerId),
        Subscription: connectRelation(body.subscriptionId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-list.helper.ts">
import { Prisma } from '@prisma/client';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackListRESP } from '../response/feedback-list.response';
import { FeedbackGetPayload, FeedbackRelation, ReviewerAccount } from '../shared/type';

export class FeedbackListHelper {
  static toQueryCondition(query: FeedbackListREQ): Prisma.FeedbackFindManyArgs['where'] {
    const relation =
      query.relationType === FeedbackRelation.COURSE
        ? {
            Subscription: {
              courseId: query.relationId,
            },
          }
        : {
            Subscription: {
              Course: { Creator: { Mentors: { some: { id: query.relationId } } } },
            },
          };

    return { ...relation };
  }

  static toFindMany(query: FeedbackListREQ): Prisma.FeedbackFindManyArgs {
    const condition = FeedbackListHelper.toQueryCondition(query);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        reviewerId: true,
        courseRating: true,
        mentorRating: true,
        courseReview: true,
        mentorReview: true,
        subscriptionId: true,
        Report: { select: { id: true, type: true, description: true, status: true, resolution: true } },
        updatedAt: true,
      },
    };
  }

  static findManyByAccountId(accountId: number): Prisma.FeedbackFindManyArgs {
    return {
      where: {
        Subscription: { Course: { Creator: { id: accountId } } },
      },

      select: {
        id: true,
        reviewerId: true,
        courseRating: true,
        mentorRating: true,
        courseReview: true,
        mentorReview: true,
        subscriptionId: true,
        updatedAt: true,
      },
    };
  }

  static fromEntity(e: FeedbackGetPayload, account: ReviewerAccount): FeedbackListRESP {
    return {
      id: e.id,
      subscriptionId: e.subscriptionId,
      courseRating: e.courseRating,
      mentorRating: e.mentorRating,
      courseReview: e.courseReview,
      mentorReview: e.mentorReview,
      reviewer: account,
      updatedAt: parseEpoch(e.updatedAt),
      report: orNullWithCondition(!!e.Report, {
        id: e.Report?.id,
        type: e.Report?.type,
        description: e.Report?.description,
        status: e.Report?.status,
        resolution: e.Report?.resolution,
      }),
    };
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-update.helper.ts">
import { Prisma } from '@prisma/client';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';

export class FeedbackUpdateHelper {
  static toUpdate(feedbackId: number, body: FeedbackUpdateREQ): Prisma.FeedbackUpdateArgs {
    return {
      where: { id: feedbackId },
      data: {
        courseRating: body.courseRating,
        mentorRating: body.mentorRating,
        courseReview: body.courseReview,
        mentorReview: body.mentorReview,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/feedback/request/feedback-create.request.ts">
import { IsNumber, IsOptional, IsString, Max, Min } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class FeedbackCreateREQ {
  @Min(1)
  @Max(5)
  @IsNumber()
  mentorRating: number;

  @IsNumber()
  @Min(1)
  @Max(5)
  courseRating: number;

  @IdValidator()
  subscriptionId: number;

  @IsString()
  @IsOptional()
  courseReview?: string;

  @IsString()
  @IsOptional()
  mentorReview?: string;
}
</file>

<file path="src/domains/feedback/request/feedback-list.request.ts">
import { Transform } from 'class-transformer';
import { IsEnum } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { FeedbackRelation } from '../shared/type';

export class FeedbackListREQ extends PaginationREQ {
  @IdValidator()
  @Transform(({ value }) => value && parseInt(value))
  relationId: number;

  @IsEnum(FeedbackRelation)
  relationType: FeedbackRelation;
}
</file>

<file path="src/domains/feedback/request/feedback-update.request.ts">
import { PartialType, PickType } from '@nestjs/swagger';
import { FeedbackCreateREQ } from './feedback-create.request';

export class FeedbackUpdateREQ extends PartialType(
  PickType(FeedbackCreateREQ, ['courseRating', 'mentorRating', 'courseReview', 'mentorReview']),
) {}
</file>

<file path="src/domains/feedback/response/feedback-list.response.ts">
import { FeedbackReportRESP, ReviewerAccount } from '../shared/type';

export class FeedbackListRESP {
  id: number;
  courseRating: number;
  mentorRating: number;
  courseReview: string;
  mentorReview: string;
  subscriptionId: number;
  updatedAt: string;
  reviewer: ReviewerAccount;
  report?: FeedbackReportRESP;
}
</file>

<file path="src/domains/feedback/shared/type.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { ReportDetailRESP } from 'src/domains/report/response/report-detail.response';

export type ReviewerAccount = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;

export type FeedbackGetPayload = Prisma.FeedbackGetPayload<{
  include: { Subscription: true; Reviewer: true; Report: true };
}>;

export enum FeedbackRelation {
  COURSE = 'COURSE',
  MENTOR = 'MENTOR',
}

export type FeedbackReportRESP = Pick<ReportDetailRESP, 'id' | 'type' | 'description' | 'status' | 'resolution'>;
</file>

<file path="src/domains/feedback/feedback.module.ts">
import { Module } from '@nestjs/common';
import { FeedbackAdminModule } from './admin/feedback-admin.module';
import { FeedbackClientModule } from './client/feedback-client.module';

@Module({
  imports: [FeedbackClientModule, FeedbackAdminModule],
})
export class FeedbackModule {}
</file>

<file path="src/domains/file/dto/file-link.dto.ts">
import { Prisma } from '@prisma/client';

export class FileLinkDTO {
  static fileSelect(): Prisma.FileSelect {
    return {
      ImageVersions: { select: { id: true } },
      Categories: { select: { id: true } },
      CourseImages: { select: { id: true } },
      SectionAttachments: { select: { fileId: true } },
    };
  }

  static isLinked(
    e: Prisma.FileGetPayload<{
      include: { ImageVersions: true; Categories: true; AccountAvatars: true; CourseImages: true; SectionAttachments: true };
    }>,
  ) {
    return (
      e.ImageVersions?.length > 0 ||
      e.Categories?.length > 0 ||
      e.AccountAvatars?.length > 0 ||
      e.CourseImages?.length > 0 ||
      e.SectionAttachments?.length > 0
    );
  }
}
</file>

<file path="src/domains/file/request/file-create.request.ts">
import { Prisma } from '@prisma/client';
import { IsNumber, IsOptional } from 'class-validator';
import { UploadApiResponse } from 'cloudinary';
import { SharpOptions } from 'sharp';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ISharpInputOptions } from 'src/services/storage/shared/interfaces/sharp.interface';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class FileCreateREQ implements ISharpInputOptions {
  @IsNumber()
  @IsOptional()
  width?: number;

  @IsNumber()
  @IsOptional()
  height?: number;

  @IsOptional()
  options?: SharpOptions;

  static toSharpOptions(body: FileCreateREQ): ISharpInputOptions {
    return {
      width: body.width,
      height: body.height,
      options: body.options,
    };
  }

  static fromCLDApiResponse(user: AuthUserDTO, body: UploadApiResponse): Prisma.FileCreateInput {
    return {
      publicId: body.public_id,
      size: body.bytes,
      url: body.secure_url,
      version: body.version,
      resourceType: body.resource_type,
      signature: body.signature,
      uploadedAt: new Date(body.created_at).getMilliseconds(),
      Registrant: connectRelation(user?.accountId),
    };
  }
}
</file>

<file path="src/domains/file/request/file-upload-signed-url.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { ResourceType } from 'cloudinary';
import { CLD_FOLDER } from 'src/shared/constants/storage.constant';
import { NameValidator } from 'src/shared/request-validator/account.validator';

export class FileUploadSignedUrlREQ {
  @NameValidator()
  fileName: string;

  @IsString()
  resourceType: ResourceType;

  @IsEnum(CLD_FOLDER)
  folder: CLD_FOLDER;

  @IsString()
  @IsOptional()
  imageType?: string;

  @IsOptional()
  eager?: string;

  static fromSignedUrl(body: FileUploadSignedUrlREQ, result: any): Prisma.FileCreateInput {
    return {
      filename: body.fileName,
      publicId: result.publicId,
      url: result.url,
      resourceType: body.resourceType,
      signature: result.signature,
      uploadedAt: new Date().getTime(),
    };
  }
}
</file>

<file path="src/domains/file/response/file-create.response.ts">
import { Prisma } from '@prisma/client';

export class FileCreateRESP {
  fileId: number;
  url: string;

  static fromEntity(e: Prisma.FileGetPayload<unknown>, url: string): FileCreateRESP {
    return { fileId: e.id, url };
  }
}
</file>

<file path="src/domains/file/response/file.response.ts">
import { Prisma } from '@prisma/client';
import { StorageDTO } from 'src/services/storage/dto/storage.dto';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNull } from 'src/shared/parsers/io.parser';

export class FileRESP {
  fileId: number;
  fileName: string;
  fileSize: number | null;
  url: string;
  createdAt: number;
  registrant: { id: number; email: string };

  static querySelect(): Prisma.FileSelect {
    return {
      id: true,
      publicId: true,
      size: true,
      createdAt: true,
      Registrant: { select: { id: true, email: true } },
    };
  }

  static fromEntity(e: Prisma.FileGetPayload<{ include: { Registrant: true } }>, storage: StorageDTO): FileRESP {
    return {
      fileId: e.id,
      fileName: e.filename,
      fileSize: orNull(storage?.size),
      url: orNull(storage?.url),
      createdAt: parseEpoch(e.createdAt),
      registrant: { id: e.Registrant?.id, email: e.Registrant?.email },
    };
  }
}
</file>

<file path="src/domains/file/file.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FileController } from './file.controller';
import { FileService } from './file.service';

describe('FileController', () => {
  let controller: FileController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FileController],
      providers: [FileService],
    }).compile();

    controller = module.get<FileController>(FileController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/file/file.controller.ts">
import { Body, Controller, Post, Req, UploadedFile, UseGuards, UseInterceptors } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { Public } from '../auth/auth-public.decorator';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { FileService } from './file.service';
import { FileUploadSignedUrlREQ } from './request/file-upload-signed-url.request';

@Controller('files')
@UseGuards(AuthJwtGuard)
export class FileController {
  constructor(private readonly fileService: FileService) {}

  @Post()
  @Public()
  @UseInterceptors(FileInterceptor('file'))
  async upload(@Req() req: AuthRequestDTO, @UploadedFile() file: Express.Multer.File) {
    const asset = await this.fileService.uploadFile(req.user, file, req.body);

    return BaseResponse.of(asset);
  }

  @Public()
  @Post('signed-url')
  async createSignedUrl(@Body() body: FileUploadSignedUrlREQ) {
    const response = await this.fileService.createSignedFile(body);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/file/file.module.ts">
import { Global, Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { FileController } from './file.controller';
import { FileService } from './file.service';

@Global()
@Module({
  imports: [CommonModule],
  controllers: [FileController],
  providers: [FileService],
  exports: [FileService],
})
export class FileModule {}
</file>

<file path="src/domains/file/file.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FileService } from './file.service';

describe('FileService', () => {
  let service: FileService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FileService],
    }).compile();

    service = module.get<FileService>(FileService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/file/file.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { isEmpty, isNil } from 'lodash';
import { NODE_ENV } from 'src/app.config';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { StorageService } from 'src/services/storage/storage.service';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { CLD_UPLOAD_IMAGE_OPTIONS, IMAGE_TYPE } from 'src/shared/constants/storage.constant';
import { AssetFileNotExisted } from 'src/shared/exceptions/asset-file-not-existed.exception';
import { WriteFailedException } from 'src/shared/exceptions/write-fail-exception';
import { WriteRelationNotFoundException } from 'src/shared/exceptions/write-relation-not-found.exception';
import { Nil } from 'src/shared/generics/type.helper';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FileLinkDTO } from './dto/file-link.dto';
import { FileCreateREQ } from './request/file-create.request';
import { FileUploadSignedUrlREQ } from './request/file-upload-signed-url.request';
import { FileRESP } from './response/file.response';

@Injectable()
export class FileService {
  private readonly logger = new Logger(FileService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly storageService: StorageService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async uploadFile(user: AuthUserDTO, file: Express.Multer.File, body: FileCreateREQ) {
    try {
      const result = await this.storageService.uploadFile(file, CLD_UPLOAD_IMAGE_OPTIONS, FileCreateREQ.toSharpOptions(body));

      const asset = await this.transactionHost.tx.file.create({
        data: FileCreateREQ.fromCLDApiResponse(user, result as any),
        select: { id: true, url: true },
      });

      return asset;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Failed to upload file');
    }
  }

  @Transactional()
  async createSignedFile(body: FileUploadSignedUrlREQ) {
    const imageType = body.imageType ?? IMAGE_TYPE;
    const publicId = `${body.folder}/${body.fileName}_${new Date().getTime().toString().substring(6)}`;
    const result = await this.storageService.createSignedUploadUrl(publicId, imageType, {
      folder: body.folder,
      eager: body.eager,
    });

    const file = await this.transactionHost.tx.file.create({
      data: FileUploadSignedUrlREQ.fromSignedUrl(body, result as any),
      select: { id: true, url: true },
    });

    const uploadedUrl = `${result.url}?api_key=${result.api_key}&public_id=${publicId}&timestamp=${result.timestamp}&signature=${result.signature}`;

    const resposne = { fileId: file.id, uploadedUrl };

    return resposne;
  }

  async checkFileUploaded(fileId: Nil<number>) {
    if (isNil(fileId)) return;
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id: fileId },
      select: { id: true, publicId: true },
    });
    return this.storageService.checkFileExist(file.publicId);
  }

  async detail(id: Nil<number>) {
    if (isNil(id)) return null;
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id },
      select: FileRESP.querySelect(),
    });
    return FileRESP.fromEntity(file as any, await this.storageService.getStorageFile(file.publicId));
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async enableUploaded(fileIds: number[]) {
    await this.transactionHost.tx.file.updateMany({ where: { id: { in: fileIds } }, data: { isUploaded: true } });
  }

  /* Delete file */
  async delete(id: number) {
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({ where: { id }, select: { publicId: true } });
    await this.transactionHost.tx.$executeRaw`DELETE FROM files WHERE id = ${id}`;
    await this.storageService.deleteFile(file.publicId);
  }

  /* Delete multi files */
  @Transactional(TRANSACTION_TIMEOUT)
  async deleteMany(fileIds: number[]) {
    if (fileIds.length === 0) return;
    const files = await this.transactionHost.tx.file.findMany({
      where: { id: { in: fileIds } },
      select: { id: true, publicId: true },
    });

    await this.storageService.deleteManyFiles(files.map((f) => f.publicId));
    await this.transactionHost.tx.$executeRaw`DELETE FROM files WHERE id IN (${Prisma.join(fileIds)})`;
  }

  async checkFileLinked(fileIds: number[]) {
    const linkedFiles = await this.transactionHost.tx.file.findMany({
      where: { id: { in: fileIds } },
      select: FileLinkDTO.fileSelect(),
    });
    if (linkedFiles.filter((f) => FileLinkDTO.isLinked(f)).length !== 0)
      throw new WriteFailedException('update', 'These specified files had been linked already');
  }

  async checkAttachmentUploadedOrThrow(fileIds: number[]) {
    if (!fileIds || isEmpty(fileIds)) return;
    try {
      const fileUploadStatus = await this.checkManyFileUploaded(fileIds);
      //TODO: Fix rate limit
      const isAttachment = fileIds.length !== 0;
      if (isAttachment && !fileUploadStatus.isAllUploaded && NODE_ENV === 'production')
        throw new AssetFileNotExisted(fileUploadStatus.notUploadedFileIds);
    } catch (e) {
      if (e instanceof PrismaClientKnownRequestError)
        throw new WriteRelationNotFoundException('create', 'File', `File(s) not found id = ${fileIds.join(', ')}`);
      throw e;
    }
  }

  async checkManyFileUploaded(fileIds: number[]): Promise<{ isAllUploaded: boolean; notUploadedFileIds: number[] }> {
    type FileStatus = { isUploaded: boolean; id: number };
    const promises = fileIds.map(
      (id) =>
        new Promise<FileStatus>(async (res, rej) => {
          try {
            const isUploaded = await this.checkFileUploaded(id);
            res({ isUploaded, id });
          } catch (e) {
            // File not exist in database
            rej(e);
          }
        }),
    );

    const fileStatuses = await Promise.all(promises);
    const notUploadedFiles = fileStatuses.filter((f) => !f.isUploaded);
    return { isAllUploaded: notUploadedFiles.length <= 0, notUploadedFileIds: notUploadedFiles.map((f) => f.id) };
  }
}
</file>

<file path="src/domains/image/response/image-version.response.ts">
import { ImageVersionType, Prisma } from '@prisma/client';
import { StorageDTO } from 'src/services/storage/dto/storage.dto';

export class ImageVersionRESP {
  id: number;
  url: string;
  fileId: number;
  fileSize: number | null;
  width: number;
  height: number;
  type: ImageVersionType;

  static getResolution(type: ImageVersionType): { width: number; height: number } {
    switch (type) {
      case 'THUMBNAIL':
        return { width: 200, height: 200 };
      case 'MEDIUM':
        return { width: 1280, height: 720 };
      case 'LARGE':
        return { width: 1920, height: 1080 };
    }
  }

  static fromEntity(e: Prisma.ImageVersionGetPayload<{ include: { File: true } }>, storage: StorageDTO): ImageVersionRESP {
    const resolution = ImageVersionRESP.getResolution(e.type);
    return {
      id: e.id,
      url: storage.url,
      fileId: e.File.id,
      fileSize: storage.size,
      width: resolution.width,
      height: resolution.height,
      type: e.type,
    };
  }

  static mock(imageUrl: string): ImageVersionRESP[] {
    const banner = ImageVersionRESP.getResolution(ImageVersionType.LARGE);
    const thumbnail = ImageVersionRESP.getResolution(ImageVersionType.THUMBNAIL);
    return [
      {
        id: 1,
        url: imageUrl,
        fileId: 1,
        fileSize: 1000,
        width: banner.width,
        height: banner.height,
        type: ImageVersionType.LARGE,
      },
      {
        id: 2,
        url: imageUrl,
        fileId: 2,
        fileSize: 2000,
        width: thumbnail.width,
        height: thumbnail.height,
        type: ImageVersionType.THUMBNAIL,
      },
    ];
  }
}
</file>

<file path="src/domains/image/response/image.response.ts">
import { Prisma } from '@prisma/client';

import { StorageDTO } from 'src/services/storage/dto/storage.dto';
import { ImageVersionRESP } from './image-version.response';

export class ImageRESP {
  fileName: string;
  fileId: number;
  fileSize: number | null;
  originalUrl: string;
  versions: ImageVersionRESP[];

  static fromEntity(e: Prisma.FileGetPayload<unknown>, storage: StorageDTO, versions: ImageVersionRESP[]): ImageRESP {
    return {
      fileId: e.id,
      fileName: e.filename,
      fileSize: storage.size,
      originalUrl: storage.url,
      versions,
    };
  }
}
</file>

<file path="src/domains/image/image.controller.ts">
import { Controller } from '@nestjs/common';
import { ImageService } from './image.service';

@Controller('/images')
export class ImageController {
  constructor(private readonly imageService: ImageService) {}

  // @Get()
  // async list(@Query() query: CategoryListREQ) {
  //   return await this.categoryService.list(query);
  // }

  // @Get(':id')
  // async detail(@Param('id', ParseIntPipe) id: number) {
  //   return this.categoryService.detail(id);
  // }
}
</file>

<file path="src/domains/image/image.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaModule } from 'src/services/prisma/prisma.module';
import { FileModule } from '../file/file.module';
import { ImageController } from './image.controller';
import { ImageService } from './image.service';

@Module({
  imports: [FileModule, PrismaModule],
  controllers: [ImageController],
  providers: [ImageService],
  exports: [ImageService],
})
@Global()
export class ImageModule {}
</file>

<file path="src/domains/image/image.service.ts">
import { Injectable } from '@nestjs/common';

import { Prisma } from '@prisma/client';
import { isNil, isNull } from 'lodash';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { StorageService } from 'src/services/storage/storage.service';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { Nil } from 'src/shared/generics/type.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { FileService } from '../file/file.service';
import { ImageVersionRESP } from './response/image-version.response';
import { ImageRESP } from './response/image.response';

@Injectable()
export class ImageService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly fileService: FileService,
    private readonly storageService: StorageService,
  ) {}

  /* Quy trình upload ảnh
    1. Tạo entity (validate xong tất cả)
    1. Tạo ảnh (gồm kiểm tra attachment đã upload & file đã link)
    2. Tạo các phiên bản ảnh tối ưu
    3. Link ảnh với entity
    4. Enable ảnh
  */

  async verifyImages(fileIds: number[]) {
    await this.fileService.checkAttachmentUploadedOrThrow(fileIds);
    // await this.fileService.checkFileLinked(fileIds);
  }

  // @Transactional(TRANSACTION_TIMEOUT)
  // async createImages(fileIds: number[]) {
  //   /* 1. Create image */
  //   const createdImageIds = [];
  //   for (const fileId of fileIds) {
  //     const image = await this.transactionHost.tx.file.create({
  //       data: ImageCreateDTO.toCreateInput(fileId),
  //       select: { id: true },
  //     });
  //     createdImageIds.push(image.id);
  //   }

  //   /* 2. Create optimized image versions */
  //   return createdImageIds;
  // }

  async getImage(imageId: Nil<number>) {
    if (isNil(imageId)) return null;
    const image = await this.transactionHost.tx.file.findUnique({
      where: { id: imageId },
      include: { ImageVersions: { include: { File: true } } },
    });
    // const versions = await Promise.all(
    //   image.ImageVersions.map(async (v) => ImageVersionRESP.fromEntity(v, await this.storageService.getStorageFile(v.File.key))),
    // );
    const storage = await this.storageService.getStorageFile(image.publicId);
    const versions = ImageVersionRESP.mock(storage.url); // Mock
    return ImageRESP.fromEntity(image, storage, versions);
  }

  async getImageOriginal(imageId: Nil<number>): Promise<ImageRESP | null> {
    if (isNil(imageId)) return null;
    const image = await this.transactionHost.tx.file.findUnique({
      where: { id: imageId },
      include: { ImageVersions: { include: { File: true } } },
    });
    const storage = await this.storageService.getStorageFile(image.publicId);
    //TODO: Handle null storage
    return isNull(storage) ? null : ImageRESP.fromEntity(image, storage, []);
  }

  async enableImages(imageIds: number[]) {
    const images = await this.transactionHost.tx.file.findMany({
      where: { id: { in: imageIds } },
      select: { id: true, ImageVersions: { select: { id: true, fileId: true } } },
    });
    if (images.length !== imageIds.length)
      throw new ActionFailedException(
        ActionFailed.IMAGE_ENABLE_QUANTITY_NOT_MATCH,
        `Image quantity not match ${imageIds.length}/${images.length}`,
      );
    const fileIds = [];
    images.forEach((image) => {
      fileIds.push(image.id, ...image.ImageVersions.map((v) => v.fileId));
    });
    await this.fileService.enableUploaded(fileIds);
  }

  async deleteImage(imageId: number) {
    const image = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id: imageId },
      include: { ImageVersions: true },
    });
    const fileIds = [image.id, ...image.ImageVersions.map((v) => v.fileId)];

    await this.transactionHost.tx.$executeRaw`DELETE FROM image_versions WHERE file_id IN (${Prisma.join(fileIds)})`;
    await this.fileService.deleteMany(fileIds);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkImageToAccount(accountId: number, fileId: number) {
    console.log('🚀 ~ ImageService ~ linkImageToAccount ~ accountId:', accountId);
    if (!fileId) return;
    /* 1. Check if attachment uploaded & create image */
    // await this.verifyImages([fileId]);

    /* 2. Remove old image */
    const account = await this.transactionHost.tx.account.findUniqueOrThrow({
      where: { id: accountId },
      select: { Avatar: { select: { id: true } } },
    });

    if (account.Avatar) await this.deleteImage(account.Avatar.id);

    /* 3. Create and link image */
    await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { Avatar: connectRelation(fileId) },
    });

    /* 4. Enable Image & File */
    await this.enableImages([fileId]);
    return fileId;
  }

  async linkImageToCourse(courseId: number, fileId: number) {
    if (!courseId) throw new ActionFailedException(ActionFailed.COURSE_NOT_FOUND);
    if (!fileId) return;

    await this.verifyImages([fileId]);

    await this.transactionHost.tx.course.update({
      where: { id: courseId },
      data: { Image: connectRelation(fileId) },
    });

    /* 4. Enable Image & File */
    await this.enableImages([fileId]);
    return fileId;
  }
}
</file>

<file path="src/domains/mentor/admin/dto/mentor-admin-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorAdminDetailDTO {
  static toFindUnique(mentorId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        accpetedAt: true,
        createdAt: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            phoneNumber: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/dto/mentor-client-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorClientDetailDTO {
  static toFindByAccountId(accountId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { accountId: accountId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindFirst(mentorId: number): Prisma.MentorFindFirstOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        isCurrent: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-approve.request.ts">
import { MentorStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class MentorAdminApproveREQ {
  @BooleanValidator()
  isApproved: boolean;

  static toApprove(id: number, body: MentorAdminApproveREQ, user: AuthUserDTO): Prisma.MentorUpdateArgs {
    return {
      where: { id },
      data: {
        status: body.isApproved ? MentorStatus.ACCEPTED : MentorStatus.REJECTED,
        Acceptant: connectRelation(user.accountId),
        accpetedAt: nowEpoch(),
      },
      select: { id: true, accountId: true },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-interview.request.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { IsString } from 'class-validator';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';

export class MentorAdminInterviewREQ {
  @IsString()
  title: string;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  static toAudioRoomCreateREQ(mentorId: number, body: MentorAdminInterviewREQ): AudioCallAdminCreateREQ {
    return {
      title: body.title,
      type: AudioRoomType.INTERVIEW,
      startsAt: body.startsAt,
      status: RoomStatus.SCHEDULED,
      members: [
        {
          accountId: mentorId,
          role: 'USER',
        },
      ],
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-list.request.ts">
import { AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorAdminListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorAdminListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorAdminListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorAdminListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        status: true,
        accpetedAt: true,
        accountId: true,
        fileId: true,
        Account: { select: { name: true, email: true, phoneNumber: true, avatarId: true } },
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-client-list.request.ts">
import { AccountStatus, AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorClientListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorClientListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorClientListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorClientListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: { ...condition, Account: { status: { not: AccountStatus.SUSPENSIVE } } },
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        accountId: true,
        Account: { select: { name: true, avatarId: true, bio: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-detail.response.ts">
import { AchievementType } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          organization: e.organization,
          description: e.description,
          position: e.position,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: e.organization,
          description: e.description,
          major: e.major,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: e.name,
          organization: e.organization,
          description: e.description,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorAdminDetailRESP {
  id: number;
  accountId: number;
  status: string;
  gender: string;
  dob: string;
  accpetedAt: string;
  createdAt: string;
  name: string;
  email: string;
  phoneNumber: string;
  cv: FileRESP;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    cv: FileRESP,
    thumbnail?: ImageRESP,
  ): MentorAdminDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      status: e.status,
      gender: e.Account.gender,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      accpetedAt: parseEpoch(e.accpetedAt),
      createdAt: parseEpoch(e.createdAt),
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      cv: cv,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-interview.response.ts">
import { AudioRoomParticipantDTO } from 'src/domains/audio-call/admin/dto/participant-dto';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { parseEpoch } from 'src/shared/parsers/common.parser';

export class MentorAdminInterviewRESP {
  creatorId: number;
  cid: string;
  startsAt: string;
  members: AudioRoomParticipantDTO[];

  static fromEntity(e: AudioRoomGetPayload, cid: string): MentorAdminInterviewRESP {
    return {
      creatorId: e.creatorId,
      cid: cid,
      startsAt: parseEpoch(e.startsAt),
      members: e.Participants.map((m) => ({
        accountId: m.accountId,
        role: m.role,
      })),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-list.response.ts">
import { MentorStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { MentorGetPayload } from '../../shared/types';

export class MentorAdminListRESP {
  id: number;
  accountId: number;
  name: string;
  email: string;
  phoneNumber: string;
  registeredAt: string;
  status: MentorStatus;
  avatar?: ImageRESP;
  cv?: FileRESP;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumnail?: ImageRESP,
    cv?: FileRESP,
  ): MentorAdminListRESP {
    return {
      id: e.id,
      status: e.status,
      accountId: e.accountId,
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      registeredAt: parseEpoch(e.createdAt),
      avatar: thumnail,
      cv: cv,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-detail.response.ts">
import { AchievementType, MentorStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  id: number;
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  isCurrent: boolean;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          position: e.position,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          major: e.major,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          id: e.id,
          name: e.name,
          organization: e.organization,
          description: e.description,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorClientDetailRESP {
  id: number;
  accountId: number;
  bio?: string;
  name: string;
  gender: string;
  dob: string;
  status: MentorStatus;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    thumbnail?: ImageRESP,
  ): MentorClientDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      gender: e.Account.gender,
      status: e.status,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      bio: e.Account.bio,
      name: e.Account.name,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorGetPayload } from '../../shared/types';

export class MentorClientListRESP {
  id: number;
  accountId: number;
  name: string;
  thumbnail?: ImageRESP;
  bio?: string;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumbnail?: ImageRESP,
  ): MentorClientListRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      name: e.Account.name,
      bio: e.Account.bio,
      thumbnail,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminController', () => {
  let controller: MentorAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorAdminController],
      providers: [MentorAdminService],
    }).compile();

    controller = module.get<MentorAdminController>(MentorAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorAdminService } from './mentor-admin.service';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminDetailRESP } from './response/mentor-admin-detail.response';
import { MentorAdminInterviewRESP } from './response/mentor-admin-interview.response';

@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
@Controller('admin/mentors')
export class MentorAdminController {
  constructor(private readonly mentorAdminService: MentorAdminService) {}

  @Get()
  async list(@Query() query: MentorAdminListREQ) {
    const response = await this.mentorAdminService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorAdminService.detail(mentorId);

    return BaseResponse.of(
      MentorAdminDetailRESP.fromEntity(response.mentor, response.achievements, response.cv, response.thumbnail),
    );
  }

  @Post(':id/audio-call')
  async interviewMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminInterviewREQ,
  ) {
    const call = await this.mentorAdminService.interviewMentor(req.user, mentorId, body);

    return BaseResponse.of(MentorAdminInterviewRESP.fromEntity(call, call.cid));
  }

  @Patch(':id/approvement')
  async approveMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminApproveREQ,
  ) {
    const call = await this.mentorAdminService.updateResultInterview(req.user, mentorId, body);

    return BaseResponse.of(call.id);
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from 'src/domains/audio-call/admin/audio-call-admin.module';
import { CommonModule } from 'src/services/common.module';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

@Module({
  imports: [CommonModule, AudioCallAdminModule],
  controllers: [MentorAdminController],
  providers: [MentorAdminService],
})
export class MentorAdminModule {}
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminService', () => {
  let service: MentorAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorAdminService],
    }).compile();

    service = module.get<MentorAdminService>(MentorAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus, NotificationRelationType, NotificationType, RoomStatus } from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminService } from 'src/domains/audio-call/admin/audio-call-admin.service';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorGetPayload } from '../shared/types';
import { MentorAdminDetailDTO } from './dto/mentor-admin-detail.dto';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminListRESP } from './response/mentor-admin-list.response';

@Injectable()
export class MentorAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly audioCallAdminService: AudioCallAdminService,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  /* API: List mentor */
  async list(query: MentorAdminListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorAdminListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorAdminListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const cv = await this.fileService.detail(mentor.fileId);

        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorAdminListRESP.fromEntity(
          mentor,
          { noOfSubscriptions, rateOfMentor: rateOfMentor._avg.mentorRating },
          thumbnail,
          cv,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorAdminDetailDTO.toFindUnique(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorAdminDetailDTO.toFindManyAchievements(mentorId),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const cv = await this.fileService.detail(mentor.fileId);
    const data = { mentor, achievements, thumbnail, cv };

    return data;
  }

  /* API: Create interview with mentor */
  async interviewMentor(user: AuthUserDTO, mentorId: number, body: MentorAdminInterviewREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, accountId: true, status: true },
    });

    if (mentor.status == MentorStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.MENTOR_INTERVIEW_ACCEPTED);
    }

    const call = (await this.audioCallAdminService.createAudioCall(
      user,
      MentorAdminInterviewREQ.toAudioRoomCreateREQ(mentor.accountId, body),
    )) as AudioRoomGetPayload;

    //generate cid
    const cid = `${new Date().getTime()}-${call.id}-${randomUUID()}`;
    await this.transactionHost.tx.audioRoom.update({
      where: { id: call.id },
      data: { cid: cid },
      select: { id: true },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: call.id, type: NotificationRelationType.AUDIO_CALL },
      mentor.accountId,
      NotificationType.AUDIO_CALL_CREATED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return { cid: cid, ...call };
  }

  /* API: Approve or Reject Mentor after interview */
  @Transactional(TRANSACTION_TIMEOUT)
  async updateResultInterview(user: AuthUserDTO, id: number, body: MentorAdminApproveREQ) {
    //1. update mentor status
    const mentor = await this.transactionHost.tx.mentor.update(MentorAdminApproveREQ.toApprove(id, body, user));

    const onGoingInterview = await this.transactionHost.tx.audioRoom.findFirst({
      where: { status: RoomStatus.ONGOING, creatorId: user.accountId, Participants: { some: { accountId: mentor.accountId } } },
      select: { id: true },
    });

    if (onGoingInterview) {
      throw new ActionFailedException(ActionFailed.MENTOR_CANNOT_UPDATE_RESULT, MentorErrorMessages.MSG01);
    }

    //2. Deletes all scheduled interviews
    await this.transactionHost.tx.audioRoom.deleteMany({
      where: { status: RoomStatus.SCHEDULED, Participants: { some: { accountId: mentor.accountId } } },
    });

    await this.transactionHost.tx.audioRoomParticipant.updateMany({
      where: { accountId: mentor.accountId, AudioRoom: { creatorId: user.accountId } },
      data: { isInCall: false, isActive: false },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: mentor.id, type: NotificationRelationType.MENTOR },
      mentor.accountId,
      body.isApproved ? NotificationType.MENTOR_APPROVED : NotificationType.MENTOR_REJECTED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return mentor;
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-create.request.ts">
import { AuthMentorAchievementREQ } from 'src/domains/auth/request/auth-mentor-register.request';

export class MentorClientAchievementCreateREQ extends AuthMentorAchievementREQ {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-update.request.ts">
import { AchievementType } from '@prisma/client';
import { IsEnum, IsOptional, IsString, MaxLength, ValidateIf } from 'class-validator';
import { isUndefined } from 'lodash';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class MentorClientAchievementUpdateREQ {
  @IdValidator()
  id: number;

  @NameValidator()
  @ValidateIf((o) => o.achievementType === AchievementType.CERTIFICATION)
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  organization?: string; // Can be company or institution or certification body

  @BooleanValidator()
  @IsOptional()
  isCurrent?: boolean;

  @IsEnum(AchievementType)
  @IsOptional()
  achievementType?: AchievementType;

  @IsString()
  @MaxLength(255)
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EXPERIENCE)
  position: string; // For experience

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EDUCATION)
  major?: string; // For education

  @OnlyDate()
  startDate?: string;

  @OnlyDate()
  @DateMonthYearCompare({ startField: 'startDate' })
  @ValidateIf((o) => !isUndefined(o.isCurrent) && o.isCurrent == false)
  endDate?: string;

  static ToUpdateByAchievementType(body: MentorClientAchievementUpdateREQ) {
    switch (body.achievementType) {
      case AchievementType.EXPERIENCE:
        return {
          organization: body.organization,
          description: body.description,
          position: body.position,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: body.organization,
          description: body.description,
          major: body.major,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: body.name,
          organization: body.organization,
          description: body.description,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-course-list.request.ts">
import { PickType } from '@nestjs/swagger';
import { CourseClientListREQ } from 'src/domains/course/factory/list/course-client-list.request';

export class MentorClientCourseListREQ extends PickType(CourseClientListREQ, ['courseStatus']) {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-create.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleCreateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toCreate(id: number, body: MentorClientScheduleCreateREQ): Prisma.MentorScheduleCreateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        Mentor: connectRelation(id),
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-list.request.ts">
import { Prisma } from '@prisma/client';

export class MentorScheduleClientListREQ {
  static toFindMany(mentorId: number): Prisma.MentorScheduleFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        dayOfWeek: true,
        startTime: true,
        endTime: true,
        Course: { select: { id: true, name: true, description: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-update.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleUpdateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toUpdate(scheduleId: number, body: MentorClientScheduleUpdateREQ): Prisma.MentorScheduleUpdateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      where: { id: scheduleId },
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-update.request.ts">
import { AccountUpdateDTO } from 'src/domains/accounts/dto/account-update.dto';

export class MentorClientUpdateREQ extends AccountUpdateDTO {}
</file>

<file path="src/domains/mentor/client/response /mentor-schedule-list.response.ts">
import { Course } from '@prisma/client';
import { MentorScheduleCourseDetail, MentorScheduleGetPayload } from '../../shared/types';

export class MentorScheduleListRESP {
  dayOfWeek: string;
  timeRanges: { id: number; startTime: string; endTime: string; course: MentorScheduleCourseDetail }[] = [];

  static fromEntity(entities: MentorScheduleGetPayload[]): MentorScheduleListRESP[] {
    const response: MentorScheduleListRESP[] = [];

    entities.forEach((entity) => {
      const existed = response.find((item) => item.dayOfWeek === entity.dayOfWeek);
      const data = {
        id: entity.id,
        startTime: entity.startTime,
        endTime: entity.endTime,
        course: this.fromEntityWithCourse(entity.Course as Course),
      };

      if (existed) {
        existed.timeRanges.push(data);
      } else {
        response.push({ dayOfWeek: entity.dayOfWeek, timeRanges: [data] });
      }
    });

    return response;
  }

  static fromEntityWithCourse(course: Course): MentorScheduleCourseDetail {
    if (!course) return null;

    return {
      id: course.id,
      name: course.name,
      description: course.description,
    };
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientController', () => {
  let controller: MentorClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorClientController],
      providers: [MentorClientService],
    }).compile();

    controller = module.get<MentorClientController>(MentorClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Put, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { FeedbackClientService } from 'src/domains/feedback/client/feedback-client.service';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Controller('client/mentors')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR)
export class MentorClientController {
  constructor(
    private readonly mentorClientService: MentorClientService,
    private readonly mentorSchduleService: MentorScheduleService,
    private readonly feedbackClientService: FeedbackClientService,
  ) {}

  @Get()
  @Public()
  async list(@Query() query: MentorClientListREQ) {
    const response = await this.mentorClientService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get('profile')
  async profile(@Req() req: AuthRequestDTO) {
    const response = await this.mentorClientService.getMentorByAccountId(req.user.accountId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Post('schedules')
  async createSchedule(@Req() req: AuthRequestDTO, @Body() body: MentorClientScheduleCreateREQ) {
    await this.mentorSchduleService.createScheduleByAccountId(req.user, body);

    return BaseResponse.ok();
  }

  @Get('schedules') async getSchedule(@Req() req: AuthRequestDTO) {
    const response = await this.mentorSchduleService.getSchedulesByAccountId(req.user.accountId);

    return BaseResponse.of(response);
  }

  @Public()
  @Get(':id/schedules')
  async getScheduleByMentorId(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorSchduleService.getSchedulesByMentorId(mentorId);

    return BaseResponse.of(response);
  }

  @Get(':mentorId/feedbacks')
  async listFeedbackByMentorId(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const data = await this.feedbackClientService.listFeedbackByMentorId(mentorId);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }

  @Put('schedules/:id') async updateSchedule(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) scheduleId: number,
    @Body() body: MentorClientScheduleUpdateREQ,
  ) {
    await this.mentorSchduleService.updateMentorSchedule(req.user, scheduleId, body);

    return BaseResponse.ok();
  }

  @Delete('schedules/:id') async deleteSchedule(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) scheduleId: number) {
    await this.mentorSchduleService.deleteScheduleById(req.user.accountId, scheduleId);

    return BaseResponse.ok();
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorClientService.detail(mentorId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Roles(AccountType.MENTOR, AccountType.STUDENT)
  @Get(':id/courses')
  async getCoursesByMentorId(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Query() query: MentorClientCourseListREQ,
  ) {
    const response = await this.mentorClientService.getCoursesByMentorId(mentorId, req.user, query);

    return BaseResponse.of(response);
  }

  @Patch(':id')
  async update(@Param('id', ParseIntPipe) mentorId: number, @Req() req: AuthRequestDTO, @Body() body: MentorClientUpdateREQ) {
    const response = await this.mentorClientService.update(mentorId, req.user, body);

    return BaseResponse.of(response.id);
  }

  @Post(':id/achievements')
  async addProfileAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementCreateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.addProfileAchievement(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Patch(':id/achievements')
  async updateAchievements(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementUpdateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.updateAchievements(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Delete(':id/achievements/:achievementId')
  async deleteAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Param('achievementId', ParseIntPipe) achievementId: number,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.deleteAchievement(mentorId, achievementId, req.user);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { CourseClientModule } from 'src/domains/course/client/course-client.module';
import { FeedbackClientModule } from 'src/domains/feedback/client/feedback-client.module';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';

@Module({
  imports: [AccountModule, CourseClientModule, FeedbackClientModule],
  controllers: [MentorClientController],
  providers: [MentorClientService, MentorScheduleService],
  exports: [MentorClientService],
})
export class MentorClientModule {}
</file>

<file path="src/domains/mentor/client/mentor-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientService', () => {
  let service: MentorClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorClientService],
    }).compile();

    service = module.get<MentorClientService>(MentorClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus } from '@prisma/client';
import { AccountService } from 'src/domains/accounts/account.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { CourseClientService } from 'src/domains/course/client/course-client.service';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientListRESP } from 'src/domains/mentor/admin/response/mentor-client-list.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountErrorMessages, MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Injectable()
export class MentorClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
    private readonly imageService: ImageService,
    private readonly courseClientService: CourseClientService,
  ) {}

  /* API: List All Mentor */
  async list(query: MentorClientListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorClientListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorClientListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorClientListRESP.fromEntity(
          mentor,
          {
            noOfSubscriptions,
            rateOfMentor: rateOfMentor._avg.mentorRating,
          },
          thumbnail,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  /* API: Update Mentor */
  async update(mentorId: number, user: AuthUserDTO, body: MentorClientUpdateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    await this.accountService.updateAccount(user, body);

    return mentor;
  }

  /* API: Update achievements by mentor id */
  async updateAchievements(mentorId: number, body: MentorClientAchievementUpdateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.MENTOR_NOT_FOUND, MentorErrorMessages.MSG04);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(body.id)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement && currentAchievement.id !== body.id) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.update({
      where: { id: body.id },
      data: MentorClientAchievementUpdateREQ.ToUpdateByAchievementType(body),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Add achievements by mentor id */
  async addProfileAchievement(mentorId: number, body: MentorClientAchievementCreateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findUnique({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.create({
      data: MentorClientAchievementCreateREQ.ToCreateByAchievementType(body, mentorId),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Delete achievements by mentor id */
  async deleteAchievement(mentorId: number, achievementId: number, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_FOUND, AccountErrorMessages.MSG01);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(achievementId)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    await this.transactionHost.tx.profileAchievement.delete({ where: { id: achievementId } });

    return { mentorId: mentor.id, achievementId };
  }

  /* API: Mentor detail by mentor id */
  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindFirst(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getCoursesByMentorId(mentorId: number, user: AuthUserDTO, query: MentorClientCourseListREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, status: true, accountId: true },
    });

    console.log('🚀 ~ MentorClientService ~ getCoursesByMentorId ~ mentor:', mentor);

    const isOwner = mentor.accountId === user.accountId;

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    return await this.courseClientService.getAllbyCreatorId(mentor.accountId, isOwner, query as any);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-schedule.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { CourseStatus, MentorSchedule } from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { checkHourMinStartOverlap } from 'src/shared/helpers/common.helper';
import { MentorScheduleGetPayload } from '../shared/types';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorScheduleClientListREQ } from './request/mentor-client-schedule-list.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';

import { SUBSCRIPTION_ACTIVE_STATUS } from 'src/shared/constants/subscription.constant';
import { MentorScheduleListRESP } from './response /mentor-schedule-list.response';

@Injectable()
export class MentorScheduleService {
  private readonly logger = new Logger(MentorScheduleService.name);
  constructor(private readonly transactionHost: TransactionHost) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createScheduleByAccountId(user: AuthUserDTO, body: MentorClientScheduleCreateREQ): Promise<any> {
    const existedMentor = await this.findMentorByAccountId(user.accountId);

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true, status: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
          else if (course.status !== CourseStatus.APPROVED) throw new ActionFailedException(ActionFailed.COURSE_NOT_AVAILABLE);
        });
    }

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    await this.checkOverlapSchedule(existedMentor.id, body);

    const schedule = await this.transactionHost.tx.mentorSchedule.create(
      MentorClientScheduleCreateREQ.toCreate(existedMentor.id, body),
    );

    return schedule;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateMentorSchedule(
    user: AuthUserDTO,
    scheduleId: number,
    body: MentorClientScheduleUpdateREQ,
  ): Promise<MentorSchedule> {
    const existedSchedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: scheduleId, Mentor: { accountId: user.accountId } },
      select: { mentorId: true },
    });

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
        });
    }

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: user.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS }, mentorScheduleId: scheduleId },
      select: { id: true },
    });

    if (subscriptions.length > 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    const existedSchedulesExcludeCurrId = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: existedSchedule.mentorId, dayOfWeek: body.dayOfWeek, id: { not: scheduleId } },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedulesExcludeCurrId)) {
      const isOverlap = existedSchedulesExcludeCurrId.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }

    // Step 3: Update schedule
    const schedule = await this.transactionHost.tx.mentorSchedule.update(
      MentorClientScheduleUpdateREQ.toUpdate(scheduleId, body),
    );

    return schedule;
  }

  async getSchedulesByAccountId(accountId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.findMentorByAccountId(accountId);

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async getSchedulesByMentorId(mentorId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { id: mentorId },
      select: { id: true },
    });

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async deleteScheduleById(accountId: number, scheduleId: number): Promise<void> {
    const mentor = await this.findMentorByAccountId(accountId);

    const numberOfDeleted = await this.transactionHost.tx
      .$executeRaw`DELETE FROM "mentor_schedules" WHERE id = ${scheduleId} AND "mentor_id" = ${mentor.id}`;

    if (numberOfDeleted <= 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_NOT_FOUND);
  }

  private checkOneHourFromStartTime(startTime: string, endTime: string): boolean {
    const hour1 = Number(startTime.split(':')[0] ?? 0) + Number(startTime.split(':')[1] ?? 0) / 60;
    const hour2 = Number(endTime.split(':')[0] ?? 0) + Number(endTime.split(':')[1] ?? 0) / 60;

    return hour2 - hour1 >= 1;
  }

  private async findMentorByAccountId(accountId: number) {
    return this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { accountId },
      select: { id: true },
    });
  }

  private async checkOverlapSchedule(mentorId: number, body: MentorClientScheduleCreateREQ) {
    const existedSchedules = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: mentorId, dayOfWeek: body.dayOfWeek },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedules)) {
      const isOverlap = existedSchedules.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }
  }
}
</file>

<file path="src/domains/mentor/shared/enums.ts">
export enum MentorAdminListSortableFields {
  NAME = 'name',
  EMAIL = 'email',
  PHONE_NUMBER = 'phoneNumber',
  CREATED_AT = 'createdAt',
}
</file>

<file path="src/domains/mentor/shared/types.ts">
import { Prisma } from '@prisma/client';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';

export type MentorGetPayload = Prisma.MentorGetPayload<{
  include: {
    Account: true;
  };
}>;

export type MentorScheduleGetPayload = Prisma.MentorScheduleGetPayload<{
  include: {
    Course: true;
    Mentor: true;
  };
}>;

export type ProfileAchievementGetPayload = Prisma.ProfileAchievementGetPayload<unknown>;

export type MentorScheduleCourseDetail = Pick<CourseClientDetailRESP, 'id' | 'name' | 'description'>;
</file>

<file path="src/domains/mentor/mentor.module.ts">
import { Module } from '@nestjs/common';
import { MentorAdminModule } from './admin/mentor-admin.module';
import { MentorClientModule } from './client/mentor-client.module';

@Module({
  imports: [MentorClientModule, MentorAdminModule],
})
export class MentorModule {}
</file>

<file path="src/domains/notification/helper/notification-common.helper.ts">
import { NotificationRelationType, NotificationScope, NotificationType } from '@prisma/client';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { NotificationAppHandlerPayload } from '../shared/types';

type RelationData = {
  id: number;
  type: NotificationRelationType;
};

export class NotificationHelper {
  static makeAppNotificationPayload(
    relation: RelationData,
    targetAccountId: number,
    notificationType: NotificationType,
    scopes: NotificationScope[] = [NotificationScope.INDIVIDUAL],
  ): NotificationAppHandlerPayload {
    const message = getNotificationMessage(notificationType);

    return {
      notificationREQ: {
        relationId: relation.id,
        relationType: relation.type,
        type: notificationType,
        scopes: scopes,
        targetAccountId,
      },
      data: {
        title: message.title,
        topic: notificationType,
        body: message.content,
      },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-create.request.ts">
import { NotificationRelationType, NotificationScope, NotificationType, Prisma } from '@prisma/client';
import { IsArray, IsEnum, IsNumber, IsOptional } from 'class-validator';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class NotificationCreateREQ {
  @IsEnum(NotificationType)
  type: NotificationType;

  @IsEnum(NotificationRelationType)
  relationType: NotificationRelationType;

  @IdValidator()
  relationId: number;

  @IsEnum(NotificationScope)
  @IsArray()
  @IsOptional()
  scopes?: NotificationScope[];

  @IsNumber()
  @IsOptional()
  targetAccountId?: number;

  static toCreateNotification(body: NotificationCreateREQ): Prisma.NotificationCreateArgs {
    return {
      data: {
        type: body.type,
        scopes: body.scopes,
        relationType: body.relationType,
        relationId: body.relationId,
        title: getNotificationMessage(body.type).title,
        content: getNotificationMessage(body.type).content,
        TargetAccount: connectRelation(body.targetAccountId),
      },
      select: { id: true, targetAccountId: true },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-list.request.ts">
import { NotificationScope, Prisma } from '@prisma/client';
import { IsOptional } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class NotificationListREQ extends PaginationREQ {
  @BooleanValidator()
  @IsOptional()
  isRead?: boolean;

  static toQueryCondition(user: AuthUserDTO, query: NotificationListREQ): Prisma.NotificationWhereInput {
    return {
      isRead: query.isRead,
      OR: [
        { scopes: { has: NotificationScope.INDIVIDUAL }, targetAccountId: user.accountId },
        { scopes: { has: NotificationScope.ALL } },
      ],
    };
  }
  static toFindMany(user: AuthUserDTO, query: NotificationListREQ): Prisma.NotificationFindManyArgs {
    const condition = NotificationListREQ.toQueryCondition(user, query);

    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: defaultSortDesc,
      include: { TargetAccount: true },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-read.request.ts">
import { Prisma } from '@prisma/client';
import { IsBoolean } from 'class-validator';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';

export class NotificationReadREQ {
  @IsBoolean()
  isRead: boolean; // true is marked as read, false is marked as unread

  static toReadNotification(id: number, body: NotificationReadREQ): Prisma.NotificationUpdateArgs {
    return {
      where: { id: id },
      data: { isRead: body.isRead, readAt: orUndefinedWithCondition(body.isRead, nowEpoch()) },
      select: { id: true, isRead: true },
    };
  }
}
</file>

<file path="src/domains/notification/response/notification.response.ts">
import { Course, NotificationRelationType, NotificationType, Payment, Subscription } from '@prisma/client';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { NotificationGetPayload } from '../shared/types';

//=======================Course=======================
export class NotificationCourseDetailRESP {
  id: number;
  name: string;
  price: number;
  startDate: string;
  endDate: string;

  static fromEntity(entity: Course): NotificationCourseDetailRESP {
    return {
      id: entity.id,
      name: entity.name,
      price: parseDecimalNumber(entity.price),
      startDate: parsePrismaDateToEpoch(entity.startDate),
      endDate: parsePrismaDateToEpoch(entity.endDate),
    };
  }
}

export type NotificationPaymentSubscriptionRESP = Pick<NotificationSubscriptionDetailRESP, 'id' | 'createdAt' | 'course'>;

//=======================Payment=======================
export class NotificationPaymentDetailRESP {
  id: number;
  price: number;
  status: string;
  createdAt: string;
  subscription: NotificationSubscriptionDetailRESP;

  static fromEntity(entity: Payment, subscription: NotificationPaymentSubscriptionRESP): NotificationPaymentDetailRESP {
    return {
      id: entity.id,
      status: entity.status,
      subscription,
      price: parseDecimalNumber(entity.price),
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}

//=======================Mentor=======================
export class NotificationMentorDetailRESP {
  id: number;
  name: string;
  email: string;
  thumbnail?: ImageRESP;

  static fromEntity(entity: MentorGetPayload, thumbnail?: ImageRESP): NotificationMentorDetailRESP {
    return {
      id: entity.id,
      name: entity.Account.name,
      email: entity.Account.email,
      thumbnail,
    };
  }
}

//=======================Audio Room=======================
export class NotificationAudioRoomDetailRESP {
  id: number;
  title: string;
  startsAt: string;
  status: string;
  cid: string;

  static fromEntity(entity: AudioRoomGetPayload): NotificationAudioRoomDetailRESP {
    return {
      id: entity.id,
      title: entity.title,
      startsAt: parseEpoch(entity.startsAt),
      status: entity.status,
      cid: entity.cid,
    };
  }
}

//=======================Subscription=======================
export class NotificationSubscriptionDetailRESP {
  id: number;
  createdAt: string;
  course: NotificationCourseDetailRESP;
  payment?: NotificationPaymentDetailRESP;

  static fromEntity(
    entity: Subscription,
    course: NotificationCourseDetailRESP,
    payment: NotificationPaymentDetailRESP | null,
  ): NotificationSubscriptionDetailRESP {
    return {
      id: entity.id,
      course,
      payment,
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}

//=======================FEEDBACK=======================
export class NotificationFeedbackDetailRESP {
  id: number;
  courseReview: string;
  courseRating: number;
  mentorReview: string;
  mentorRating: number;

  static fromEntity(entity: any): NotificationFeedbackDetailRESP {
    return {
      id: entity.id,
      courseReview: entity.courseReview,
      courseRating: entity.courseRating,
      mentorReview: entity.mentorReview,
      mentorRating: entity.mentorRating,
    };
  }
}

//=======================REPORT=======================
export class NotificationReportDetailRESP {
  id: number;
  status: string;
  resolution: string;
  subscription?: NotificationSubscriptionDetailRESP;
  feedback?: NotificationFeedbackDetailRESP;

  static fromEntity(
    entity: any,
    subscription: NotificationSubscriptionDetailRESP,
    feedback: NotificationFeedbackDetailRESP,
  ): NotificationReportDetailRESP {
    return {
      id: entity.id,
      status: entity.status,
      resolution: entity.resolution,
      subscription,
      feedback,
    };
  }
}

export type NotificationRelationRESP =
  | NotificationCourseDetailRESP
  | NotificationPaymentDetailRESP
  | NotificationSubscriptionDetailRESP
  | NotificationMentorDetailRESP
  | NotificationAudioRoomDetailRESP
  | NotificationFeedbackDetailRESP
  | NotificationReportDetailRESP;

export class NotificationRESP {
  id: number;
  title: string;
  content: string;
  isRead: boolean;
  type: NotificationType;
  relationType: NotificationRelationType;
  createdAt: string;
  readAt?: string;
  course?: NotificationCourseDetailRESP;
  payment?: NotificationPaymentDetailRESP;
  subscription?: NotificationSubscriptionDetailRESP;
  mentor?: NotificationMentorDetailRESP;
  audioRoom?: NotificationAudioRoomDetailRESP;
  feedback?: NotificationFeedbackDetailRESP;
  report?: NotificationReportDetailRESP;

  static fromEntity(e: NotificationGetPayload, relation: NotificationRelationRESP): NotificationRESP {
    const mappingRelation = this.mapRelationTypeToDetail(e.relationType, relation);
    return {
      id: e.id,
      title: e.title,
      content: e.content,
      isRead: e.isRead,
      type: e.type,
      relationType: e.relationType,
      readAt: parseEpoch(e.readAt),
      createdAt: parseEpoch(e.createdAt),
      ...mappingRelation,
    };
  }

  static mapRelationTypeToDetail(relationType: NotificationRelationType, relation: NotificationRelationRESP) {
    let mappingRelation: any;
    switch (relationType) {
      case NotificationRelationType.COURSE:
        mappingRelation = { course: relation as NotificationCourseDetailRESP };
        break;
      case NotificationRelationType.PAYMENT:
        mappingRelation = { payment: relation as NotificationPaymentDetailRESP };
        break;
      case NotificationRelationType.SUBSCRIPTION:
        mappingRelation = { subscription: relation as NotificationSubscriptionDetailRESP };
        break;
      case NotificationRelationType.MENTOR:
        mappingRelation = { mentor: relation as NotificationMentorDetailRESP };
        break;
      case NotificationRelationType.AUDIO_CALL:
        mappingRelation = { audioRoom: relation as NotificationAudioRoomDetailRESP };
        break;
      case NotificationRelationType.FEEDBACK:
        mappingRelation = { feedback: relation as NotificationFeedbackDetailRESP };
        break;
      case NotificationRelationType.REPORT:
        mappingRelation = { report: relation as NotificationReportDetailRESP };
        break;
      default:
        throw new ActionFailedException(ActionFailed.NOTIFICATION_INVALID_RELATION_TYPE);
    }

    return {
      course: null,
      payment: null,
      subscription: null,
      mentor: null,
      audioRoom: null,
      report: null,
      feedback: null,
      ...mappingRelation,
    };
  }
}
</file>

<file path="src/domains/notification/shared/interfaces.ts">
export interface BaseNotificationPayload {
  type?: string;
  userId?: string;
}

export interface FcmNotificationPayload extends BaseNotificationPayload {
  title: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
}

export interface FCMSendOptions {
  token?: string;
  topic?: string;
  condition?: string;
  data?: { [key: string]: string }; // Custom data
}

export interface SESEmailPayload extends BaseNotificationPayload {
  to: string;
  subject?: string;
  template?: string;
  context?: any;
}

export interface SmsPayload extends BaseNotificationPayload {
  to: string;
  message: string;
}

// export interface NotificationPayload<TNotification, TData> {
//   notificationREQ: TNotification;
//   data: TData;
//   deviceTokenCondition?: Prisma.DeviceTokenWhereInput;
// }
</file>

<file path="src/domains/notification/shared/transation.enum.ts">
export enum Propagation {
  /**
   * (default) Reuse the existing transaction or create a new one if none exists.
   */
  Required = 'REQUIRED',
  /**
   * Create a new transaction even if one already exists. The new transaction is committed independently of the existing one.
   */
  RequiresNew = 'REQUIRES_NEW',
}
</file>

<file path="src/domains/notification/shared/types.ts">
import { Prisma } from '@prisma/client';
import { EmailPayload, EmailTemplate } from 'src/services/email/shared/types';
import { NotificationCreateREQ } from '../request/notification-create.request';

export type NotificationGetPayload = Prisma.NotificationGetPayload<{
  include: {
    TargetAccount: true;
  };
}>;

export interface BaseNotificationPayload {
  type?: string;
  userId?: string;
}

export interface FCMNotificationPayload extends BaseNotificationPayload {
  title: string;
  topic: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
}

export interface NotificationEmailPayload {
  data: EmailPayload;
  template?: EmailTemplate;
}

export enum NotificationChannel {
  EMAIL = 'notification.email',
  SMS = 'notification.sms',
  APP = 'notification.app',
}

export interface NotificationPayload<TNotification, TData> {
  notificationREQ: TNotification;
  data: TData;
  eviceTokenCondition?: Prisma.DeviceTokenWhereInput;
}

export type NotificationAppHandlerPayload = NotificationPayload<NotificationCreateREQ, FCMNotificationPayload>;
</file>

<file path="src/domains/notification/notification.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Query, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { NotificationService } from './notification.service';
import { NotificationListREQ } from './request/notification-list.request';
import { NotificationReadREQ } from './request/notification-read.request';

@UseGuards(AuthJwtGuard)
@Controller('notifications')
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: NotificationListREQ) {
    return await this.notificationService.list(req.user, query);
  }

  @Patch(':id')
  async readNotification(@Param('id', ParseIntPipe) id: number, @Body() body: NotificationReadREQ) {
    const notification = await this.notificationService.readNotification(id, body);

    return BaseResponse.of(notification);
  }
}
</file>

<file path="src/domains/notification/notification.gateway.ts">
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { EmailService } from 'src/services/email/email.service';
import { FCMService } from 'src/services/fcm/fcm.service';
import { payloadFcmAdapter } from 'src/services/fcm/shared/helpers';
import { NotificationService } from './notification.service';
import {
  NotificationAppHandlerPayload,
  NotificationChannel,
  NotificationEmailPayload,
  NotificationGetPayload,
} from './shared/types';

@Injectable()
export class NotificationGateway {
  private readonly logger = new Logger(NotificationGateway.name);
  constructor(
    private readonly fcmService: FCMService,
    private readonly emailService: EmailService,
    // private readonly smsService: SmsService,
    private readonly notificationService: NotificationService,
  ) {}

  @OnEvent(NotificationChannel.EMAIL)
  async handleEmailNotification(payload: NotificationEmailPayload) {
    await this.emailService.sendMail(payload.data, payload.template);
  }

  @OnEvent(NotificationChannel.APP)
  async handleAppNotification(payload: NotificationAppHandlerPayload) {
    this.logger.log('🚀 ~ NotificationGateway ~ handleAppNotification ~ payload:', payload);

    const notification = (await this.notificationService.createNotification(payload.notificationREQ)) as NotificationGetPayload;
    const detail = await this.notificationService.detail(notification.id);
    this.logger.log('🚀 ~ NotificationGateway ~ handleAppNotification ~ detail:', detail);

    const data = payloadFcmAdapter(payload.data.title, payload.data.topic, detail);
    const condition = payload.data.condition ?? { accountId: notification.targetAccountId };
    await this.fcmService.sendNotificationToAllDevices(notification.targetAccountId, condition, data);
  }

  // @OnEvent(NotificationChannel.SMS)
  // handleSmsNotification(payload: SmsPayload) {
  //   this.smsService.sendSMS(payload);
  // }
}
</file>

<file path="src/domains/notification/notification.module.ts">
import { Global, Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { FcmModule } from 'src/services/fcm/fcm.module';
import { NotificationController } from './notification.controller';
import { NotificationGateway } from './notification.gateway';
import { NotificationService } from './notification.service';
@Module({
  imports: [CommonModule, FcmModule],
  controllers: [NotificationController],
  providers: [NotificationService, NotificationGateway],
  exports: [NotificationService, NotificationGateway],
})
@Global()
export class NotificationModule {}
</file>

<file path="src/domains/notification/notification.service.ts">
import { Injectable } from '@nestjs/common';
import { Course, NotificationRelationType, Payment } from '@prisma/client';
import { PrismaService } from 'src/services/prisma/prisma.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomGetPayload } from '../audio-call/shared/types';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FeedbackGetPayload } from '../feedback/shared/type';
import { ImageService } from '../image/image.service';
import { MentorGetPayload } from '../mentor/shared/types';
import { ReportGetPayload } from '../report/shared/type';
import { SubscriptionGetPlayload } from '../subscription/shared/types';
import { NotificationCreateREQ } from './request/notification-create.request';
import { NotificationListREQ } from './request/notification-list.request';
import { NotificationReadREQ } from './request/notification-read.request';
import {
  NotificationAudioRoomDetailRESP,
  NotificationCourseDetailRESP,
  NotificationFeedbackDetailRESP,
  NotificationMentorDetailRESP,
  NotificationPaymentDetailRESP,
  NotificationReportDetailRESP,
  NotificationRESP,
  NotificationSubscriptionDetailRESP,
} from './response/notification.response';
import { Propagation } from './shared/transation.enum';
import { NotificationGetPayload } from './shared/types';

@Injectable()
export class NotificationService {
  constructor(
    private readonly prismaService: PrismaService,
    private readonly imageService: ImageService,
    private readonly transactionHost: TransactionHost,
  ) {}

  async list(user: AuthUserDTO, query: NotificationListREQ) {
    const notifications = await this.prismaService.notification.findMany(NotificationListREQ.toFindMany(user, query));
    const count = await this.prismaService.notification.count({
      where: NotificationListREQ.toQueryCondition(user, query),
    });

    const response = await Promise.all(
      notifications.map(async (notification: NotificationGetPayload) => {
        const relation = await this.findDetailRelation(notification.relationId, notification.relationType);
        return NotificationRESP.fromEntity(notification, relation);
      }),
    );

    return PaginationResponse.ofWithTotal(response, count);
  }

  @Transactional(Propagation.RequiresNew, TRANSACTION_TIMEOUT)
  async createNotification(body: NotificationCreateREQ) {
    const notification = await this.transactionHost.tx.notification.create(NotificationCreateREQ.toCreateNotification(body));

    return notification;
  }

  async readNotification(id: number, body: NotificationReadREQ) {
    const notification = await this.transactionHost.tx.notification.update(NotificationReadREQ.toReadNotification(id, body));
    return notification;
  }

  async detail(notificationId: number) {
    const notification = (await this.transactionHost.tx.notification.findFirst({
      where: { id: notificationId },
      select: {
        id: true,
        type: true,
        relationType: true,
        relationId: true,
        title: true,
        content: true,
        scopes: true,
        targetAccountId: true,
        createdAt: true,
      },
    })) as NotificationGetPayload;

    const relation = await this.findDetailRelation(notification.relationId, notification.relationType);

    return NotificationRESP.fromEntity(notification, relation);
  }

  private async findDetailRelation(relationId: number, relationType: NotificationRelationType): Promise<any> {
    switch (relationType) {
      case NotificationRelationType.COURSE:
        return this.findCourseDetail(relationId);
      case NotificationRelationType.PAYMENT:
        return this.findPaymentDetail(relationId);
      case NotificationRelationType.SUBSCRIPTION:
        return this.findSubscriptionDetail(relationId);
      case NotificationRelationType.MENTOR:
        return this.findMentorDetail(relationId);
      case NotificationRelationType.AUDIO_CALL:
        return this.findAudioCallDetail(relationId);
      case NotificationRelationType.FEEDBACK:
        return this.findFeedbackDetail(relationId);
      case NotificationRelationType.REPORT:
        return this.findReportDetail(relationId);
    }
  }

  private async findReportDetail(reportId: number) {
    const report = (await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: {
        id: true,
        status: true,
        resolution: true,
        Subscription: { select: { id: true } },
        Feedback: { select: { id: true } },
      },
    })) as ReportGetPayload;

    if (!report) return null;

    const subscription = report.Subscription ? await this.findSubscriptionDetail(report.Subscription.id) : null;
    const feedback = report.Feedback ? await this.findFeedbackDetail(report.Feedback.id) : null;

    return NotificationReportDetailRESP.fromEntity(report, subscription, feedback);
  }

  private async findFeedbackDetail(feedbackId: number) {
    const feedback = (await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, courseRating: true, mentorRating: true, courseReview: true, mentorReview: true, reviewerId: true },
    })) as FeedbackGetPayload;

    if (!feedback) return null;

    return NotificationFeedbackDetailRESP.fromEntity(feedback);
  }

  private async findCourseDetail(courseId: number) {
    const course = (await this.transactionHost.tx.course.findFirst({
      where: { id: courseId },
      select: { id: true, name: true, startDate: true, endDate: true, price: true },
    })) as Course;

    if (!course) return null;

    return NotificationCourseDetailRESP.fromEntity(course);
  }

  private async findAudioCallDetail(audioCallId: number) {
    const audioCall = (await this.transactionHost.tx.audioRoom.findFirst({
      where: { id: audioCallId },
      select: { id: true, title: true, startsAt: true, status: true, cid: true },
    })) as AudioRoomGetPayload;

    if (!audioCall) return null;

    return NotificationAudioRoomDetailRESP.fromEntity(audioCall);
  }

  private async findMentorDetail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId },
      select: {
        id: true,
        status: true,
        Account: { select: { id: true, name: true, email: true, phoneNumber: true, avatarId: true } },
      },
    })) as MentorGetPayload;

    if (!mentor) return null;

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);

    return NotificationMentorDetailRESP.fromEntity(mentor, thumbnail);
  }

  private async findPaymentDetail(paymentId: number) {
    const payment = (await this.transactionHost.tx.payment.findFirst({
      where: { id: paymentId },
      select: { id: true, price: true, status: true, subscriptionId: true, createdAt: true },
    })) as Payment;

    if (!payment) return null;

    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: payment.subscriptionId },
      select: { id: true, courseId: true, status: true, createdAt: true },
    })) as SubscriptionGetPlayload;
    const course = await this.findCourseDetail(subscription.courseId);

    return NotificationPaymentDetailRESP.fromEntity(payment, {
      id: subscription.id,
      createdAt: parseEpoch(subscription.createdAt),
      course,
    });
  }

  private async findSubscriptionDetail(subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: subscriptionId },
      select: { id: true, courseId: true, status: true, Payment: { select: { id: true } }, createdAt: true },
    })) as SubscriptionGetPlayload;

    if (!subscription) return null;

    const course = await this.findCourseDetail(subscription.courseId);
    const payment = subscription.Payment ? await this.findPaymentDetail(subscription.Payment?.id) : null;

    return NotificationSubscriptionDetailRESP.fromEntity(subscription, course, payment);
  }
}
</file>

<file path="src/domains/payment/client/payment-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientController', () => {
  let controller: PaymentClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PaymentClientController],
      providers: [PaymentClientService],
    }).compile();

    controller = module.get<PaymentClientController>(PaymentClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.controller.ts">
import { Body, Controller, Post, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaymentCreateREQ } from '../dto/payment-create.request';
import { PaymentClientService } from './payment-client.service';

@Controller('client/payments')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class PaymentClientController {
  constructor(private readonly paymentClientService: PaymentClientService) {}

  @Post()
  async createPayment(@Req() req: AuthRequestDTO, @Body() body: PaymentCreateREQ): Promise<any> {
    const ipAddr = req.headers['x-forwarded-for'] || req.socket.remoteAddress;

    const payment = await this.paymentClientService.create(body, ipAddr as string);

    return BaseResponse.of(payment);
  }

  @Post('verify')
  async verify(@Body() body: ReturnQueryFromVNPay & { paymentId: number }): Promise<any> {
    const { paymentId, ...returnUrl } = body;
    const result = await this.paymentClientService.verify(paymentId, returnUrl);

    return BaseResponse.of(result);
  }
}
</file>

<file path="src/domains/payment/client/payment-client.module.ts">
import { Module } from '@nestjs/common';
import { VNP_HASHSECRET, VNP_TMNCODE } from 'src/app.config';
import { VnpayModule } from 'src/services/payment-gateway/vn-pay/vnpay.module';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

@Module({
  imports: [
    VnpayModule.register({
      tmnCode: VNP_TMNCODE,
      secureSecret: VNP_HASHSECRET,
    }),
  ],
  controllers: [PaymentClientController],
  providers: [PaymentClientService],
  exports: [PaymentClientService],
})
export class PaymentClientModule {}
</file>

<file path="src/domains/payment/client/payment-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientService', () => {
  let service: PaymentClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PaymentClientService],
    }).compile();

    service = module.get<PaymentClientService>(PaymentClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomType,
  NotificationRelationType,
  NotificationType,
  ParticipantAudioRoomRole,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { SubscriptionMakePaymentHelper } from 'src/domains/subscription/helper/subscription-make-payment.helper';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { VnpayService } from 'src/services/payment-gateway/vn-pay/vnpay.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { ReturnPaymentStatus } from 'src/shared/constants/payment.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { EXPIRED_SUBSCRIPTION_AFTER_APPROVED } from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { Result } from 'src/shared/generics/type.helper';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { PaymentContinueREQ } from '../dto/payment-continue.request';
import { PaymentCreateREQ } from '../dto/payment-create.request';

@Injectable()
export class PaymentClientService {
  private logger = new Logger(PaymentClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly vnpayService: VnpayService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async create(body: PaymentCreateREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.create({
      data: {
        status: PaymentStatus.IN_PROGRESS,
        price: parseDecimalNumber(body.amount),
        Subscription: connectRelation(body.subscriptionId),
      },
      select: {
        id: true,
        status: true,
      },
    });

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async continue(body: PaymentContinueREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { subscriptionId: body.subscriptionId },
      select: { id: true, status: true },
    });

    if (payment.status !== PaymentStatus.IN_PROGRESS) {
      throw new ActionFailedException(ActionFailed.PAYMENT_NOT_AVAILABLE);
    }

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async verify(paymentId: number, query: ReturnQueryFromVNPay): Promise<Result<ReturnQueryFromVNPay, Error>> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { id: paymentId },
      select: { subscriptionId: true },
    });

    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: payment.subscriptionId },
      select: {
        id: true,
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        accountId: true,
        Course: { select: { id: true, creatorId: true } },
      },
    });

    const now = nowEpoch();

    if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    if (now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
      this.logger.log(
        '🚀 ~ PaymentClientService ~ verify ~ EXPIRED_SUBSCRIPTION_AFTER_APPROVED: ',
        EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
      );

      this.logger.warn(
        `🚀 ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
    }

    const result = await this.vnpayService.verifyReturnUrl(paymentId, query);

    if (result.success == false) {
      this.logger.error('🚀 ~ PaymentClientService ~ verify ~ fail result:', result);
      this.logger.warn('🚀 ~ PaymentClientService ~ verify ~ fail query from third party');
      // await this.transactionHost.tx.payment.update({
      //   where: { id: paymentId },
      //   data: {
      //     status: PaymentStatus.CANCELED,
      //     Subscription: { update: { status: SubscriptionStatus.CANCELED } },
      //   },
      // });

      return result;
    }

    switch (result.data.vnp_ResponseCode) {
      case ReturnPaymentStatus.SUCCESSFUL_STATUS:
        const { payment } = await this.updatePaymentStatus(paymentId, PaymentStatus.DONE, SubscriptionStatus.ACTIVE);

        const payload = NotificationHelper.makeAppNotificationPayload(
          { id: payment.id, type: NotificationRelationType.PAYMENT },
          subscription.Course.creatorId,
          NotificationType.PAYMENT_SUCCESS,
        );

        runFunctionWithCondition(!!subscription, () => {
          this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
        });

        break;
      // case ReturnPaymentStatus.EXPIRED_STATUS:
      // await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
      // break;
      default:
        break;
    }

    return result;
  }

  async updatePaymentStatus(paymentId: number, status: PaymentStatus, subscriptionStatus: SubscriptionStatus) {
    const payment = await this.transactionHost.tx.payment.update({
      where: { id: paymentId },
      data: { status },
      select: {
        id: true,
        Subscription: {
          select: { id: true, accountId: true, courseAccessStartAt: true, Course: { select: { name: true, creatorId: true } } },
        },
      },
    });

    let cid: string;
    let callId: number;
    if (subscriptionStatus === SubscriptionStatus.ACTIVE) {
      callId = await this.createAudioCall(payment.Subscription as SubscriptionGetPlayload);
      cid = await this.generateCid(callId);
    }

    (await this.transactionHost.tx.subscription.update(
      SubscriptionMakePaymentHelper.toActivate(payment.Subscription.id, subscriptionStatus, callId),
    )) as SubscriptionGetPlayload;

    return { payment, cid };
  }

  private async createAudioCall(subscription: SubscriptionGetPlayload): Promise<number> {
    const audioCallCreateData: AudioCallAdminCreateREQ = {
      title: `${subscription.Course.name}`,
      status: RoomStatus.SCHEDULED,
      type: AudioRoomType.AUDIOROOM,
      members: [{ accountId: subscription.accountId, role: ParticipantAudioRoomRole.USER }],
      startsAt: SubscriptionMakePaymentHelper.parseAudioCallStartsAt(Number(subscription.courseAccessStartAt)),
    };

    const call = await this.transactionHost.tx.audioRoom.create(
      AudioCallAdminCreateREQ.toCreateMemberInput(subscription.Course.creatorId, audioCallCreateData),
    );

    return call.id;
  }

  // Function to generate CID
  private async generateCid(callId: number): Promise<string> {
    const cid = `${new Date().getTime()}-${callId}-${randomUUID()}`;

    await this.transactionHost.tx.audioRoom.update({
      where: { id: callId },
      data: { cid: cid },
      select: { id: true },
    });
    return cid;
  }
}
</file>

<file path="src/domains/payment/dto/payment-continue.request.ts">
import { PaymentCreateREQ } from './payment-create.request';

export class PaymentContinueREQ extends PaymentCreateREQ {}
</file>

<file path="src/domains/payment/dto/payment-create.request.ts">
import { IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { VNPAY_RETURN_URL } from 'src/app.config';
import { BankCode } from 'src/services/payment-gateway/vn-pay/shared/vnpay.enum';
import { VNPayBuildUrlRequest } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class PaymentCreateREQ {
  @IdValidator()
  subscriptionId: number;

  @IsNumber()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  amount: number;

  @IsEnum(BankCode)
  @IsOptional()
  bankCode?: BankCode;

  @IsString()
  @MaxLength(255)
  description: string;

  static toVnpayRequest(body: PaymentCreateREQ, ipAddr: string): VNPayBuildUrlRequest {
    return {
      vnp_Amount: body.amount,
      vnp_BankCode: body.bankCode,
      vnp_OrderInfo: body.description,
      vnp_IpAddr: ipAddr,
      vnp_ReturnUrl: VNPAY_RETURN_URL,
      vnp_TxnRef: `${body.subscriptionId}-${nowEpoch()}`,
    };
  }
}
</file>

<file path="src/domains/payment/payment.module.ts">
import { Module } from '@nestjs/common';
import { PaymentClientModule } from './client/payment-client.module';

@Module({
  imports: [PaymentClientModule],
})
export class PaymentModule {}
</file>

<file path="src/domains/report/helper/report-create.helper.ts">
import { Prisma, ReportStatus, ReportType } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { ReportCreateInterface } from '../shared/interface';

export class ReportCreateHelper {
  static toConnectRelationByReportType(type: ReportType, relationId: number) {
    switch (type) {
      case ReportType.MENTOR_ISSUES:
      case ReportType.COURSE_UNQUALIFIED:
        return { Subscription: connectRelation(relationId) };
      case ReportType.FEEDBACK_INAPPROPRIATE:
        return { Feedback: connectRelation(relationId) };
    }
  }

  static toCreate<T extends ReportCreateInterface>(user: AuthUserDTO, body: T): Prisma.ReportCreateArgs {
    const relationId = body['subscriptionId'] || body['feedbackId'];

    return {
      data: {
        type: body.type,
        description: body.description,
        status: ReportStatus.PENDING,
        Reporter: connectRelation(user.accountId),
        ...this.toConnectRelationByReportType(body.type, relationId),
      },
    };
  }
}
</file>

<file path="src/domains/report/helper/report-detail.helper.ts">
import { Feedback, Prisma } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { ReportDetailRESP, ReportFeedbackDetailRESP, ReportSubscriptionDetailRESP } from '../response/report-detail.response';
import { ReporterAccountRESP, ReportGetPayload, ReportRelationDetailRESP } from '../shared/type';

export class ReportDetailHelper {
  static toFindUnique(reportId: number): Prisma.ReportFindUniqueOrThrowArgs {
    return {
      where: { id: reportId },
      select: {
        id: true,
        type: true,
        description: true,
        status: true,
        resolution: true,
        createdAt: true,
        reporterId: true,
        subscriptionId: true,
        Feedback: {
          select: {
            id: true,
            reviewerId: true,
            courseRating: true,
            courseReview: true,
            mentorRating: true,
            mentorReview: true,
            subscriptionId: true,
            createdAt: true,
          },
        },
      },
    };
  }

  static fromReportFeedback(feedback: Feedback, reviewer: ReporterAccountRESP): ReportFeedbackDetailRESP {
    if (!feedback) return null;

    return {
      id: feedback.id,
      courseRating: feedback.courseRating,
      mentorRating: feedback.mentorRating,
      courseReview: feedback.courseReview,
      mentorReview: feedback.mentorReview,
      updatedAt: parseEpoch(feedback.updatedAt),
      reviewer: reviewer,
      subscriptionId: feedback.subscriptionId,
    };
  }

  static fromReportSubscription(subcription: ReportSubscriptionDetailRESP): ReportSubscriptionDetailRESP {
    if (!subcription) return null;

    return subcription;
  }

  static fromReportEntity(entity: ReportGetPayload, reportRelation: ReportRelationDetailRESP): ReportDetailRESP {
    return {
      id: entity.id,
      type: entity.type,
      description: entity.description,
      status: entity.status,
      resolution: entity.resolution,
      createdAt: parseEpoch(entity.createdAt),
      subscription: orNullWithCondition(!!reportRelation.subscription, reportRelation.subscription),
      feedback: orNullWithCondition(!!reportRelation.feedback, reportRelation.feedback),
    };
  }
}
</file>

<file path="src/domains/report/helper/report-list.helper.ts">
import { AccountType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parseEpoch, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { ReportListREQ } from '../request/report-list.request';
import { ReportListRESP } from '../response/report-list.response';
import { ReportGetPayload } from '../shared/type';

export class ReportListHelper {
  static toFilterByAccountType(user: AuthUserDTO): Prisma.ReportWhereInput {
    switch (user.accountType) {
      case AccountType.STUDENT: {
        return { Reporter: { id: user.accountId } };
      }
      case AccountType.ADMIN: {
        return {};
      }
    }
  }

  static toQueryCondition(user: AuthUserDTO, query: ReportListREQ): Prisma.ReportWhereInput {
    const filterByAccountType = this.toFilterByAccountType(user);
    const queryName = orUndefinedWithCondition(!!query.reporterName, {
      Reporter: parsePrismaSearch('name', query.reporterName),
    });

    return {
      AND: [filterByAccountType, queryName].filter((x) => !!x),
      status: orUndefinedWithCondition(!!query.status, query.status),
      type: orUndefinedWithCondition(!!query.type, query.type),
    };
  }

  static toFindMany(user: AuthUserDTO, query: ReportListREQ): Prisma.ReportFindManyArgs {
    const queryCondition = this.toQueryCondition(user, query);
    console.log('🚀 ~ ReportListHelper ~ toFindMany ~ queryCondition:', queryCondition);

    return {
      where: { ...queryCondition },
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        type: true,
        description: true,
        status: true,
        resolution: true,
        createdAt: true,
        Reporter: { select: { id: true, name: true } },
      },
    };
  }

  static fromEntity(entity: ReportGetPayload): ReportListRESP {
    return {
      id: entity.id,
      type: entity.type,
      description: entity.description,
      status: entity.status,
      resolution: entity.resolution,
      reporter: { id: entity.Reporter.id, name: entity.Reporter.name },
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}
</file>

<file path="src/domains/report/helper/report-resolve.helper.ts">
import { AccountSuspensionType, AudioRoomActivityHistory, CourseSuspensionType, WageStatus } from '@prisma/client';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseEpoch } from 'src/shared/parsers/common.parser';

export class ReportResolveHelper {
  public static calculateAccountSuspensionDays(noOfReports: number): AccountSuspensionType {
    if (noOfReports < 0) throw new ActionFailedException(ActionFailed.REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO);

    switch (true) {
      case noOfReports >= 0 && noOfReports < 5:
        return AccountSuspensionType.ACCOUNT_NOT_SUSPENDED;
      case noOfReports >= 5 && noOfReports <= 7:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_3_DAYS;
      case noOfReports > 7 && noOfReports < 11:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_7_DAYS;
      default:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_PERMANENTLY;
    }
  }

  public static calculateCourseSuspensionDays(noOfReports: number): CourseSuspensionType {
    console.log('🚀 ~ ReportResolveHelper ~ calculateCourseSuspensionDays ~ noOfReports:', noOfReports);
    if (noOfReports < 0) throw new ActionFailedException(ActionFailed.REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO);

    switch (true) {
      case noOfReports >= 0 && noOfReports <= 1:
        return CourseSuspensionType.COURSE_NOT_SUSPENDED;
      case noOfReports > 1 && noOfReports <= 3:
        return CourseSuspensionType.COURSE_SUSPENDED_3_DAYS;
      case noOfReports > 3 && noOfReports <= 5:
        return CourseSuspensionType.COURSE_SUSPENDED_7_DAYS;
      default:
        return CourseSuspensionType.COURSE_SUSPENDED_PERMANENTLY;
    }
  }

  public static getTotalTimeInAudioRoom(audioRoomHistories: AudioRoomActivityHistory[]): number {
    const totalTimeInSeconds = audioRoomHistories.reduce((total, history) => {
      if (history.joinedAt && history.leftAt) {
        const duration = Math.abs(parseEpoch(history.joinedAt) - parseEpoch(history.leftAt));
        return total + duration;
      }

      return total;
    }, 0);

    return totalTimeInSeconds;
  }

  public static calculatePaymentCut(totalTimeInMils: number, courseTotalDuration: number): WageStatus {
    const totalDurationInMils = courseTotalDuration * 60 * 60 * 1000;
    const percentage = (totalTimeInMils / totalDurationInMils) * 100;
    console.log('🚀 ~ ReportResolveHelper ~ calculatePaymentCut ~ percentage:', percentage);

    switch (true) {
      case percentage < 40 && percentage >= 0:
        return WageStatus.NOT_PAID;
      case percentage >= 40 && percentage < 70:
        return WageStatus.PARTIAL_30_PERCENT;
      case percentage >= 70 && percentage < 80:
        return WageStatus.PARTIAL_70_PERCENT;
      default:
        return WageStatus.FULL_WAGE;
    }
  }
}
</file>

<file path="src/domains/report/request/report-client-feedback-create.request.ts">
import { ReportType } from '@prisma/client';
import { IsEnum, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { ReportCreateInterface } from '../shared/interface';

export class ReportClientFeedbackCreateREQ implements ReportCreateInterface {
  @IdValidator()
  feedbackId: number;

  @IsEnum(ReportType)
  type: ReportType;

  @MaxLength(1000)
  description: string;
}
</file>

<file path="src/domains/report/request/report-client-subscription-create.request.ts">
import { ReportType } from '@prisma/client';
import { IsEnum, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { ReportCreateInterface } from '../shared/interface';

export class ReportClientSubscriptionCreateREQ implements ReportCreateInterface {
  @IdValidator()
  subscriptionId: number;

  @IsEnum(ReportType)
  type: ReportType;

  @MaxLength(1000)
  description: string;
}
</file>

<file path="src/domains/report/request/report-list.request.ts">
import { ReportStatus, ReportType } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ReportListREQ extends PaginationREQ {
  @IsEnum(ReportStatus)
  @IsOptional()
  status?: ReportStatus;

  @IsEnum(ReportType)
  @IsOptional()
  type?: ReportType;

  @IsOptional()
  @IsString()
  reporterName?: string;
}
</file>

<file path="src/domains/report/request/report-resolve-base.request.ts">
import { ReportStatus } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsString, MaxLength } from 'class-validator';

export class ReportResolveBaseREQ {
  @IsEnum(ReportStatus)
  status: ReportStatus;

  @IsString()
  @MaxLength(1000)
  @IsNotEmpty()
  resolution: string;
}
</file>

<file path="src/domains/report/request/report-resolve-feeback.request.ts">
import { ReportResolveBaseREQ } from './report-resolve-base.request';

export class ReportResolveFeedbackREQ extends ReportResolveBaseREQ {}
</file>

<file path="src/domains/report/request/report-resolve-subscription.request.ts">
import { ReportResolveBaseREQ } from './report-resolve-base.request';

export class ReportResolveSubscriptionREQ extends ReportResolveBaseREQ {}
</file>

<file path="src/domains/report/response/report-detail.response.ts">
import { ReportStatus, ReportType } from '@prisma/client';
import { FeedbackListRESP } from 'src/domains/feedback/response/feedback-list.response';
import { SubscriptionDetailRESP } from 'src/domains/subscription/dto/response/subscription-detail.response';
import { ReportFeedbackListRESP } from '../shared/type';

export class ReportSubscriptionDetailRESP extends SubscriptionDetailRESP {
  audioCall: ReportAudioCallDetailRESP;
  feedbacks: ReportFeedbackListRESP[] = [];
}

export class ReportFeedbackDetailRESP extends FeedbackListRESP {}

export class ReportAudioCallDetailRESP {
  id: number;
  cid: string;
}

export class ReportDetailRESP {
  id: number;
  type: ReportType;
  description: string;
  status: ReportStatus;
  resolution: string;
  createdAt: string;
  subscription?: ReportSubscriptionDetailRESP;
  feedback?: ReportFeedbackDetailRESP;
}
</file>

<file path="src/domains/report/response/report-list.response.ts">
export class ReportListRESP {
  id: number;
  type: string;
  description: string;
  status: string;
  resolution: string;
  reporter: {
    id: number;
    name: string;
  };
  createdAt: string;
}
</file>

<file path="src/domains/report/shared/interface.ts">
import { ReportType } from '@prisma/client';

export interface ReportCreateInterface {
  type: ReportType;
  description: string;
}
</file>

<file path="src/domains/report/shared/type.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { SubscriptionDetailRESP } from 'src/domains/subscription/dto/response/subscription-detail.response';
import { ReportFeedbackDetailRESP } from '../response/report-detail.response';

export type ReportGetPayload = Prisma.ReportGetPayload<{
  include: { Feedback: true; Reporter: true; Subscription: true };
}>;

export type ReporterAccountRESP = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;

export type ReportRelationDetailRESP = {
  feedback?: ReportFeedbackDetailRESP;
  subscription?: SubscriptionDetailRESP;
};

export type ReportFeedbackListRESP = {
  id: number;
  courseRating: number;
  courseReview: string;
  mentorRating: number;
  mentorReview: string;
  updatedAt: string;
};
</file>

<file path="src/domains/report/shared/utilities.ts">
import { ReportClientFeedbackCreateREQ } from '../request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from '../request/report-client-subscription-create.request';

function getRelationId(body: ReportClientSubscriptionCreateREQ | ReportClientFeedbackCreateREQ): number {
  if ('subscriptionId' in body) return body.subscriptionId;
  if ('feedbackId' in body) return body.feedbackId;

  throw new Error('Unable to resolve relationId: invalid DTO structure');
}
</file>

<file path="src/domains/report/report.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { Roles } from '../auth/auth-role.decorator';
import { AuthRoleGuard } from '../auth/auth-role.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { ReportDetailHelper } from './helper/report-detail.helper';
import { ReportService } from './report.service';
import { ReportClientFeedbackCreateREQ } from './request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from './request/report-client-subscription-create.request';
import { ReportListREQ } from './request/report-list.request';
import { ReportResolveFeedbackREQ } from './request/report-resolve-feeback.request';
import { ReportResolveSubscriptionREQ } from './request/report-resolve-subscription.request';

@Controller('reports')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class ReportController {
  constructor(private readonly reportService: ReportService) {}

  @Get()
  @Roles(AccountType.ADMIN, AccountType.STUDENT)
  async list(@Req() req: AuthRequestDTO, @Query() query: ReportListREQ) {
    const { data, count } = await this.reportService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data, count);
  }

  @Post('subscriptions')
  @Roles(AccountType.STUDENT)
  async createSubscriptionReport(@Req() req: AuthRequestDTO, @Body() body: ReportClientSubscriptionCreateREQ) {
    await this.reportService.createSubscriptionReport(req.user, body);

    return BaseResponse.ok();
  }

  @Post('feedbacks')
  @Roles(AccountType.STUDENT)
  async createFeedbackReport(@Req() req: AuthRequestDTO, @Body() body: ReportClientFeedbackCreateREQ) {
    await this.reportService.createReportFeedback(req.user, body);

    return BaseResponse.ok();
  }

  @Get(':reportId')
  @Roles(AccountType.ADMIN, AccountType.STUDENT)
  async detail(@Req() req: AuthRequestDTO, @Param('reportId', ParseIntPipe) reportId: number) {
    const { report, feedback, subscription } = await this.reportService.detail(req.user, reportId);

    const reportDtos = ReportDetailHelper.fromReportEntity(report, { feedback, subscription });

    return BaseResponse.of(reportDtos);
  }

  @Patch(':reportId/feedback-resolutions')
  @Roles(AccountType.ADMIN)
  async resolve(@Param('reportId', ParseIntPipe) reportId: number, @Body() body: ReportResolveFeedbackREQ) {
    await this.reportService.resolveFeedback(reportId, body);

    return BaseResponse.ok();
  }

  @Patch(':reportId/subscription-resolutions')
  @Roles(AccountType.ADMIN)
  async resolveSubscription(@Param('reportId', ParseIntPipe) reportId: number, @Body() body: ReportResolveSubscriptionREQ) {
    await this.reportService.resolveSubscriptionReport(reportId, body);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/domains/report/report.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from '../accounts/accounts.module';
import { FeedbackClientModule } from '../feedback/client/feedback-client.module';
import { SubscriptionClientModule } from '../subscription/client/subscription-client.module';
import { ReportController } from './report.controller';
import { ReportService } from './report.service';

@Module({
  imports: [AccountModule, SubscriptionClientModule, FeedbackClientModule],
  controllers: [ReportController],
  providers: [ReportService],
})
export class ReportModule {}
</file>

<file path="src/domains/report/report.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ReportService } from './report.service';

describe('ReportService', () => {
  let service: ReportService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ReportService],
    }).compile();

    service = module.get<ReportService>(ReportService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/report/report.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AccountStatus,
  AccountSuspensionType,
  AccountType,
  AudioRoomActivityHistory,
  CourseStatus,
  CourseSuspensionType,
  Feedback,
  NotificationRelationType,
  NotificationType,
  PaymentStatus,
  Report,
  ReportStatus,
  ReportType,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import {
  NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER,
  NOTIFICATION_SUSPENSION_COURSE_MAPPER,
} from 'src/shared/constants/notification.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import {
  REPORT_DURATION_TIME_QUERY,
  REPORT_FEEDBACK_TYPE,
  REPORT_SUBSCRIPTION_TYPE,
  ReportNotificationMap,
} from 'src/shared/constants/report.constant';
import { SUBSCRIPTION_ACTIVE_STATUS } from 'src/shared/constants/subscription.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { orNullWithCondition, orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { AccountService } from '../accounts/account.service';
import { AccountRESP } from '../accounts/response/account.response';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FeedbackClientService } from '../feedback/client/feedback-client.service';
import { FeedbackGetPayload, FeedbackRelation } from '../feedback/shared/type';
import { NotificationHelper } from '../notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from '../notification/shared/types';
import { SubscriptionClientService } from '../subscription/client/subscription-client.service';
import { SubscriptionDetailRESP } from '../subscription/dto/response/subscription-detail.response';
import { SubscriptionGetPlayload } from '../subscription/shared/types';
import { ReportCreateHelper } from './helper/report-create.helper';
import { ReportDetailHelper } from './helper/report-detail.helper';
import { ReportListHelper } from './helper/report-list.helper';
import { ReportResolveHelper } from './helper/report-resolve.helper';
import { ReportClientFeedbackCreateREQ } from './request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from './request/report-client-subscription-create.request';
import { ReportListREQ } from './request/report-list.request';
import { ReportResolveFeedbackREQ } from './request/report-resolve-feeback.request';
import { ReportResolveSubscriptionREQ } from './request/report-resolve-subscription.request';
import { ReportGetPayload } from './shared/type';

@Injectable()
export class ReportService {
  private readonly logger = new Logger(ReportService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly eventEmitterService: EventEmitterService,
    private readonly subscriptionService: SubscriptionClientService,
    private readonly feedbackService: FeedbackClientService,
    private readonly accountService: AccountService,
  ) {}

  async list(user: AuthUserDTO, query: ReportListREQ) {
    const count = await this.transactionHost.tx.report.count({ where: ReportListHelper.toQueryCondition(user, query) });
    const reports = await this.transactionHost.tx.report.findMany(ReportListHelper.toFindMany(user, query));

    const dto = reports.map(ReportListHelper.fromEntity);

    return { data: dto, count };
  }

  async detail(user: AuthUserDTO, reportId: number) {
    let report: ReportGetPayload;
    try {
      report = (await this.transactionHost.tx.report.findUniqueOrThrow(
        ReportDetailHelper.toFindUnique(reportId),
      )) as ReportGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.REPORT_NOT_FOUND);
    }

    const subsriptionDtos = await this.getSubscriptionDetail(user, report.subscriptionId);
    const feedbackDtos = await this.getFeedbackDetail(report.Feedback);

    return { report, subscription: subsriptionDtos, feedback: feedbackDtos };
  }

  async getFeedbackDetail(feedback: Feedback) {
    this.logger.log('🚀 ~ ReportService ~ getFeedbackDetail ~ feedback:', feedback);
    if (!feedback || !feedback.subscriptionId) return null;

    // const { mentorData, studentInfo, subscription } = await this.subscriptionService.detail(feedback.subscriptionId);

    // const subscriptionDtos = SubscriptionDetailRESP.fromEntity(
    //   subscription,
    //   mentorData.mentor,
    //   AccountRESP.fromEntity(
    //     {
    //       ...studentInfo.account,
    //       dob: String(studentInfo.account.dob),
    //     },
    //     studentInfo.thumbnail,
    //   ),
    //   mentorData.thumbnail,
    // );

    // const { dtos: feedbackDtoList } = await this.feedbackService.list({
    //   relationId: subscription.courseId,
    //   relationType: FeedbackRelation.COURSE,
    // });

    // const audioCall = await this.transactionHost.tx.audioRoom.findFirst({
    //   where: { Subscription: { id: feedback.subscriptionId } },
    //   select: { id: true, cid: true },
    // });

    const reviewer = await this.accountService.getMe(feedback.reviewerId);

    return ReportDetailHelper.fromReportFeedback(feedback, {
      id: reviewer.account.id,
      name: reviewer.account.name,
      thumbnail: reviewer.thumbnail,
    });
  }

  async getSubscriptionDetail(user: AuthUserDTO, subscriptionId: number) {
    if (!subscriptionId) return null;
    const { mentorData, studentInfo, subscription } = await this.subscriptionService.detail(user, subscriptionId);

    const subscriptionDto = SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );

    const { dtos: feedbackDtoList } = await this.feedbackService.list({
      relationId: subscription.courseId,
      relationType: FeedbackRelation.COURSE,
    });

    const audioCall = await this.transactionHost.tx.audioRoom.findFirst({
      where: { Subscription: { id: subscriptionId } },
      select: { id: true, cid: true },
    });

    return ReportDetailHelper.fromReportSubscription({
      ...subscriptionDto,
      audioCall: orNullWithCondition(!!audioCall, { id: audioCall.id, cid: audioCall.cid }),
      feedbacks: feedbackDtoList.map((e) => ({
        id: e.id,
        courseRating: e.courseRating,
        mentorRating: e.mentorRating,
        courseReview: e.courseReview,
        mentorReview: e.mentorReview,
        updatedAt: e.updatedAt,
      })),
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resolveFeedback(reportId: number, body: ReportResolveFeedbackREQ) {
    const report = await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: { id: true, status: true, type: true },
    });

    if (!report) {
      throw new ActionFailedException(ActionFailed.REPORT_FEEDBACK_NOT_FOUND);
    } else if (!REPORT_FEEDBACK_TYPE.includes(report.type)) {
      throw new ActionFailedException(ActionFailed.REPORT_INVALID_TYPE, `The report ${report.type} is not feedback`);
    }

    const updatedReport = await this.transactionHost.tx.report.update({
      where: { id: report.id },
      data: { status: body.status, resolution: body.resolution },
      select: { id: true, reporterId: true, feedbackId: true },
    });

    await this.transactionHost.tx.feedback.delete({ where: { id: updatedReport.feedbackId } });

    //TODO: Warning the student about their negative feedback, and maybe ban them from the platform for 30 days

    this.createNotificationReportFeedback(updatedReport as Report, body);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resolveSubscriptionReport(reportId: number, body: ReportResolveSubscriptionREQ) {
    const report = await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: { id: true, status: true, type: true, reporterId: true, subscriptionId: true },
    });

    if (!report) {
      throw new ActionFailedException(ActionFailed.REPORT_FEEDBACK_NOT_FOUND);
    } else if (!REPORT_SUBSCRIPTION_TYPE.includes(report.type)) {
      throw new ActionFailedException(ActionFailed.REPORT_INVALID_TYPE, `The report ${report.type} is not subscription`);
    }

    if (body.status === ReportStatus.RESOLVED) {
      //handle the pushnishment
      await this.handleSubscriptionPushnishment(report as Report, report.subscriptionId);
    }

    const updatedReport = await this.transactionHost.tx.report.update({
      where: { id: report.id },
      data: { status: body.status, resolution: body.resolution },
      select: { id: true, reporterId: true, subscriptionId: true },
    });

    this.logger.log('🚀 ~ ReportService ~ resolveSubscriptionReport ~ Report Subscription after updated:', updatedReport);
  }

  //TODO: Check the logic of this method morning
  async handleSubscriptionPushnishment(report: Report, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: subscriptionId },
      select: { id: true, audioRoomId: true, Course: { select: { id: true, creatorId: true, totalDuration: true } } },
    })) as SubscriptionGetPlayload;

    switch (report.type) {
      case ReportType.COURSE_UNQUALIFIED:
        //Get resolved report of COURSES within 3 months
        //Handle the punishment for courses
        await this.handleCourseSuspension(subscription, report);
        break;
      case ReportType.MENTOR_ISSUES:
        //Get resolved report of MENTORS within 3 months
        //Handle the punishment for mentors
        await this.handleMentorSuspension(subscription, report);
        break;
      default:
        break;
    }
  }

  /* Method: Handle Mentor Suspension */
  private async handleMentorSuspension(subscription: SubscriptionGetPlayload, report: Report) {
    this.logger.log('🚀 ~ ReportService ~ handleMentorSuspension ~ subscriptionId:', subscription);

    const noOfReportMentors = await this.getResolvedMentorReportsCount(subscription.Course.creatorId);

    //Get resolved report of MENTORS within 3 months
    // If the number of reports is greater than or equal 5 and less than or equal 7, suspend the mentor for 3 days
    // If the number of reports is greater than 5 and less than 11, suspend the mentor for 7 days
    // If the number of reports is greater than greater than or equal 11, suspend the mentor permanently
    const suspensionType = ReportResolveHelper.calculateAccountSuspensionDays(noOfReportMentors);

    if (suspensionType !== AccountSuspensionType.ACCOUNT_NOT_SUSPENDED) {
      const course = await this.transactionHost.tx.course.findMany({
        where: { creatorId: subscription.Course.creatorId },
        select: { id: true },
      });

      for (const c of course) {
        await this.cancelAllRelatedSubscriptions(c.id, subscription.id, 'MENTOR');
      }
    }

    await this.suspendAccount(subscription.Course.creatorId, suspensionType);

    //Refund base on access time of mentors
    //If the access time of mentors contains more than 70% of the total duration of the course, refund 30% of the course fee
    //If the access time of mentors contains less than 70% of the total duration of the course, refund 50% of the course fee
    //If the access time of mentors contains less than 40% of the total duration of the course, refund 100% of the course fee
    await this.handleSubscriptionPaymentCut(subscription);

    const suspensionPayload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.MENTOR },
      subscription.Course.creatorId,
      NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER.get(suspensionType),
    );

    const resolveSubsriptionPayload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      report.reporterId,
      NotificationType.REPORT_RESOLVED,
    );

    runFunctionWithCondition(!!subscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, suspensionPayload);
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, resolveSubsriptionPayload);
    });
  }

  private async suspendAccount(accountId: number, suspensionType: AccountSuspensionType) {
    if (suspensionType === AccountSuspensionType.ACCOUNT_NOT_SUSPENDED) return;
    await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { status: AccountStatus.SUSPENSIVE, suspendedAt: nowEpoch(), suspensionType },
      select: { id: true },
    });
  }

  private async getResolvedMentorReportsCount(creatorId: number) {
    return this.transactionHost.tx.report.count({
      where: {
        Subscription: { Course: { creatorId } },
        status: ReportStatus.RESOLVED,
        type: ReportType.MENTOR_ISSUES,
        createdAt: { gte: nowEpoch() - REPORT_DURATION_TIME_QUERY },
      },
    });
  }

  /* Method: Handle Course Suspension */
  private async handleCourseSuspension(subscription: SubscriptionGetPlayload, report: Report) {
    this.logger.log('🚀 ~ ReportService ~ handleCourseSuspension ~ subscriptionId:', subscription);

    const noOfCourseReports = await this.getResolvedCourseReportsCount(subscription.Course.id);

    //Get resolved report of COURSES within 3 months
    // If the number of reports is greater than 3, suspend the mentor for 3 days
    // If the number of reports is greater than 5, suspend the mentor for 7 days
    // If the number of reports is greater than 7, suspend the mentor permanently
    const suspensionTypeCourse = ReportResolveHelper.calculateCourseSuspensionDays(noOfCourseReports);

    // Cancel all related subscriptions in active status relating to the course
    if (suspensionTypeCourse !== CourseSuspensionType.COURSE_NOT_SUSPENDED) {
      await this.cancelAllRelatedSubscriptions(subscription.Course.id, subscription.id, 'COURSE');
    }

    this.logger.log('🚀 ~ ReportService ~ handleCourseSuspension ~ suspensionTypeCourse:', suspensionTypeCourse);
    const suspendedCourse = await this.suspendCourse(subscription.Course.id, suspensionTypeCourse);

    //Refund base on access time of mentors
    //If the access time of mentors contains more than 70% of the total duration of the course, refund 30% of the course fee
    //If the access time of mentors contains less than 70% of the total duration of the course, refund 50% of the course fee
    //If the access time of mentors contains less than 40% of the total duration of the course, refund 100% of the course fee
    //TODO: Implement refund for the subscription

    await this.handleSubscriptionPaymentCut(subscription);

    const suspensionPayloadCourse = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.COURSE },
      subscription.Course.creatorId,
      NOTIFICATION_SUSPENSION_COURSE_MAPPER.get(suspensionTypeCourse),
    );

    const resolveSubsriptionPayloadCourse = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      NotificationType.REPORT_RESOLVED,
    );

    runFunctionWithCondition(!!suspendedCourse, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, suspensionPayloadCourse);
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, resolveSubsriptionPayloadCourse);
    });
  }

  private async cancelAllRelatedSubscriptions(courseId: number, suspendSubscriptionId: number, type: 'MENTOR' | 'COURSE') {
    const canceledSubscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { id: courseId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS } },
      select: { id: true, status: true, accountId: true, Payment: { select: { id: true } } },
    });

    for (const sub of canceledSubscriptions) {
      if (sub.id === suspendSubscriptionId) continue;

      const updatedAudioRoom = orUndefinedWithCondition(sub.status === SubscriptionStatus.ACTIVE, {
        AudioRoom: { update: { data: { status: RoomStatus.CANCELLED } } },
      });
      const updatedPayment = orUndefinedWithCondition(!!sub.Payment, {
        Payment: {
          update: {
            data: { status: sub.status === SubscriptionStatus.ACTIVE ? PaymentStatus.REFUNDED : PaymentStatus.CANCELED },
          },
        },
      });

      const updatedSub = await this.transactionHost.tx.subscription.update({
        where: { id: sub.id },
        data: {
          canceledAt: nowEpoch(),
          status: SubscriptionStatus.CANCELED,
          ...updatedAudioRoom,
          ...updatedPayment,
        },
        select: { id: true },
      });

      const notificationType =
        sub.status === SubscriptionStatus.ACTIVE
          ? type === 'MENTOR'
            ? NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION
            : NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION
          : type === 'MENTOR'
            ? NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION
            : NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION;

      const cancelSubPayload = NotificationHelper.makeAppNotificationPayload(
        { id: sub.id, type: NotificationRelationType.SUBSCRIPTION },
        sub.accountId,
        notificationType,
      );

      runFunctionWithCondition(!!updatedSub, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, cancelSubPayload);
      });
    }
  }

  private async suspendCourse(courseId: number, suspensionType: CourseSuspensionType) {
    if (suspensionType === CourseSuspensionType.COURSE_NOT_SUSPENDED) return;

    return this.transactionHost.tx.course.update({
      where: { id: courseId },
      data: { status: CourseStatus.SUSPENDED, suspendedAt: nowEpoch(), suspensionType },
      select: { id: true },
    });
  }

  private async getResolvedCourseReportsCount(courseId: number) {
    return this.transactionHost.tx.report.count({
      where: {
        Subscription: { Course: { id: courseId } },
        status: ReportStatus.RESOLVED,
        type: ReportType.COURSE_UNQUALIFIED,
        createdAt: { gte: nowEpoch() - REPORT_DURATION_TIME_QUERY },
      },
    });
  }

  /* Method: Handle Subscription Payment Cut */
  private async handleSubscriptionPaymentCut(subscription: SubscriptionGetPlayload) {
    const audioRoomHistories = (await this.transactionHost.tx.audioRoomActivityHistory.findMany({
      where: { AudioRoomParticipant: { accountId: subscription.Course.creatorId, roomId: subscription.audioRoomId } },
      orderBy: { joinedAt: SortOrder.DESC },
      select: { joinedAt: true, leftAt: true },
    })) as AudioRoomActivityHistory[];

    const totalTimeInAudioRoom = ReportResolveHelper.getTotalTimeInAudioRoom(audioRoomHistories);

    this.logger.log('🚀 ~ ReportService ~ handleSubscriptionPaymentCut ~ totalTimeInAudioRoom:', totalTimeInAudioRoom);

    await this.updateSubscriptionPaymentCut(subscription.id, totalTimeInAudioRoom, subscription.Course.totalDuration);
    //TODO: Implement NOTIFICATION
  }

  private async updateSubscriptionPaymentCut(subscriptionId: number, totalTimeInAudioRoom: number, totalDuration: number) {
    await this.transactionHost.tx.subscription.update({
      where: { id: subscriptionId },
      data: { wageStatus: ReportResolveHelper.calculatePaymentCut(totalTimeInAudioRoom, totalDuration) },
      select: { id: true },
    });
  }

  async createNotificationSubscriptionFeedback(report: Report, body: ReportResolveFeedbackREQ) {
    const isResolved = body.status === ReportStatus.RESOLVED;

    // notification receiver includes mentor (reporter) and feedback owner
    const reporterPayload = NotificationHelper.makeAppNotificationPayload(
      { id: report.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      isResolved ? NotificationType.REPORT_RESOLVED : NotificationType.REPORT_REJECTED,
    );

    if (isResolved) {
      const feeback = await this.transactionHost.tx.feedback.findUnique({
        where: { id: report.feedbackId },
        select: { id: true, reviewerId: true },
      });

      const feedbackPayload = NotificationHelper.makeAppNotificationPayload(
        { id: report.feedbackId, type: NotificationRelationType.FEEDBACK },
        report.reporterId,
        NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
      );

      this.logger.log('🚀 ~ ReportService ~ createNotificationReportFeedback ~ feedbackPayload created:', feedbackPayload);

      runFunctionWithCondition(!!feeback, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, feedbackPayload);
      });
    }

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, reporterPayload);
    });
  }

  async createNotificationReportFeedback(report: Report, body: ReportResolveFeedbackREQ) {
    const isResolved = body.status === ReportStatus.RESOLVED;

    // notification receiver includes mentor (reporter) and feedback owner
    const reporterPayload = NotificationHelper.makeAppNotificationPayload(
      { id: report.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      isResolved ? NotificationType.REPORT_RESOLVED : NotificationType.REPORT_REJECTED,
    );

    if (isResolved) {
      const feeback = await this.transactionHost.tx.feedback.findUnique({
        where: { id: report.feedbackId },
        select: { id: true, reviewerId: true },
      });

      const feedbackPayload = NotificationHelper.makeAppNotificationPayload(
        { id: report.feedbackId, type: NotificationRelationType.FEEDBACK },
        report.reporterId,
        NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
      );

      this.logger.log('🚀 ~ ReportService ~ createNotificationReportFeedback ~ feedbackPayload created:', feedbackPayload);

      runFunctionWithCondition(!!feeback, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, feedbackPayload);
      });
    }

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, reporterPayload);
    });
  }

  async createSubscriptionReport(user: AuthUserDTO, body: ReportClientSubscriptionCreateREQ) {
    let subscription: SubscriptionGetPlayload;
    if (!REPORT_SUBSCRIPTION_TYPE.includes(body.type)) {
      throw new ActionFailedException(
        ActionFailed.REPORT_INVALID_TYPE,
        `The type ${body.type} is invalid, the types are ${REPORT_SUBSCRIPTION_TYPE.join(', ')}`,
      );
    }

    try {
      subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow({
        where: { id: body.subscriptionId, accountId: user.accountId },
        select: { id: true, courseId: true },
      })) as SubscriptionGetPlayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);
    }

    const report = await this.transactionHost.tx.report.create(
      ReportCreateHelper.toCreate<ReportClientSubscriptionCreateREQ>(user, body),
    );

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      admin.id,
      ReportNotificationMap.get(body.type),
    );

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });
  }

  async createReportFeedback(user: AuthUserDTO, body: ReportClientFeedbackCreateREQ) {
    if (!REPORT_FEEDBACK_TYPE.includes(body.type)) {
      throw new ActionFailedException(
        ActionFailed.REPORT_INVALID_TYPE,
        `The type ${body.type} is invalid, the types are ${REPORT_FEEDBACK_TYPE.join(', ')}`,
      );
    }

    let feedback: FeedbackGetPayload;
    try {
      feedback = (await this.transactionHost.tx.feedback.findUniqueOrThrow({
        where: { id: body.feedbackId, reviewerId: user.accountId },
        select: { id: true },
      })) as FeedbackGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);
    }

    const report = await this.transactionHost.tx.report.create(
      ReportCreateHelper.toCreate<ReportClientFeedbackCreateREQ>(user, body),
    );

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: feedback.id, type: NotificationRelationType.FEEDBACK },
      admin.id,
      ReportNotificationMap.get(body.type),
    );

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });
  }
}
</file>

<file path="src/domains/student/client/student-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StudentClientController } from './student-client.controller';
import { StudentClientService } from './student-client.service';

describe('StudentClientController', () => {
  let controller: StudentClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [StudentClientController],
      providers: [StudentClientService],
    }).compile();

    controller = module.get<StudentClientController>(StudentClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/student/client/student-client.controller.ts">
import { Controller } from '@nestjs/common';
import { StudentClientService } from './student-client.service';

@Controller('student-client')
export class StudentClientController {
  constructor(private readonly studentClientService: StudentClientService) {}
}
</file>

<file path="src/domains/student/client/student-client.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from 'src/domains/auth/auth.module';
import { PrismaModule } from 'src/services/prisma/prisma.module';
import { StudentClientController } from './student-client.controller';
import { StudentClientService } from './student-client.service';

@Module({
  imports: [PrismaModule, AuthModule],
  controllers: [StudentClientController],
  providers: [StudentClientService],
})
export class StudentClientModule {}
</file>

<file path="src/domains/student/client/student-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StudentClientService } from './student-client.service';

describe('StudentClientService', () => {
  let service: StudentClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [StudentClientService],
    }).compile();

    service = module.get<StudentClientService>(StudentClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/student/client/student-client.service.ts">
import { Injectable } from '@nestjs/common';
import { AuthService } from 'src/domains/auth/auth.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';

@Injectable()
export class StudentClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly authService: AuthService,
  ) {}
}
</file>

<file path="src/domains/student/shared/types.ts">
import { Prisma } from '@prisma/client';

export type StudentGetPayload = Prisma.StudentGetPayload<{ include: { Account: true } }>;
</file>

<file path="src/domains/student/student.module.ts">
import { Module } from '@nestjs/common';
import { StudentClientModule } from './client/student-client.module';

@Module({
  imports: [StudentClientModule],
})
export class StudentModule {}
</file>

<file path="src/domains/subscription/client/subscription-client.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Put, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionClientService } from './subscription-client.service';

@Controller('client/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class SubscriptionClientController {
  constructor(private readonly subscriptionClientService: SubscriptionClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByAccount(req.user);

    return BaseResponse.of(subscriptions);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionClientService.getSubscriptionDetailWithAccount(
      req.user,
      id,
    );

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }

  @Patch(':id/cancel')
  @Roles(AccountType.STUDENT)
  async cancel(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.subscriptionClientService.cancel(req.user, id);

    return BaseResponse.ok();
  }

  @Get('mentors/:mentorId')
  @Roles(AccountType.STUDENT)
  async listByMentor(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByMentorId(mentorId);

    return BaseResponse.of(subscriptions);
  }

  @Post('courses/:courseId')
  @Roles(AccountType.STUDENT)
  async createSubscription(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: SubscriptionCreateREQ,
  ) {
    const subscription = await this.subscriptionClientService.create(req.user, courseId, body);

    return BaseResponse.of({ subscriptionId: subscription.id });
  }

  @Post(':id/payments')
  @Roles(AccountType.STUDENT)
  async createPayment(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) id: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.makePayment(req.user, id, {
      ...body,
      ipAddr: req.ip,
    });

    return BaseResponse.of(payment);
  }

  @Put(':id/payments')
  async continue(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) subscriptionId: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.continue(req.user, subscriptionId, { ...body, ipAddr: req.ip });

    return BaseResponse.of(payment);
  }

  @Patch('approvement')
  @Roles(AccountType.MENTOR)
  async approveSubscription(@Req() req: AuthRequestDTO, @Body() body: SubscriptionMentorApproveREQ) {
    const subscriptionId = await this.subscriptionClientService.approve(req.user, body);

    return BaseResponse.of({ subscriptionId: subscriptionId });
  }
}
</file>

<file path="src/domains/subscription/client/subscription-client.module.ts">
import { forwardRef, Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { AudioCallModule } from 'src/domains/audio-call/audio-call.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { PaymentClientModule } from 'src/domains/payment/client/payment-client.module';
import { SubscriptionClientController } from './subscription-client.controller';
import { SubscriptionClientService } from './subscription-client.service';

@Module({
  imports: [forwardRef(() => MentorClientModule), AccountModule, PaymentClientModule, AudioCallModule],
  controllers: [SubscriptionClientController],
  providers: [SubscriptionClientService],
  exports: [SubscriptionClientService],
})
export class SubscriptionClientModule {}
</file>

<file path="src/domains/subscription/client/subscription-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionClientService } from './subscription-client.service';

describe('SubscriptionClientService', () => {
  let service: SubscriptionClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionClientService],
    }).compile();

    service = module.get<SubscriptionClientService>(SubscriptionClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/client/subscription-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import {
  AccountType,
  Course,
  CourseStatus,
  NotificationRelationType,
  NotificationType,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AudioCallService } from 'src/domains/audio-call/audio-call.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { PaymentClientService } from 'src/domains/payment/client/payment-client.service';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { DAY_OF_WEEK } from 'src/shared/constants/date.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import {
  EXPIRED_PENDING_SUBSCRIPTION,
  EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
  SUBSCRIPTION_ACTIVE_STATUS,
  SUBSCRIPTION_NOT_CANCELED_STATUS,
  SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO,
} from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { getDayOfWeek, parseDateToHyphen, parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionListRESP } from '../dto/response/subscription-list.response';
import { SubscriptionCreateHelper } from '../helper/subcription-create.helper';
import { SubscriptionApproveHelper } from '../helper/subscription-approve.helper';
import { parseBookingDateTimeToEpoch } from '../helper/subscription-common.helper';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionClientService {
  private readonly logger = new Logger(SubscriptionClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
    private readonly audioCallService: AudioCallService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Cron('0 0 * * * *', {
    name: 'handle-expired-pending-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.PENDING },
      select: {
        mentorScheduleId: true,
        status: true,
        createdAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const createdAt = parseEpoch(subscription.createdAt);

        if (now - createdAt > EXPIRED_PENDING_SUBSCRIPTION) {
          this.logger.warn(
            `🚀 ~ SubscriptionClientService ~ Cron ~ handleExpiredSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because mentor not reponse after 2 days`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: { status: SubscriptionStatus.EXPIRED, canceledAt: nowEpoch() },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 * * * *', {
    name: 'handle-expired-paid-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredApprovedSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.ACCEPTED },
      select: {
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const approvedAt = parseEpoch(subscription.approvedAt);

        if (now - approvedAt > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
          this.logger.warn(
            `🚀 ~ SubscriptionClientService ~ Cron ~ handleExpiredApprovedSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because student not paid after 1 day`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.EXPIRED,
              Payment: { update: { status: PaymentStatus.EXPIRED } },
              canceledAt: nowEpoch(),
            },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 0 * * *', {
    name: 'handle-suspended-course-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleSuspendedCourseSubscription() {
    const courses = await this.transactionHost.tx.course.findMany({
      where: { status: CourseStatus.SUSPENDED, ...IS_ACTIVE_NESTED },
      select: { id: true, status: true },
    });

    await Promise.all(
      courses.map(async (course) => {
        const subscriptions = await this.transactionHost.tx.subscription.findMany({
          where: { courseId: course.id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
          select: { id: true, audioRoomId: true, Payment: { select: { id: true } } },
        });

        for (const subscription of subscriptions) {
          await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.CANCELED,
              canceledAt: nowEpoch(),
              AudioRoom: { update: { status: RoomStatus.FINISHED } },
              Payment: { update: { status: PaymentStatus.REFUNDED } },
            },
            select: { id: true },
          });

          //TODO: Refund money to student
        }
      }),
    );
  }

  async listSubscriptionByAccount(user: AuthUserDTO) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(SubscriptionListHelper.toFindManyWithAccount(user));

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData =
          user.accountType !== AccountType.MENTOR
            ? await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId)
            : null;

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );
  }

  async listSubscriptionByMentorId(mentorId: number) {
    const { mentor } = await this.mentorClientService.detail(mentorId);

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: mentor.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS } },
      select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true, status: true },
    });

    return subscriptions.map((subscription) => {
      return {
        id: subscription.id,
        status: subscription.status,
        courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
        courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      };
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, courseId: number, body: SubscriptionCreateREQ): Promise<any> {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, startDate: true, endDate: true, price: true, creatorId: true },
    })) as Course;

    const existedSubscriptions = (await this.transactionHost.tx.subscription.findMany(
      SubscriptionCreateHelper.toFindManyByAccountId(user.accountId),
    )) as SubscriptionGetPlayload[];

    // 1. Check for active subscription by the user for the same course
    const existedAccountSubscriptions = existedSubscriptions.filter((subscription) => subscription.Course.id === course.id);

    if (!isEmpty(existedAccountSubscriptions) && SUBSCRIPTION_ACTIVE_STATUS.includes(existedAccountSubscriptions[0]?.status)) {
      this.logger.error(`🚀 ~ SubscriptionClientService ~ create ~ there are same courses subscribed which are ACTIVE`);
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE);
    } else if (!isEmpty(existedAccountSubscriptions)) {
      //TODO: Uncomment this code when the feature is ready
      // const now = nowEpoch();
      // const lastSubscriptionInActive =
      //   parseEpoch(existedAccountSubscriptions[0].rejectedAt) || parseEpoch(existedAccountSubscriptions[0].canceledAt);
      //
      // const isStillBanned = now - lastSubscriptionInActive > EXPIRED_PENDING_SUBSCRIPTION;
      // if (lastSubscriptionInActive && isStillBanned) {
      //   this.logger.log(
      //     `🚀 ~ SubscriptionClientService ~ create ~ the user with account id ${user.accountId} can not subscribe to this course with course id ${course.id}`,
      //   );
      //   throw new ActionFailedException(ActionFailed.SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS);
      // }
    }

    // 2. Check for mentor schedule conflicts
    const schedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: body.mentorScheduleId, Mentor: { Account: { id: course.creatorId } } },
    });

    const conflictSchedule = await this.transactionHost.tx.subscription.findFirst({
      where: {
        status: { in: SUBSCRIPTION_ACTIVE_STATUS },
        mentorScheduleId: body.mentorScheduleId,
        courseAccessStartAt: parseBookingDateTimeToEpoch(body.date, schedule.startTime),
      },
      select: { id: true },
    });

    // Check if schedule is already booked
    if (conflictSchedule) {
      this.logger.error(
        `🚀 ~ SubscriptionClientService ~ create ~ This schedule has been booked with the subscription id ${conflictSchedule.id}`,
      );
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);
    }

    //3. Check for overlapping subscriptions with other mentors
    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const isNotMentorSubscriptionActive = existedSubscriptions.some((subscription) => {
      if (
        SUBSCRIPTION_ACTIVE_STATUS.includes(subscription.status) &&
        subscription.Course.creatorId !== course.creatorId &&
        Number(parseEpoch(subscription.courseAccessStartAt)) === courseAccessStartAt
      ) {
        this.logger.error(
          `🚀 ~ SubscriptionClientService ~ isNotMentorSubscriptionActive ~ This subscription has been scheduled overlap with the subscription id ${subscription.id} and the course id ${subscription.Course.id}`,
        );
        return true;
      }
    });

    if (isNotMentorSubscriptionActive) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE);
    }

    const parsedDate = parseDateToHyphen(body.date);
    const dayOfWeek = getDayOfWeek(parsedDate);
    this.logger.log(`🚀 ~ SubscriptionClientService ~ create ~ the date ${body.date} is ${DAY_OF_WEEK[dayOfWeek]}`);
    this.logger.log(`🚀 ~ SubscriptionClientService ~ create ~ the schedule day is ${schedule.dayOfWeek}`);

    if (schedule.dayOfWeek !== DAY_OF_WEEK[dayOfWeek]) {
      throw new ActionFailedException(
        ActionFailed.MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK,
        `the schedule day is ${schedule.dayOfWeek} but you choose ${DAY_OF_WEEK[dayOfWeek]}`,
      );
    }

    const subscription = await this.transactionHost.tx.subscription.create(
      SubscriptionCreateHelper.toCreate(user, course, schedule, body),
    );

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      course.creatorId,
      NotificationType.SUBSCRIPTION_CREATED,
    );
    runFunctionWithCondition(!!subscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return subscription;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async approve(courseCreator: AuthUserDTO, body: SubscriptionMentorApproveREQ) {
    await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      select: { id: true },
    });

    const updatedSubscription = await this.transactionHost.tx.subscription.update(
      SubscriptionApproveHelper.toApprove(body, courseCreator),
    );

    //Notification: send notification to student
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
      updatedSubscription.accountId,
      body.isApproved ? NotificationType.SUBSCRIPTION_APPROVED : NotificationType.SUBSCRIPTION_REJECTED,
    );
    runFunctionWithCondition(!!updatedSubscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedSubscription.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async makePayment(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { originalPrice: true, status: true, accountId: true },
    })) as SubscriptionGetPlayload;

    if (subscription.status !== SubscriptionStatus.ACCEPTED)
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_MAKE_PAYMENT,
        `Subscription status is ${subscription.status}`,
      );

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const { payment, url } = await this.paymentClientService.create(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  async continue(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { id: true, originalPrice: true, status: true, accountId: true, approvedAt: true },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const now = nowEpoch();
    if (
      now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED ||
      subscription.status === SubscriptionStatus.EXPIRED
    ) {
      this.logger.warn(
        `🚀 ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      // throw new ActionFailedException(ActionFailed.SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT);
    } else if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    const { payment, url } = await this.paymentClientService.continue(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancel(user: AuthUserDTO, subscriptionId: number) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: {
        status: true,
        accountId: true,
        mentorScheduleId: true,
        audioRoomId: true,
        Course: { select: { creatorId: true } },
      },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    if (SUBSCRIPTION_NOT_CANCELED_STATUS.includes(subscription.status)) {
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_CANCEL,
        `Subscription status in ${SUBSCRIPTION_NOT_CANCELED_STATUS} can not be canceled`,
      );
    }

    if (SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO.includes(subscription.status)) {
      await this.audioCallService.cancelCall(subscription.audioRoomId);
    }

    await this.transactionHost.tx.subscription.update({
      where: { id: subscriptionId },
      data: {
        status: subscription.status === SubscriptionStatus.ACTIVE ? SubscriptionStatus.ENDED : SubscriptionStatus.CANCELED,
        canceledAt: nowEpoch(),
      },
    });
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetailWithAccount(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    if (subscription.Account.id !== user.accountId && user.accountType === AccountType.STUDENT) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);
    } else if (subscription.Course.creatorId !== user.accountId && user.accountType === AccountType.MENTOR) {
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    return { subscription, mentorData, studentInfo };
  }

  async detail(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/dto/request/subscription-admin-list.request.ts">
import { SubscriptionStatus, WageStatus } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';

export class SubscriptionAdminListREQ extends PaginationREQ {
  @NameValidator()
  @IsOptional()
  mentorName?: string;

  @NameValidator()
  @IsOptional()
  courseName?: string;

  @NameValidator()
  @IsOptional()
  studentName?: string;

  @IsEnum(SubscriptionStatus)
  @IsOptional()
  status?: SubscriptionStatus;

  @IsEnum(WageStatus)
  @IsOptional()
  wageStatus?: WageStatus;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-create.request.ts">
import { IsOptional, IsString, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class SubscriptionCreateREQ {
  @OnlyDate()
  date: string;

  @IdValidator()
  mentorScheduleId: number;

  @IsString()
  @MaxLength(500)
  message: string;

  @IsString()
  @IsOptional()
  ipAddr: string;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-mentor-approve.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class SubscriptionMentorApproveREQ {
  @IdValidator()
  subscriptionId: number;

  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-payment-create.ts">
import { IsOptional, IsString } from 'class-validator';

export class SubscriptionPaymentCreateREQ {
  @IsString()
  message: string;

  @IsString()
  @IsOptional()
  ipAddr?: string;
}
</file>

<file path="src/domains/subscription/dto/response/subscription-admin-list.response.ts">
import { SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { SubscriptionMentorListRESP } from '../../shared/types';

export class SubscriptionAdminListRESP {
  id: string;
  status: SubscriptionStatus;
  wageStatus: SubscriptionStatus;
  originalPrice: number;
  courseAccessStartAt: Date;
  courseAccessEndAt: Date;
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  course: { id: number; name: string };

  static fromEntity(
    subscription: any,
    studentInfo: AccountRESP,
    mentorInfo: SubscriptionMentorListRESP,
  ): SubscriptionAdminListRESP {
    return {
      id: subscription.id,
      status: subscription.status,
      wageStatus: subscription.wageStatus,
      originalPrice: subscription.originalPrice,
      courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      course: { id: subscription.Course.id, name: subscription.Course.name },
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-detail.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus, WageStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionGetPlayload, SubscriptionReportRESP } from '../../shared/types';

export class SubscriptionDetailRESP {
  id: number;
  status: SubscriptionStatus;
  wageStatus: WageStatus;
  orginalPrice: number;
  message: string;
  courseAccessStartAt: number;
  courseAccessEndAt: number;
  course: Pick<CourseClientDetailRESP, 'id' | 'name' | 'status' | 'description'>;
  mentor: Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
  student: AccountRESP;
  audiCall?: { status: RoomStatus; cid: string };
  report?: SubscriptionReportRESP;
  payment?: { status: PaymentStatus; price: number };

  static fromEntity(
    e: SubscriptionGetPlayload,
    mentor: MentorGetPayload,
    student: AccountRESP,
    thumbnail?: ImageRESP,
  ): SubscriptionDetailRESP {
    return {
      id: e.id,
      status: e.status,
      wageStatus: e.wageStatus,
      orginalPrice: parseDecimalNumber(e.originalPrice),
      message: e.message,
      courseAccessStartAt: parseEpoch(e.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(e.courseAccessEndAt),
      course: { id: e.Course.id, name: e.Course.name, status: e.Course.status, description: e.Course.description },
      mentor: { id: mentor.id, accountId: mentor.accountId, name: mentor.Account.name, thumbnail: thumbnail },
      payment: orNullWithCondition(!!e.Payment, {
        status: e.Payment?.status,
        price: parseDecimalNumber(e.Payment?.price),
      }),
      audiCall: orNullWithCondition(!!e.AudioRoom, {
        status: e.AudioRoom?.status,
        cid: e.AudioRoom?.cid,
      }),
      report: orNullWithCondition(!!e.Report, {
        id: e.Report?.id,
        type: e.Report?.type,
        description: e.Report?.description,
        status: e.Report?.status,
        resolution: e.Report?.resolution,
      }),
      student: student,
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-list.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import {
  SubscriptionFeedbackRESP,
  SubscriptionGetPlayload,
  SubscriptionMentorListRESP,
  SubscriptionReportRESP,
} from '../../shared/types';

export class SubscriptionListRESP {
  id: number;
  status: SubscriptionStatus;
  originalPrice: number;
  courseStartAt: string;
  courseEndAt: string;
  course: { id: number; name: string };
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  audiCall: { status: RoomStatus; cid: string };
  payment?: { id: true; status: PaymentStatus; price: number };
  feedback?: SubscriptionFeedbackRESP;
  report?: SubscriptionReportRESP;
  canceledAt?: string;
  approvedAt?: string;
  rejectedAt?: string;

  static fromEntity(
    subcription: SubscriptionGetPlayload,
    studentInfo: AccountRESP,
    audiCall: { status: RoomStatus; cid: string },
    mentorInfo?: SubscriptionMentorListRESP,
  ): SubscriptionListRESP {
    return {
      id: subcription.id,
      status: subcription.status,
      originalPrice: parseDecimalNumber(subcription.originalPrice),
      courseStartAt: parseEpoch(subcription.courseAccessStartAt),
      courseEndAt: parseEpoch(subcription.courseAccessEndAt),
      canceledAt: parseEpoch(subcription.canceledAt),
      approvedAt: parseEpoch(subcription.approvedAt),
      rejectedAt: parseEpoch(subcription.rejectedAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      report: orNullWithCondition(!!subcription.Report, {
        id: subcription.Report?.id,
        type: subcription.Report?.type,
        description: subcription.Report?.description,
        status: subcription.Report?.status,
        resolution: subcription.Report?.resolution,
      }),
      course: { id: subcription.Course.id, name: subcription.Course.name },
      audiCall: audiCall,
      payment: orNullWithCondition(!!subcription.Payment, {
        id: subcription.Payment?.id,
        status: subcription.Payment?.status,
        price: parseDecimalNumber(subcription.Payment?.price),
      }),
      feedback: orNullWithCondition(!!subcription.Feedback, {
        id: subcription.Feedback?.id,
        courseRating: subcription.Feedback?.courseRating,
        mentorRating: subcription.Feedback?.mentorRating,
        courseReview: subcription.Feedback?.courseReview,
        mentorReview: subcription.Feedback?.mentorReview,
      }),
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subcription-create.helper.ts">
import {
  Course,
  MentorSchedule,
  NotificationRelationType,
  NotificationScope,
  NotificationType,
  Prisma,
  Subscription,
  SubscriptionStatus,
} from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { NotificationAppHandlerPayload } from 'src/domains/notification/shared/types';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { parseBookingDateTimeToEpoch } from './subscription-common.helper';

export class SubscriptionCreateHelper {
  static toCreate(
    user: AuthUserDTO,
    course: Course,
    schedule: MentorSchedule,
    body: SubscriptionCreateREQ,
  ): Prisma.SubscriptionCreateArgs {
    if (!course) return;

    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const courseAccessEndAt = parseBookingDateTimeToEpoch(body.date, schedule.endTime);

    return {
      data: {
        message: body.message,
        originalPrice: course.price,
        status: SubscriptionStatus.PENDING,
        courseAccessEndAt: courseAccessEndAt,
        courseAccessStartAt: courseAccessStartAt,
        Course: connectRelation(course.id),
        Account: connectRelation(user.accountId),
        MentorSchedule: connectRelation(body.mentorScheduleId),
      },
      select: { id: true },
    };
  }

  static toFindMany(courseId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Course: { id: courseId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toFindManyByAccountId(accountId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Account: { id: accountId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true } },
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toCreateNotification(subcription: Subscription, targetAccountId: number): NotificationAppHandlerPayload {
    return {
      notificationREQ: {
        relationId: subcription.id,
        relationType: NotificationRelationType.SUBSCRIPTION,
        type: NotificationType.SUBSCRIPTION_CREATED,
        scopes: [NotificationScope.INDIVIDUAL],
        targetAccountId: targetAccountId,
      },
      data: {
        title: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).title,
        topic: NotificationType.SUBSCRIPTION_CREATED,
        body: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).content,
      },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-approve.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';

export class SubscriptionApproveHelper {
  static toApprove(body: SubscriptionMentorApproveREQ, courseCreator: AuthUserDTO): Prisma.SubscriptionUpdateArgs {
    const timeUpdate = body.isApproved ? { approvedAt: nowEpoch() } : { rejectedAt: nowEpoch() };

    return {
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      data: {
        status: body.isApproved ? SubscriptionStatus.ACCEPTED : SubscriptionStatus.REJECTED,
        ...timeUpdate,
      },
      select: { id: true, accountId: true, status: true },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-common.helper.ts">
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseDateTimeToEpochV2 } from 'src/shared/parsers/datetime.parse';

export const parseBookingDateTimeToEpoch = (date: string, time: string) => {
  const [day, month, year] = date.split('/');
  const [hour, minute] = time.split(':');

  if (!time) throw new ActionFailedException(ActionFailed.DATE_TIME_INVALID);

  const dateAfterParse = new Date(`${year}-${month}-${day}T${hour}:${minute}:00.00Z`);

  const epoch = parseDateTimeToEpochV2(dateAfterParse.toISOString());

  const now = Date.now();

  if (epoch < now) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW);

  return epoch;
};

export const compareDateFromEpoch = (epoch1: number, epoch2: number) => {
  const date1 = new Date(epoch1);
  const date2 = new Date(epoch2);

  return (
    date1.getDate() === date2.getDate() && date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear()
  );
};
</file>

<file path="src/domains/subscription/helper/subscription-detail.helper.ts">
import { AccountType, Prisma, ReportStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class SubscriptionDetailHelper {
  static toFindUnique(subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: { select: { id: true, type: true, description: true, status: true, resolution: true } },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindUniqueWithAccount(user: AuthUserDTO, subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true },
        },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindByAccount(user: AuthUserDTO, id: number): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT:
        return {
          accountId: user.accountId,
          id: id,
        };

      case AccountType.MENTOR:
        return {
          Course: {
            creatorId: user.accountId,
          },
          id: id,
        };
      case AccountType.ADMIN:
        return {};
      default:
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-list.helper.ts">
import { AccountType, Prisma, ReportStatus } from '.prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';

export class SubscriptionListHelper {
  static toFindMany(): Prisma.SubscriptionFindManyArgs {
    return {
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: SubscriptionListHelper.toFilterByAccount(user),
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        canceledAt: true,
        approvedAt: true,
        rejectedAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true, createdAt: true },
        },
        Feedback: { select: { id: true, courseRating: true, mentorRating: true, courseReview: true, mentorReview: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = SubscriptionListHelper.toFilterByCondition(query);
    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: defaultSortDesc,
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Account: { select: { id: true, name: true } },
        Course: { select: { id: true, name: true, Creator: { select: { id: true, name: true } } } },
      },
    };
  }

  static toFilterByCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs['where'] {
    const studentName = orUndefinedWithCondition(!!query.studentName, {
      Account: parsePrismaSearch('name', query.studentName),
    });

    const mentorName = orUndefinedWithCondition(!!query.mentorName, {
      Course: {
        Creator: parsePrismaSearch('name', query.mentorName),
      },
    });

    const courseName = orUndefinedWithCondition(!!query.courseName, {
      Course: parsePrismaSearch('name', query.courseName),
    });

    return leanObject({
      ...studentName,
      ...mentorName,
      ...courseName,
      status: query.status,
      wageStatus: query.wageStatus,
    });
  }

  static toFilterByAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT: {
        return { accountId: user.accountId };
      }
      case AccountType.MENTOR: {
        return {
          Course: { creatorId: user.accountId },
        };
      }
      default:
        return;
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-make-payment.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { Nil } from 'src/shared/generics/type.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';

export class SubscriptionMakePaymentHelper {
  static toActivate(
    subscriptionId: number,
    subscriptionStatus: SubscriptionStatus,
    callId: number,
  ): Prisma.SubscriptionUpdateArgs {
    const audioRoom = orUndefinedWithCondition(subscriptionStatus === SubscriptionStatus.ACTIVE, {
      AudioRoom: connectRelation(callId),
    });

    return {
      where: { id: subscriptionId },
      data: { status: subscriptionStatus, ...audioRoom },
      select: { id: true },
    };
  }

  static parseAudioCallStartsAt(epoch: Nil<number>): string {
    if (!epoch) return;
    const [year, month, day, hour, minute, second] = parseEpochToDate(epoch)
      .split(/[-:\s]/)
      .map((value) => parseInt(value, 10));

    console.log(year, month, day, hour, minute, second); // Output: 2024 12 16 19 0 0

    // parse date time in this format DD/MM/YY to YYYY-MM-dd
    const parsedDate = `${day}/${month}/${year} ${hour}:${minute}:${second}`;
    return parsedDate;
  }
}
</file>

<file path="src/domains/subscription/shared/types.ts">
import { Prisma } from '@prisma/client';
import { FeedbackListRESP } from 'src/domains/feedback/response/feedback-list.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { ReportDetailRESP } from 'src/domains/report/response/report-detail.response';

export type SubscriptionGetPlayload = Prisma.SubscriptionGetPayload<{
  include: { Course: true; Account: true; Payment: true; AudioRoom: true; Feedback: true; Report: true };
}>;

export type SubscriptionMentorListRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;

export type SubscriptionFeedbackRESP = Pick<
  FeedbackListRESP,
  'id' | 'courseRating' | 'mentorRating' | 'courseReview' | 'mentorReview'
>;

export type SubscriptionReportRESP = Pick<ReportDetailRESP, 'id' | 'type' | 'description' | 'status' | 'resolution'>;
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminController', () => {
  let controller: SubscriptionAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SubscriptionAdminController],
      providers: [SubscriptionAdminService],
    }).compile();

    controller = module.get<SubscriptionAdminController>(SubscriptionAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionAdminService } from './subscription-admin.service';

@Controller('admin/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class SubscriptionAdminController {
  constructor(private readonly subscriptionAdminService: SubscriptionAdminService) {}

  @Get()
  async listSubscription(@Query() query: SubscriptionAdminListREQ) {
    const { subscriptionDtos, count } = await this.subscriptionAdminService.listSubscription(query);

    return PaginationResponse.ofWithTotal(subscriptionDtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionAdminService.getSubscriptionDetail(id);

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }
}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

@Module({
  imports: [AccountModule, MentorClientModule],
  controllers: [SubscriptionAdminController],
  providers: [SubscriptionAdminService],
})
export class SubscriptionAdminModule {}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminService', () => {
  let service: SubscriptionAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionAdminService],
    }).compile();

    service = module.get<SubscriptionAdminService>(SubscriptionAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionAdminListRESP } from '../dto/response/subscription-admin-list.response';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionAdminService {
  private readonly logger = new Logger(SubscriptionAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    // private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
  ) {}

  async listSubscription(query: SubscriptionAdminListREQ) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      SubscriptionListHelper.toFindManyWithCondition(query),
    );

    const count = await this.transactionHost.tx.subscription.count({
      where: SubscriptionListHelper.toFilterByCondition(query),
    });

    const subscriptionDtos = await Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);

        return SubscriptionAdminListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );

    return { subscriptionDtos, count };
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetail(subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUnique(subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/subscription.module.ts">
import { Module } from '@nestjs/common';
import { SubscriptionClientModule } from './client/subscription-client.module';
import { SubscriptionAdminModule } from './subscription-admin/subscription-admin.module';

@Module({
  imports: [SubscriptionClientModule, SubscriptionAdminModule],
})
export class SubscriptionModule {}
</file>

<file path="src/domains/utility/request/utility-enum.request.ts">
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsNotEmpty, IsString } from 'class-validator';

export class UtilityEnumREQ {
  @IsString({
    each: true,
  })
  @IsNotEmpty({
    each: true,
  })
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @ApiPropertyOptional({
    type: [String],
    description: 'List of keys to get',
    example: ['SortOrder', 'AccountType', 'ActionFailed'],
  })
  keys: string[] = [];
}
</file>

<file path="src/domains/utility/utility.controller.ts">
import { Controller, Get, Query } from '@nestjs/common';

import { ApiResponse, ApiTags } from '@nestjs/swagger';
import { UtilityEnumREQ } from './request/utility-enum.request';
import { UtilityService } from './utility.service';

@Controller('utilities')
@ApiTags('Utilities')
export class UtilityController {
  constructor(private readonly utilityService: UtilityService) {}

  @Get('enums')
  @ApiResponse({
    status: 200,
    description: 'Get all enums',
    example: {
      data: {
        SortOrder: ['asc', 'desc'],
        AccountType: ['STUDENT', 'MENTOR', 'ADMIN'],
        ActionFailed: ['ACCOUNT_NOT_FOUND', 'INCORRECT_PASSWORD', 'AUTH_PHONE_EXISTED', 'AUTH_EMAIL_EXISTED'],
      },
      message: 'OK',
    },
  })
  findAll(@Query() body: UtilityEnumREQ) {
    return this.utilityService.findAll(body);
  }
}
</file>

<file path="src/domains/utility/utility.module.ts">
import { Module } from '@nestjs/common';
import { UtilityController } from './utility.controller';
import { UtilityService } from './utility.service';

@Module({
  controllers: [UtilityController],
  providers: [UtilityService],
})
export class UtilityModule {}
</file>

<file path="src/domains/utility/utility.service.ts">
import { Injectable, UnprocessableEntityException } from '@nestjs/common';
import { $Enums } from '@prisma/client';
import { SortOrder } from 'src/shared/enums/query.enum';
import { BaseResponse } from 'src/shared/generics/base.response';

import { ActionFailed } from 'src/shared/exceptions/action-failed.exception';
import { MentorAdminListSortableFields } from '../mentor/shared/enums';
import { UtilityEnumREQ } from './request/utility-enum.request';

@Injectable()
export class UtilityService {
  constructor() {}

  private readonly additionEnums = {
    SortOrder: SortOrder,
    ...$Enums,
    ActionFailed: ActionFailed,
    MentorAdminListSortableFields: MentorAdminListSortableFields,
  };
  findAll(body: UtilityEnumREQ) {
    const response: { [key: string]: object } = {};
    if (body.keys.length === 0) {
      Object.keys(this.additionEnums).forEach((k) => (response[k] = Object.values(this.additionEnums[k])));
    } else
      body.keys.forEach((k) => {
        const value = this.additionEnums[k];
        if (!value) throw new UnprocessableEntityException(`Key: ${k} doesn't not exist`);
        response[k] = value;
      });
    return BaseResponse.of(response);
  }
}
</file>

<file path="src/interceptors/logging.interceptor.ts">
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import chalk from 'chalk';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

/**
 * Logger Interceptor.
 * Creates informative logs to all requests, showing the path and
 * the method name.
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const parentType = chalk.hex('#5f02f5').bold(`${context.getArgs()[0].route.path}`);
    const fieldName = chalk.hex('#2ec8f2').bold(`${context.getArgs()[0].route.stack[0].method}`);
    return next.handle().pipe(
      tap(() => {
        Logger.debug(`${parentType} » ${fieldName}`, 'RESTful');
      }),
    );
  }
}
</file>

<file path="src/interceptors/prisma-exception.interceptor.ts">
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import {
  PrismaClientInitializationError,
  PrismaClientKnownRequestError,
  PrismaClientRustPanicError,
  PrismaClientUnknownRequestError,
  PrismaClientValidationError,
} from '@prisma/client/runtime/library';
import { Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { EntityNotFoundException } from 'src/shared/exceptions/entity-not-found.exception';
import { KeyDuplicationException } from 'src/shared/exceptions/key-duplication.exception';
import { PrismaClientValidationException } from 'src/shared/exceptions/prisma-client-validation.exception';
import { RelationViolationException } from 'src/shared/exceptions/relation-violation.request';
import { WriteRelationNotFoundException } from 'src/shared/exceptions/write-relation-not-found.exception';
import { DatabaseConnectionException } from '../shared/exceptions/database-connnection.exception';
import { UnknownPrismaException } from '../shared/exceptions/unknown-prisma.exception';

@Injectable()
export class PrismaExceptionInterceptor implements NestInterceptor {
  private readonly logger = new Logger(PrismaExceptionInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      catchError((error) => {
        console.log('🚀 ~ PrismaExceptionInterceptor ~ catchError ~ error:', error);
        this.logger.error('PrismaExceptionInterceptor:', error);

        if (error instanceof PrismaClientValidationError) {
          throw new PrismaClientValidationException(error.message);
        } else if (error instanceof PrismaClientKnownRequestError) {
          switch (error.code) {
            case 'P2002':
              throw new KeyDuplicationException(error.meta.modelName as string, `${error.meta.target}` as string);
            case 'P2025':
              if (
                ['record to update', 'relation'].some((p) =>
                  error.meta?.cause?.toString().toLowerCase().includes(p.toLowerCase()),
                )
              ) {
                throw new WriteRelationNotFoundException(null, error.meta.modelName as string, error.meta.cause as string);
              }
              throw new EntityNotFoundException(undefined, error.message);
            case 'P2017':
              if (error.meta.relation_name) {
                throw new WriteRelationNotFoundException(
                  undefined,
                  error.meta.modelName as string,
                  `No relation between ${error.meta.parent_name} & ${error.meta.child_name}`,
                );
              }
              break;
            case 'P2014':
              if (error.meta.relation_name) {
                throw new RelationViolationException(
                  String(error.meta?.relation_name),
                  String(error.meta?.model_a_name),
                  String(error.meta?.model_b_name),
                );
              }
              break;
            // Handle additional known error codes here
            default:
              throw new UnknownPrismaException(error.message);
          }
        } else if (error instanceof PrismaClientUnknownRequestError) {
          throw new UnknownPrismaException(error.message);
        } else if (error instanceof PrismaClientInitializationError) {
          throw new DatabaseConnectionException(error.message);
        } else if (error instanceof PrismaClientRustPanicError) {
          throw new DatabaseConnectionException('The database encountered an unexpected panic.');
        }

        // If it's not a known Prisma error, rethrow it
        throw error;
      }),
    );
  }
}
</file>

<file path="src/middlewares/http-exception.middlewave.ts">
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus, Logger } from '@nestjs/common';
import { Response } from 'express';
import { NODE_ENV } from 'src/app.config';

@Catch(HttpException)
export class HttpExceptionMiddleware implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionMiddleware.name);

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const message = this.getErrorMessage(exception.getStatus(), exception.getResponse());
    const name: string = exception.name || 'HttpException';
    const statusCode = exception.getStatus();

    if (
      [
        HttpStatus.UNPROCESSABLE_ENTITY,
        HttpStatus.BAD_REQUEST,
        HttpStatus.CONFLICT,
        HttpStatus.UNAUTHORIZED,
        HttpStatus.FORBIDDEN,
      ].includes(statusCode)
    ) {
      // Log nothing
    } else this.logger.error(message, exception.stack);

    response.status(exception.getStatus()).json({
      name,
      message,
      statusCode,
      data: (exception as any).response,
      path: request.url,
      timestamp: new Date().toISOString(),
      error: (exception as any).error,
      stack: NODE_ENV === 'production' ? '🧌' : exception.stack,
    });
  }

  private getErrorMessage(httpStatus: number, errorResponse: string | object): string | { [key: string]: any } {
    if (httpStatus === HttpStatus.UNPROCESSABLE_ENTITY && typeof errorResponse === 'object' && 'message' in errorResponse)
      return errorResponse.message;
    else if (typeof errorResponse === 'string') return errorResponse;
    else if ('message' in errorResponse) return errorResponse.message;
    else return 'Server Error';
  }
}
</file>

<file path="src/middlewares/socket-auth.middleware.ts">
import { Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Socket } from 'socket.io';
import { AuthJwtPayloadDTO } from 'src/domains/auth/dto/auth-jwt-payload.dto';

export interface AuthSocket extends Socket {
  payload: AuthJwtPayloadDTO;
}
export type SocketMiddleware = (socket: AuthSocket, next: (err?: Error) => void) => void;

export const SocketAuthMiddleware = (jwtService: JwtService, logger: Logger): SocketMiddleware => {
  return (client, next) => {
    try {
      const authorization =
        client.handshake.auth.token || client.handshake.headers['token'] || client.handshake.headers.authorization;
      const jwtPayload = jwtService.verify(authorization ?? '') as AuthJwtPayloadDTO;

      logger.log('🚀 ~ return ~ authorization:', authorization);

      if (jwtPayload) {
        logger.log('🚀 ~ return ~ jwtPayload:', jwtPayload);
        client.payload = jwtPayload;
        next();
      } else {
        next({
          name: 'Unauthorizaed',
          message: 'Unauthorizaed',
        });
      }
    } catch (error) {
      next({
        name: 'Unauthorizaed',
        message: 'Unauthorizaed',
      });
    }
  };
};
</file>

<file path="src/pipes/validation-array.pipe.ts">
import { HttpException, HttpStatus, Injectable, PipeTransform } from '@nestjs/common';
import { plainToClass } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class ParseArrayPipe implements PipeTransform<any> {
  constructor(private readonly type?: any) {}

  async transform(value: any, metadata: any) {
    if (!Array.isArray(value)) {
      throw new HttpException('Invalid input', HttpStatus.BAD_REQUEST);
    }

    const { metatype } = metadata;
    const parsedArray = [];

    for (const item of value) {
      const object = plainToClass(this.type || metatype, item);
      const errors = await validate(object);

      if (errors.length > 0) {
        const message = errors.map((error) => Object.values(error.constraints)).join(', ');
        throw new HttpException(message, HttpStatus.BAD_REQUEST);
      }

      parsedArray.push(object);
    }

    return parsedArray;
  }
}
</file>

<file path="src/pipes/validation-custom.pipe.ts">
import { HttpStatus, UnprocessableEntityException, ValidationPipe } from '@nestjs/common';
import { ValidationError } from 'class-validator';

export class ValidationCustomPipe {
  static compactVersion() {
    return new ValidationPipe({ whitelist: true, errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY });
  }

  static extendVersion() {
    return new ValidationPipe({
      whitelist: true,
      errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,
      exceptionFactory: (validationErrors: ValidationError[] = []) => {
        type MyError = { field: string; errors: string[] | MyError[] };
        function parseError(error: ValidationError, parentName = ''): MyError {
          const fieldName = parentName ? [parentName, error.property].join('.') : error.property;
          if (error.children.length === 0) return { field: fieldName, errors: Object.values(error.constraints) };
          return {
            field: fieldName,
            errors: error.children.map((e) => parseError(e, fieldName)),
          };
        }
        return new UnprocessableEntityException(validationErrors.map((e) => parseError(e)));
      },
    });
  }
}
</file>

<file path="src/pipes/validation.pipe.ts">
import { HttpException, HttpStatus, Injectable, PipeTransform } from '@nestjs/common';
import { instanceToPlain, plainToInstance } from 'class-transformer';
import { ValidationError, validate, validateOrReject } from 'class-validator';
@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, metadata: any) {
    const { metatype } = metadata;
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }

    try {
      const object = plainToInstance(metatype, value);
      await validateOrReject(object);

      await this.validateNestedDTOs(object);

      const plainObject = instanceToPlain(object, { excludeExtraneousValues: false });
      return plainObject;
    } catch (errors) {
      if (errors instanceof Array && errors.every((error) => error instanceof ValidationError)) {
        // const message = errors.map((error: ValidationError) => Object.values(error.constraints)).join(', ');
        const message = errors.map((error: ValidationError) => ({
          name: error.property,
          errors: Object.values(error.constraints),
        }));

        throw new HttpException(
          Object.values(message).reduce((prev, cur) => {
            return {
              ...prev,
              [cur.name]: cur.errors,
            };
          }, {}),
          HttpStatus.UNPROCESSABLE_ENTITY,
        );
      } else {
        throw new HttpException('Validation failed.', HttpStatus.BAD_REQUEST);
      }
    }
  }

  private async validateNestedDTOs(object: any) {
    const properties = Object.getOwnPropertyNames(object);
    for (const property of properties) {
      const propertyValue = object[property];
      if (propertyValue && typeof propertyValue === 'object' && !Array.isArray(propertyValue)) {
        const nestedMetatype = (Reflect as any).getMetadata('design:type', object, property);
        if (this.toValidate(nestedMetatype)) {
          await validate(propertyValue).then((errors) => {
            if (errors.length > 0) {
              throw errors;
            }
          });
          await this.validateNestedDTOs(propertyValue);
        }
      }
    }
  }

  private toValidate(metaType: any): boolean {
    const types: any[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metaType);
  }
}
</file>

<file path="src/services/axios/axios.module.ts">
import { HttpModule } from '@nestjs/axios';
import { DynamicModule, Module } from '@nestjs/common';
import { AXIOS_CONFIG } from 'src/shared/constants/common.constant';
import { AxiosService } from './axios.service';

@Module({
  imports: [HttpModule],
})
export class AxiosModule {
  static register(options: { apiDomain: string }): DynamicModule {
    return {
      module: AxiosModule,
      providers: [
        {
          provide: AXIOS_CONFIG,
          useValue: options,
        },
        AxiosService,
      ],
      exports: [AxiosService],
    };
  }
}
</file>

<file path="src/services/axios/axios.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AxiosService } from './axios.service';

describe('AxiosService', () => {
  let service: AxiosService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AxiosService],
    }).compile();

    service = module.get<AxiosService>(AxiosService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/axios/axios.service.ts">
import { HttpService } from '@nestjs/axios';
import { Inject, Injectable } from '@nestjs/common';
import { lastValueFrom } from 'rxjs';
import { AXIOS_CONFIG } from 'src/shared/constants/common.constant';

@Injectable()
export class AxiosService {
  constructor(
    @Inject(AXIOS_CONFIG) private readonly options: { apiDomain: string },
    private readonly httpService: HttpService,
  ) {}

  async post<T>(headers: { [key: string]: string }, path: string, body: any): Promise<T> {
    try {
      const response = await lastValueFrom(
        this.httpService.post<T>(this.options.apiDomain + path, body, {
          headers: {
            ...headers,
            'Content-Type': 'application/json',
          },
        }),
      );
      return response.data as T;
    } catch (error) {
      console.log('🚀 ~ AxiosService ~ error:', error);
      //   if (error instanceof AxiosError) {
      //     throw new PayosPaymentsException(error.response.data as PayosErrorResponse, error.response.status);
      //   }
      throw error;
    }
  }

  async get<T>(headers: { [key: string]: string }, path: string, searchParams: any = {}): Promise<T> {
    try {
      const response = await lastValueFrom(
        this.httpService.get<T>(this.options.apiDomain + path, {
          params: searchParams,
          headers: {
            ...headers,
          },
        }),
      );
      return response.data as T;
    } catch (error) {
      console.log('🚀 ~ AxiosService ~ error:', error);
      //   if (error instanceof AxiosError) {
      //     throw new PayosPaymentsException(error.response.data as PayosErrorResponse, error.response.status);
      //   }
      throw error;
    }
  }
}
</file>

<file path="src/services/email/shared/types.ts">
export type EmailPayload = {
  email: string;
  subject: string;
  text: string;
};

export type EmailTemplate = {
  path: string;
  context?: Record<string, string>;
};
</file>

<file path="src/services/email/email.module.ts">
import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { Global, Module } from '@nestjs/common';
import { join } from 'path';
import { EMAIL_FROM, EMAIL_HOST, EMAIL_PASSWORD, EMAIL_USER } from 'src/app.config';
import { EmailService } from './email.service';

@Global()
@Module({
  imports: [
    MailerModule.forRootAsync({
      useFactory: async () => {
        return {
          transport: {
            host: EMAIL_HOST,

            secure: false,
            auth: {
              user: EMAIL_USER,
              pass: EMAIL_PASSWORD,
            },
          },
          defaults: {
            from: `"No Reply" <${EMAIL_FROM}>`,
          },
          template: {
            dir: join(__dirname, 'templates'),
            adapter: new HandlebarsAdapter(),
            options: {
              strict: true,
            },
          },
        };
      },
    }),
  ],
  providers: [EmailService],
  exports: [EmailService],
})
export class EmailModule {}
</file>

<file path="src/services/email/email.service.ts">
import { MailerService } from '@nestjs-modules/mailer';
import { Injectable, Logger } from '@nestjs/common';
import { leanObject } from 'src/shared/parsers/common.parser';
import { EmailPayload, EmailTemplate } from './shared/types';

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  constructor(private readonly mailService: MailerService) {}

  async sendMail(payload: EmailPayload, template?: EmailTemplate) {
    try {
      const sentEmail = await this.mailService.sendMail({
        to: payload.email,
        subject: payload.subject,
        text: payload.text,
        ...(template.path && leanObject({ template: template.path, context: template.context })),
      });

      this.logger.log('🚀 ~ EmailService ~ sendMail ~ sentEmail:', sentEmail);
    } catch (error) {
      this.logger.error('🚀 ~ EmailService ~ sendMail ~ error:', error);
    }
  }
}
</file>

<file path="src/services/event-emitter/event-emitter.interface.ts">
interface EventOptions {
  /** Indicates if the event should be emitted asynchronously */
  async?: boolean;
  /** Any additional options to pass to the emitter */
  [key: string]: any;
}
</file>

<file path="src/services/event-emitter/event-emitter.module.ts">
import { Global, Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { EventEmitterService } from './event-emitter.service';

@Global()
@Module({
  imports: [EventEmitterModule.forRoot()],
  providers: [EventEmitterService],
  exports: [EventEmitterService],
})
export class EventNestModule {}
</file>

<file path="src/services/event-emitter/event-emitter.service.ts">
import { Injectable } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class EventEmitterService {
  constructor(private readonly eventEmitter: EventEmitter2) {}

  /**
   * Emit an event with the given payload
   * @param eventName Name of the event
   * @param payload Payload to emit with the event
   * @param options Optional configurations for emitting the event
   */
  emit<T = any>(eventName: string, payload: T, options?: EventOptions): void {
    if (options?.async) {
      this.eventEmitter.emitAsync(eventName, payload, options);
    } else {
      this.eventEmitter.emit(eventName, payload, options);
    }
  }
}
</file>

<file path="src/services/fcm/request/fcm-register-token.request.ts">
import { Prisma } from '@prisma/client';
import { IsString } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class FcmRegisterTokenREQ {
  @IsString()
  token: string;

  static toCreateToken(accountId: number, body: FcmRegisterTokenREQ): Prisma.DeviceTokenCreateArgs {
    return {
      data: { token: body.token, Account: connectRelation(accountId) },
      select: { id: true },
    };
  }
}
</file>

<file path="src/services/fcm/request/fcm-remove-token.request.ts">
import { IsString } from 'class-validator';

export class FcmRemoveTokenREQ {
  @IsString()
  token: string;
}
</file>

<file path="src/services/fcm/shared/helpers.ts">
import { NotificationType } from '@prisma/client';
import { FcmNotificationPayload } from 'src/domains/notification/shared/interfaces';

// adapter for the FCM service
export const payloadFcmAdapter = (
  title: string | NotificationType,
  topic: string | NotificationType,
  body: string | object,
): FcmNotificationPayload => {
  return {
    title: typeof title === 'string' ? title : NotificationType[title],
    topic: typeof topic === 'string' ? topic : NotificationType[topic],
    body: typeof body === 'object' ? JSON.stringify(body) : body,
  };
};
</file>

<file path="src/services/fcm/fcm.controller.ts">
import { Body, Controller, Delete, Post, Req, UseGuards } from '@nestjs/common';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { FCMService } from './fcm.service';
import { FcmRegisterTokenREQ } from './request/fcm-register-token.request';
import { FcmRemoveTokenREQ } from './request/fcm-remove-token.request';

@Controller('fcm')
@UseGuards(AuthJwtGuard)
export class FcmController {
  constructor(private readonly fcmService: FCMService) {}

  @Post('device-tokens')
  async registerToken(@Req() req: AuthRequestDTO, @Body() body: FcmRegisterTokenREQ) {
    return await this.fcmService.registerToken(req.user, body);
  }

  @Delete('device-tokens')
  async removeToken(@Req() req: AuthRequestDTO, @Body() body: FcmRemoveTokenREQ) {
    await this.fcmService.removeToken(req.user, body);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/services/fcm/fcm.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from '../prisma/prisma.module';
import { FcmController } from './fcm.controller';
import { FCMService } from './fcm.service';

@Module({
  imports: [PrismaModule],
  controllers: [FcmController],
  providers: [FCMService],
  exports: [FCMService],
})
export class FcmModule {}
</file>

<file path="src/services/fcm/fcm.service.ts">
import { ForbiddenException, Injectable, Logger } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import * as firebaseAdmin from 'firebase-admin';
import { Message } from 'firebase-admin/lib/messaging/messaging-api';
import { isEmpty } from 'lodash';
import { FIREBASE_CLOUD_MESSAGE_CERTIFICATION } from 'src/app.config';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FcmNotificationPayload, FCMSendOptions } from 'src/domains/notification/shared/interfaces';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { resolvePathFromRoot } from 'src/shared/helpers/path.helper';
import { PrismaRawService } from '../prisma/prisma-raw.service';
import { TransactionHost } from '../prisma/transactions/transaction-host';
import { Transactional } from '../prisma/transactions/transactional.decorator';
import { FcmRegisterTokenREQ } from './request/fcm-register-token.request';
import { FcmRemoveTokenREQ } from './request/fcm-remove-token.request';

@Injectable()
export class FCMService {
  private readonly logger = new Logger(FCMService.name);

  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly prismaRawService: PrismaRawService,
  ) {
    try {
      firebaseAdmin.initializeApp({
        credential: firebaseAdmin.credential.cert(resolvePathFromRoot(FIREBASE_CLOUD_MESSAGE_CERTIFICATION)),
      });
      this.logger.log('Firebase Admin initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Firebase Admin', error);
      throw new Error('Firebase initialization failed');
    }
  }

  private notificationMessageBuilder(payload: FcmNotificationPayload, options: FCMSendOptions) {
    const message: Message = {
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: options.data || {},
      ...(options.token && { token: options.token }),
      // ...(options.topic && { topic: options.topic }),
      // ...(options.condition && { condition: options.condition }),
    };
    return message;
  }

  async sendNotification(payload: FcmNotificationPayload, options: FCMSendOptions): Promise<string> {
    try {
      const message = this.notificationMessageBuilder(payload, options);
      const response = await firebaseAdmin.messaging().send(message);
      this.logger.log('PUSHING NOTIFICATION SUCCESS on DEVICE', message.token);
      return response;
    } catch (error) {
      this.logger.error('PUSHING NOTIFICATION FAILED:', error);
      // throw new ActionFailedException(ActionFailed.NOTIFICATION_PUSH_FAILED, 'Error sending notification:', error);
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async sendNotificationToAllDevices(
    accountId: number,
    condition: Prisma.DeviceTokenWhereInput,
    payload: FcmNotificationPayload,
  ) {
    if (!accountId) return;

    const deviceTokens = await this.transactionHost.tx.deviceToken.findMany({
      where: condition,
      select: { token: true },
    });

    if (isEmpty(deviceTokens)) return;

    for (const device of deviceTokens) {
      await this.sendNotification(
        { body: typeof payload.body === 'object' ? JSON.stringify(payload.body) : payload.body, title: payload.title },
        { token: device.token },
      );
    }
  }

  async registerToken(user: AuthUserDTO, body: FcmRegisterTokenREQ) {
    const exiestedToken = await this.transactionHost.tx.deviceToken.findUnique({
      where: { token: body.token },
      select: { id: true },
    });

    if (exiestedToken) return exiestedToken;

    const token = await this.transactionHost.tx.deviceToken.create(FcmRegisterTokenREQ.toCreateToken(user.accountId, body));

    return token;
  }

  async removeToken(user: AuthUserDTO, body: FcmRemoveTokenREQ) {
    const deviceToken = await this.transactionHost.tx.deviceToken.findUniqueOrThrow({
      where: { token: body.token },
      select: { accountId: true, id: true },
    });

    if (deviceToken && deviceToken.accountId !== user.accountId) throw new ForbiddenException();

    await this.prismaRawService.deviceToken.delete({ where: { token: body.token } });
  }
}
</file>

<file path="src/services/fcm/fcm.types.ts">
export type NotificationPayload = {
  title: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
};

export type SendNotificationOptions = {
  token?: string;
  topic?: string;
  condition?: string;
  data?: { [key: string]: string }; // Custom data
};
</file>

<file path="src/services/getstream/request/getstream.request.ts">
export interface GetstreamREQ {
  user_id: string;
  role?: string;
  call_cids: string[];
  validity_in_seconds?: number;
  exp?: number;
  iat?: number;
}
</file>

<file path="src/services/getstream/getstream.controller.ts">
import { Body, Controller, Post, Req } from '@nestjs/common';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { GetStreamService } from './getstream.service';

@Controller('getstream')
export class GetStreamController {
  constructor(private readonly getStreamService: GetStreamService) {}

  @Post('webhooks')
  async push(@Body() payload: any, @Req() req: AuthRequestDTO) {
    this.getStreamService.verifyWebhook(req, payload);
    console.log('🚀 ~ AudioCallController ~ push ~ payload:', payload);
    this.getStreamService.emitEvent(payload);
  }
}
</file>

<file path="src/services/getstream/getstream.module.ts">
import { Module } from '@nestjs/common';
import { GetStreamController } from './getstream.controller';
import { GetStreamService } from './getstream.service';

@Module({
  providers: [GetStreamService],
  controllers: [GetStreamController],
  exports: [GetStreamService],
})
export class GetstreamModule {}
</file>

<file path="src/services/getstream/getstream.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { GetstreamService } from './getstream.service';

describe('GetstreamService', () => {
  let service: GetstreamService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [GetstreamService],
    }).compile();

    service = module.get<GetstreamService>(GetstreamService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/getstream/getstream.service.ts">
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { StreamClient } from '@stream-io/node-sdk';
import { GETSTREAM_API_KEY, GETSTREAM_API_SECRET, GETSTREAM_WEBHOOK_URL } from 'src/app.config';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { AudioCallChannel } from 'src/shared/constants/event.constant';
import { GetstreamREQ } from './request/getstream.request';

@Injectable()
export class GetStreamService implements OnModuleInit {
  private readonly streamClient: StreamClient;
  private logger = new Logger(GetStreamService.name);
  constructor(private readonly eventEmitter: EventEmitter2) {
    this.streamClient = new StreamClient(GETSTREAM_API_KEY, GETSTREAM_API_SECRET, { timeout: 10000 });
    this.logger.log('StreamClient initialized');
  }
  async onModuleInit() {
    try {
      await this.streamClient.updateApp({
        webhook_url: GETSTREAM_WEBHOOK_URL,
      });
    } catch (err) {
      this.logger.error(err.message);
    }
  }

  createCallToken(request: GetstreamREQ) {
    try {
      this.streamClient.generateCallToken(request as any);
    } catch (e) {
      this.logger.error(e);
    }
  }

  emitEvent(payload: any) {
    switch (payload.type) {
      case AudioCallChannel.LEAVE_CALL:
        this.eventEmitter.emit(AudioCallChannel.LEAVE_CALL, payload);
        break;
      default:
        break;
    }
  }

  verifyWebhook(req: AuthRequestDTO, body: any) {
    try {
      const signature = Array.isArray(req.headers['x-signature']) ? req.headers['x-signature'][0] : req.headers['x-signature'];
      const isVerified = this.streamClient.verifyWebhook(JSON.stringify(body), signature);
      if (!isVerified) {
        throw new Error('Webhook verification failed');
      }
    } catch (e) {
      this.logger.error(e.message);
    }
  }

  async createCall(request: any) {
    try {
      await this.streamClient.video.getOrCreateCall(request);
    } catch (e) {
      this.logger.error(e);
    }
  }
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.constant.ts">
import { VnpLocale } from './vnpay.enum';

export const VNP_DEFAULT_COMMAND = 'pay';
export const VNP_DEFAULT_CURR_CODE = 'VND';
export const WRONG_CHECKSUM_KEY = 'WRONG CHECKSUM';
export const VNPAY_RESPONSE_MAP = new Map<string, Record<VnpLocale, string>>([
  ['00', { vn: 'Giao dịch thành công', en: 'Approved' }],
  ['01', { vn: 'Giao dịch đã tồn tại', en: 'Transaction is already exist' }],
  [
    '02',
    {
      vn: 'Merchant không hợp lệ (kiểm tra lại vnp_TmnCode)',
      en: 'Invalid merchant (check vnp_TmnCode value)',
    },
  ],
  [
    '03',
    {
      vn: 'Dữ liệu gửi sang không đúng định dạng',
      en: 'Sent data is not in the right format',
    },
  ],
  [
    '04',
    {
      vn: 'Khởi tạo GD không thành công do Website đang bị tạm khoá',
      en: 'Payment website is not available',
    },
  ],
  [
    '05',
    {
      vn: 'Giao dịch không thành công do: Quý khách nhập sai mật khẩu thanh toán quá số lần quy định. Xin quý khách vui lòng thực hiện lại giao dịch',
      en: 'Transaction failed: Too many wrong password input',
    },
  ],
  [
    '06',
    {
      vn: 'Giao dịch không thành công do Quý khách nhập sai mật khẩu xác thực giao dịch (OTP). Xin quý khách vui lòng thực hiện lại giao dịch.',
      en: 'Transaction failed: Wrong OTP input',
    },
  ],
  [
    '07',
    {
      vn: 'Trừ tiền thành công. Giao dịch bị nghi ngờ (liên quan tới lừa đảo, giao dịch bất thường). Đối với giao dịch này cần merchant xác nhận thông qua merchant admin: Từ chối/Đồng ý giao dịch',
      en: 'This transaction is suspicious',
    },
  ],
  [
    '08',
    {
      vn: 'Giao dịch không thành công do: Hệ thống Ngân hàng đang bảo trì. Xin quý khách tạm thời không thực hiện giao dịch bằng thẻ/tài khoản của Ngân hàng này.',
      en: 'Transaction failed: The banking system is under maintenance. Please do not temporarily make transactions by card / account of this Bank.',
    },
  ],
  [
    '09',
    {
      vn: 'Giao dịch không thành công do: Thẻ/Tài khoản của khách hàng chưa đăng ký dịch vụ InternetBanking tại ngân hàng.',
      en: 'Transaction failed: Cards / accounts of customer who has not yet registered for Internet Banking service.',
    },
  ],
  [
    '10',
    {
      vn: 'Giao dịch không thành công do: Khách hàng xác thực thông tin thẻ/tài khoản không đúng quá 3 lần',
      en: 'Transaction failed: Customer incorrectly validate the card / account information more than 3 times',
    },
  ],
  [
    '11',
    {
      vn: 'Giao dịch không thành công do: Đã hết hạn chờ thanh toán. Xin quý khách vui lòng thực hiện lại giao dịch.',
      en: 'Transaction failed: Pending payment is expired. Please try again.',
    },
  ],
  [
    '24',
    {
      vn: 'Giao dịch không thành công do: Khách hàng hủy giao dịch',
      en: 'Transaction canceled',
    },
  ],
  [
    '51',
    {
      vn: 'Giao dịch không thành công do: Tài khoản của quý khách không đủ số dư để thực hiện giao dịch.',
      en: 'Transaction failed: Your account is not enough balance to make the transaction.',
    },
  ],
  [
    '65',
    {
      vn: 'Giao dịch không thành công do: Tài khoản của Quý khách đã vượt quá hạn mức giao dịch trong ngày.',
      en: 'Transaction failed: Your account has exceeded the daily limit.',
    },
  ],
  [
    '75',
    {
      vn: 'Ngân hàng thanh toán đang bảo trì',
      en: 'Banking system is under maintenance',
    },
  ],
  [WRONG_CHECKSUM_KEY, { vn: 'Sai checksum', en: 'Wrong checksum' }],
  ['default', { vn: 'Giao dịch thất bại', en: 'Failure' }],
]);

export const QUERY_DR_RESPONSE_MAP = new Map<string, Record<VnpLocale, string>>([
  ['00', { vn: 'Yêu cầu thành công', en: 'Success' }],
  [
    '02',
    {
      vn: 'Mã định danh kết nối không hợp lệ (kiểm tra lại TmnCode)',
      en: 'Invalid connection identifier (check TmnCode)',
    },
  ],
  [
    '03',
    {
      vn: 'Dữ liệu gửi sang không đúng định dạng',
      en: 'Sent data is not in the right format',
    },
  ],
  [
    '91',
    {
      vn: 'Không tìm thấy giao dịch yêu cầu',
      en: 'Transaction not found for request',
    },
  ],
  [
    '94',
    {
      vn: 'Yêu cầu trùng lặp, duplicate request trong thời gian giới hạn của API',
      en: 'Duplicate request within the time limit of the API',
    },
  ],
  [
    '97',
    {
      vn: 'Checksum không hợp lệ',
      en: 'Invalid checksum',
    },
  ],
  [
    '99',
    {
      vn: 'Các lỗi khác (lỗi còn lại, không có trong danh sách mã lỗi đã liệt kê)',
      en: 'Other errors (remaining errors, not in the list of error codes listed)',
    },
  ],
  [WRONG_CHECKSUM_KEY, { vn: 'Sai checksum', en: 'Wrong checksum' }],
  ['default', { vn: 'Giao dịch thất bại', en: 'Failure' }],
]);
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.enum.ts">
export enum HashAlgorithm {
  SHA256 = 'SHA256',
  SHA512 = 'SHA512',
  MD5 = 'MD5',
}

export enum VnpCurrCode {
  VND = 'VND',
}
export enum VnpLocale {
  VN = 'vn',
  EN = 'en',
}

export enum VnpCardType {
  ATM = 'ATM',
  QRCODE = 'QRCODE',
}

export enum BankCode {
  VNPAYQR = 'VNPAYQR',
  VNBANK = 'VNBANK',
  INTCARD = 'INTCARD',
}
export declare enum VnpTransactionType {
  PAYMENT = '01',
  FULL_REFUND = '02',
  PARTIAL_REFUND = '03',
}

export declare enum RefundTransactionType {
  FULL_REFUND = '02',
  PARTIAL_REFUND = '03',
}

/**
 * @see https://sandbox.vnpayment.vn/apis/docs/loai-hang-hoa/
 */
export enum ProductCode {
  Food_Consumption = '100000',
  Phone_Tablet = '110000',
  ElectricAppliance = '120000',
  Computers_OfficeEquipment = '130000',
  Electronics_Sound = '140000',
  Books_Newspapers_Magazines = '150000',
  Sports_Picnics = '160000',
  Hotel_Tourism = '170000',
  Cuisine = '180000',
  Entertainment_Training = '190000',
  Fashion = '200000',
  Health_Beauty = '210000',
  Mother_Baby = '220000',
  KitchenUtensils = '230000',
  Vehicle = '240000',
  Pay = '250000',
  AirlineTickets = '250007',
  CardCode = '260000',
  Pharmacy_MedicalServices = '270000',
  Other = 'other',
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.helper.ts">
import crypto, { type BinaryLike } from 'crypto';
import { VNPAY_ENDPOINT, VNPAY_SANDBOX_HOST } from 'src/app.config';
import { DATE_FORMAT } from 'src/shared/constants/date.constant';
import { resolveUrlString } from 'src/shared/helpers/common.helper';
import { parseAndAddMinutes } from 'src/shared/parsers/datetime.parse';
import { VNPAY_RESPONSE_MAP } from './vnpay.constant';
import { HashAlgorithm, VnpLocale } from './vnpay.enum';
import { DefaultConfig, VNPayBuildUrlRequest, VpnGlobalConfig } from './vnpay.type';

/**
 * Validate if the date is match with format `yyyyMMddHHmmss` or not
 * @param date The date to be validated
 * @returns True if the date is valid, false otherwise
 */
export function isValidVnpayDateFormat(date: number): boolean {
  const dateString = date.toString();
  const regex = /^\d{4}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]$/;
  return regex.test(dateString);
}
export function formatVnpayDate(date: Date, format = 'yyyyMMddHHmmss'): number {
  const pad = (n: number) => (n < 10 ? `0${n}` : n).toString();
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hour = pad(date.getHours());
  const minute = pad(date.getMinutes());
  const second = pad(date.getSeconds());

  return Number(
    format
      .replace('yyyy', year.toString())
      .replace('MM', month)
      .replace('dd', day)
      .replace('HH', hour)
      .replace('mm', minute)
      .replace('ss', second),
  );
}

export function generateExpiredDate(createdDate: number): number {
  if (!isValidVnpayDateFormat(createdDate)) {
    throw new Error('Invalid date format');
  }

  //generate expired date after 10 minutes
  const expiredDate = parseAndAddMinutes(createdDate.toString(), 10, DATE_FORMAT.DATE_TIME_SECOND.NO_SPACE);
  return Number(expiredDate);
}

export function buildPaymentUrlSearchParams(data: Record<string, unknown>): URLSearchParams {
  const searchParams = new URLSearchParams();
  const sortedEntries = Object.entries(data).sort(([key1], [key2]) => key1.toString().localeCompare(key2.toString()));

  for (const [key, value] of sortedEntries) {
    // Skip empty value
    if (value === '' || value === undefined || value === null) {
      continue;
    }

    searchParams.append(key, value.toString());
  }
  return searchParams;
}

export const createPaymentUrl = ({
  data,
  config,
}: {
  data: (VNPayBuildUrlRequest & DefaultConfig) | Record<string, unknown>;
  config: Pick<VpnGlobalConfig, 'vnpayHost' | 'paymentEndpoint'>;
}): URL => {
  const redirectUrl = new URL(resolveUrlString(config.vnpayHost ?? VNPAY_SANDBOX_HOST, config.paymentEndpoint ?? VNPAY_ENDPOINT));

  buildPaymentUrlSearchParams(data).forEach((value, key) => {
    redirectUrl.searchParams.set(key, value);
  });

  return redirectUrl;
};

export function calculateSecureHash({
  bufferEncode = 'utf-8',
  data,
  hashAlgorithm,
  secureSecret,
}: {
  secureSecret: string;
  data: string;
  hashAlgorithm: HashAlgorithm;
  bufferEncode?: BufferEncoding;
}): string {
  return hashVnpay(secureSecret, Buffer.from(data, bufferEncode), hashAlgorithm);
}

export function verifySecureHash({
  data,
  hashAlgorithm,
  receivedHash,
  secureSecret,
}: {
  secureSecret: string;
  data: string;
  hashAlgorithm: HashAlgorithm;
  receivedHash: string;
}): boolean {
  const calculatedHash = calculateSecureHash({ secureSecret, data, hashAlgorithm });
  console.log('🚀 ~ calculatedHash:', calculatedHash);
  return calculatedHash === receivedHash;
}

export function hashVnpay(secret: string, data: BinaryLike, algorithm: HashAlgorithm): string {
  return crypto.createHmac(algorithm, secret).update(data).digest('hex');
}

export function makeVNPayResponse(responseCode: string = '', locale: string = VnpLocale.VN) {
  const responseText: Record<VnpLocale, string> = VNPAY_RESPONSE_MAP.get(responseCode) ?? VNPAY_RESPONSE_MAP.get('default');

  return responseText[locale];
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.type.ts">
import { HashAlgorithm, ProductCode, VnpCardType, VnpCurrCode, VnpLocale } from './vnpay.enum';

export const VNPAY_MODULE_OPTIONS = Symbol('VNPAY_MODULE_OPTIONS');

export type VnpMode = 'sandbox' | 'production';

export type VpnGlobalConfig = Omit<VNPayConfig, 'testMode' | 'enableLog' | 'loggerFn'> & {
  vnpayHost: string;
  vnp_Locale: VnpLocale;
  vnp_CurrCode: VnpCurrCode;
  vnp_Command: string;
  vnp_OrderType: ProductCode | string;
  vnp_Version: string;
};

export type DefaultConfig = Pick<VpnGlobalConfig, 'vnp_Version' | 'vnp_CurrCode' | 'vnp_Command' | 'vnp_OrderType'> & {
  vnp_TmnCode: string;
  vnp_Locale: VnpLocale;
};
export type VNPayConfig = {
  /**
   * Merchant tmn code
   */
  tmnCode: string;
  /**
   * Secure secret of merchant
   */
  secureSecret: string;
  /**
   * Version of VNPay API
   */
  vnp_Version?: string;
  /**
   * Currency code
   */
  vnp_CurrCode?: VnpCurrCode;
  /**
   * Language display on payment gateway
   */
  vnp_Locale?: VnpLocale;
  /**
   * API host url of VNPay
   * @default 'https://sandbox.vnpayment.vn'
   * @example 'https://sandbox.vnpayment.vn'
   */
  vnpayHost?: string;
  /**
   *  Payment endpoint of VNPay
   * @default 'paymentv2/vpcpay.html'
   * @example 'paymentv2/vpcpay.html'
   */
  paymentEndpoint?: string;
  /**
   * When using test mode, `vnpayHost` should be set to sandbox
   * @default false
   */
  mode?: VnpMode;
  /**
   * Hash algorithm
   * @default 'SHA512'
   */
  hashAlgorithm?: HashAlgorithm;
  /**
   * Disable it, then no logger will be used in any method
   *
   * Enable logging feature
   * @default false
   */
  enableLog?: boolean;
  /**
   * Method that allows you to customize the log
   * @param data Data to log, it can be change to each method
   * @returns
   */
  loggerFn?: (data: unknown) => void;
};

export type VNPayBuildUrlRequest = {
  /**
   * Amount of payment. Automatically calculated according to the unit of VNPay. (100 times the amount of the order in your database)
   */
  vnp_Amount: number;

  /**
   * Description of payment (Vietnamese, no accent)
   * @example Thanh toan don hang 12345
   */
  vnp_OrderInfo: string;

  /**
   * Reference code of transaction on merchant system. This code is unique to distinguish orders sent to VNPAY. Not duplicated in a day.
   * @example 123456
   */
  vnp_TxnRef: string;

  /**
   * IP address of customer who make transaction
   * @example 13.160.92.202
   */
  vnp_IpAddr: string;

  /**
   * URL thông báo kết quả giao dịch khi Khách hàng kết thúc thanh toán.
   * URL to notify result of transaction when customer finish payment
   * @example https://domain.vn/VnPayReturn
   */
  vnp_ReturnUrl: string;

  /**
   * Transaction date format yyyyMMddHHmmss(Time zone GMT+7)
   *
   * If `vnp_CreateDate` is not in the correct format, it will be the current time
   * @example 20170829103111
   * @example
   * ```ts
   *  import { dateFormat } from 'vnpay';
   *
   *  // then
   *  vnp_CreateDate: dateFormat(new Date()),
   * ```
   */
  vnp_CreateDate?: number;

  /**
   * Time of expiration of payment, format yyyyMMddHHmmss(Time zone GMT+7)
   * @example 20170829103111
   * @example
   * ```ts
   *  import { dateFormat } from 'vnpay';
   *
   *  const tomorrow = new Date();
   *  tomorrow.setDate(tomorrow.getDate() + 1);
   *
   *  // then
   *  vnp_CreateDate: dateFormat(tomorrow),
   * ```
   */
  vnp_ExpireDate?: number;

  /**
   * Currency code using for payment. Currently only support VND
   * @example VND
   */
  vnp_CurrCode?: VpnGlobalConfig['vnp_CurrCode'];

  /**
   * Language display on payment gateway. Currently support Vietnamese (vn), English)
   * @example vn
   */
  vnp_Locale?: VpnGlobalConfig['vnp_Locale'];

  /**
   * Order type/ Product Code
   * @default 'other'
   */
  vnp_OrderType?: VpnGlobalConfig['vnp_OrderType'];

  /**
   * Bank code
   * @example NCB
   */
  vnp_BankCode?: string;
};

export type VnpayModuleOptions = VNPayConfig;

export type ReturnQueryFromVNPay = Pick<VNPayBuildUrlRequest, 'vnp_OrderInfo' | 'vnp_TxnRef'> & {
  /**
   * Payment amount
   */
  vnp_Amount: number | string;
  /**
   * Merchant tmn code
   */
  vnp_TmnCode?: string;
  /**
   * Bank code
   * @example NCB
   */
  vnp_BankCode?: string;
  /**
   * Transaction code at bank
   * @example NCB20170829152730
   */
  vnp_BankTranNo?: string;
  /**
   * Type of customer account/card used: `ATM`, `QRCODE`
   * @example ATM
   */
  vnp_CardType?: VnpCardType | string;
  /**
   * Payment time. Format: yyyyMMddHHmmss
   * @example 20170829152730
   */
  vnp_PayDate?: number | string;
  /**
   * Transaction code recorded in VNPAY system.
   * @example 20170829153052
   */
  vnp_TransactionNo?: number | string;
  /**
   * Response code of payment result. The response code 00 corresponds to the Successful result for all APIs.
   * @example 00
   * @see https://sandbox.vnpayment.vn/apis/docs/bang-ma-loi/
   */
  vnp_ResponseCode: number | string;
  /**
   *
   * Response code of payment result. Status of transaction at VNPAY payment gateway.
   *
   * -00: Payment transaction is successful at VNPAY
   *
   * -Other 00: Payment transaction is not successful at VNPAY
   *
   * @example 00
   * @see https://sandbox.vnpayment.vn/apis/docs/bang-ma-loi/
   */
  vnp_TransactionStatus?: number | string;
  /**
   * Security type code used to create checksum code. This code depends on the configuration of the merchant and the version of the api used.
   * The current version supports `SHA256`, `HMACSHA512`.
   * @example HMACSHA512
   */
  vnp_SecureHashType?: string;
  /**
   * Checksum to ensure that the transaction data is not changed during the transfer from merchant to VNPAY.
   * The creation of this code depends on the configuration of the merchant and the version of the api used. The current version supports `SHA256`, `HMACSHA512`.
   *
   */
  vnp_SecureHash?: string;
};
</file>

<file path="src/services/payment-gateway/vn-pay/vnpay.module.ts">
import { DynamicModule, Module } from '@nestjs/common';
import { VNPAY_MODULE_OPTIONS, VnpayModuleOptions } from './shared/vnpay.type';
import { VnpayService } from './vnpay.service';

@Module({})
export class VnpayModule {
  static register(options: VnpayModuleOptions): DynamicModule {
    return {
      module: VnpayModule,
      providers: [{ provide: VNPAY_MODULE_OPTIONS, useValue: options }, VnpayService],
      exports: [VnpayService],
    };
  }
}
</file>

<file path="src/services/payment-gateway/vn-pay/vnpay.service.ts">
import { Inject, Injectable, Logger } from '@nestjs/common';
import { AxiosError } from 'axios';
import { isNull } from 'lodash';
import { VNP_HASHSECRET, VNP_TMNCODE, VNP_VERSION, VNPAY_SANDBOX_HOST } from 'src/app.config';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { numberRegex } from 'src/shared/constants/common.constant';
import { DATE_FORMAT } from 'src/shared/constants/date.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { Result, SuccessOrFailResponse } from 'src/shared/generics/type.helper';
import { makeResult } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { leanObject } from 'src/shared/parsers/common.parser';
import { parseDateTimeNowFormat } from 'src/shared/parsers/datetime.parse';
import { VNP_DEFAULT_COMMAND, VNP_DEFAULT_CURR_CODE } from './shared/vnpay.constant';
import { HashAlgorithm, ProductCode, VnpCurrCode, VnpLocale } from './shared/vnpay.enum';
import {
  buildPaymentUrlSearchParams,
  calculateSecureHash,
  createPaymentUrl,
  generateExpiredDate,
  isValidVnpayDateFormat,
  makeVNPayResponse,
  verifySecureHash,
} from './shared/vnpay.helper';
import {
  DefaultConfig,
  ReturnQueryFromVNPay,
  VNPAY_MODULE_OPTIONS,
  VNPayBuildUrlRequest,
  VNPayConfig,
  VpnGlobalConfig,
} from './shared/vnpay.type';

@Injectable()
export class VnpayService {
  private readonly logger = new Logger(VnpayService.name);
  private HASH_ALGORITHM = HashAlgorithm.SHA512;
  private BUFFER_ENCODE: BufferEncoding = 'utf-8';
  private readonly globalDefaultConfig: VpnGlobalConfig;

  constructor(
    @Inject(VNPAY_MODULE_OPTIONS) private readonly config: VNPayConfig,
    private readonly transactionHost: TransactionHost,
  ) {
    if (isNull(this.config.mode) || this.config.mode === 'sandbox') {
      this.globalDefaultConfig.vnpayHost = VNPAY_SANDBOX_HOST;
    }

    this.globalDefaultConfig = {
      tmnCode: VNP_TMNCODE,
      vnp_Version: VNP_VERSION,
      vnpayHost: VNPAY_SANDBOX_HOST,
      secureSecret: VNP_HASHSECRET,
      vnp_Command: VNP_DEFAULT_COMMAND,
      vnp_CurrCode: VNP_DEFAULT_CURR_CODE as VnpCurrCode,
      vnp_Locale: VnpLocale.VN,
      vnp_OrderType: ProductCode.Other,
      ...config,
    };
  }

  /**
   */
  @Transactional(TRANSACTION_TIMEOUT)
  async create(paymentId: number, body: VNPayBuildUrlRequest) {
    const url = this.buildPaymentUrl(body);
    const searchParams = url
      .split('?')[1]
      .split('&')
      .reduce((acc, item) => {
        const [key, value] = item.split('=');
        return { ...acc, [key]: value };
      }, {}) as VNPayBuildUrlRequest;
    console.log('🚀 ~ VnpayService ~ create ~ searchParams:', searchParams);

    const { vnp_TxnRef, vnp_CreateDate, vnp_Amount, vnp_BankCode, vnp_OrderInfo, ...remain } = searchParams;

    await this.transactionHost.tx.vnpayProvider.upsert({
      where: { paymentId },
      update: {
        vnp_Amount: vnp_Amount,
        vnp_BankCode: vnp_BankCode,
        vnp_OrderInfo: vnp_OrderInfo,
        vnp_CreatedDate: vnp_CreateDate,
        vnp_TxnRef: vnp_TxnRef,
        metadata: remain,
      },
      create: {
        vnp_Amount: vnp_Amount,
        vnp_BankCode: vnp_BankCode,
        vnp_OrderInfo: vnp_OrderInfo,
        vnp_CreatedDate: vnp_CreateDate,
        vnp_TxnRef: vnp_TxnRef,
        metadata: remain,
        Payment: connectRelation(paymentId),
      },
    });

    return url;
  }

  /**
   * Lấy cấu hình mặc định của VNPay
   * @en Get default config of VNPay
   */
  public get defaultConfig(): DefaultConfig {
    return {
      vnp_TmnCode: this.globalDefaultConfig.tmnCode,
      vnp_Version: this.globalDefaultConfig.vnp_Version,
      vnp_CurrCode: this.globalDefaultConfig.vnp_CurrCode,
      vnp_Locale: this.globalDefaultConfig.vnp_Locale,
      vnp_Command: this.globalDefaultConfig.vnp_Command,
      vnp_OrderType: this.globalDefaultConfig.vnp_OrderType,
    };
  }

  async getBankList(): Promise<Result<any, AxiosError>> {
    return makeResult(async () => {});
  }

  /**
   * Phương thức xây dựng, tạo thành url thanh toán của VNPay
   * @en Build the payment url
   *
   * @param {BuildPaymentUrl} data - Payload that contains the information to build the payment url
   * @returns {string} The payment url string
   * @see https://sandbox.vnpayment.vn/apis/docs/thanh-toan-pay/pay.html#tao-url-thanh-toan
   */
  public buildPaymentUrl(data: VNPayBuildUrlRequest): string {
    const createDate = Number(parseDateTimeNowFormat(DATE_FORMAT.DATE_TIME_SECOND.NO_SPACE));

    if (data?.vnp_ExpireDate && !isValidVnpayDateFormat(data.vnp_ExpireDate)) {
      // Because the URL still works without vnp_ExpireDate, we keep it optional here.
      // TODO: make it required when VNPAY's `vnp_ExpireDate` is required
      throw new Error('Invalid vnp_ExpireDate format. use `formatDate` utility function to format it');
    }

    const expiredDate = data.vnp_ExpireDate || generateExpiredDate(Number(createDate));

    const dataToBuild = leanObject({
      ...this.defaultConfig,
      ...data,

      /**
       * Multiply by 100 to follow VNPay standard, see docs for more detail
       */
      vnp_CreateDate: createDate,
      vnp_ExpireDate: expiredDate,
      vnp_Amount: data.vnp_Amount * 100,
    });

    const redirectUrl = createPaymentUrl({
      config: this.globalDefaultConfig,
      data: dataToBuild,
    });

    const signed = calculateSecureHash({
      secureSecret: this.globalDefaultConfig.secureSecret,
      data: redirectUrl.search.slice(1).toString(),
      hashAlgorithm: this.HASH_ALGORITHM,
      bufferEncode: this.BUFFER_ENCODE,
    });
    console.log('🚀 ~ VnpayService ~ buildPaymentUrl ~ signed:', signed);

    redirectUrl.searchParams.append('vnp_SecureHash', signed);

    return redirectUrl.toString();
  }

  public async verifyReturnUrl(
    paymentId: number,
    query: ReturnQueryFromVNPay,
  ): Promise<Result<{ message: string } & ReturnQueryFromVNPay, Error>> {
    const { vnp_SecureHash, vnp_SecureHashType, ...cloneQuery } = query;

    if (typeof cloneQuery?.vnp_Amount !== 'number') {
      const isValidAmount = numberRegex.test(cloneQuery?.vnp_Amount ?? '');
      if (!isValidAmount) {
        return SuccessOrFailResponse.Failure(new Error('Invalid vnp_Amount format'));
      }
      cloneQuery.vnp_Amount = Number(cloneQuery.vnp_Amount);
    }

    const searchParams = buildPaymentUrlSearchParams(cloneQuery);
    this.logger.log('🚀 ~ VnpayService ~ searchParams:', searchParams);
    const isVerified = verifySecureHash({
      secureSecret: this.globalDefaultConfig.secureSecret,
      data: searchParams.toString(),
      hashAlgorithm: this.HASH_ALGORITHM,
      receivedHash: vnp_SecureHash,
    });

    if (!isVerified) this.logger.warn(`🚀 ~ VnpayService ~ isVerified ~ Payment with id ${paymentId} has been unverified`);

    const message = makeVNPayResponse(cloneQuery.vnp_ResponseCode?.toString() ?? '', this.globalDefaultConfig.vnp_Locale);
    this.logger.log('🚀 ~ VnpayService ~ message:', message);

    await this.updatePaymentAfterVerify(paymentId, cloneQuery);

    return isVerified
      ? SuccessOrFailResponse.Success({
          ...cloneQuery,
          vnp_Amount: cloneQuery.vnp_Amount / 100,
          message,
        })
      : SuccessOrFailResponse.Failure(new Error("The payment is unverified. It's not safe to continue"));
  }

  async updatePaymentAfterVerify(paymentId: number, cloneQuery: ReturnQueryFromVNPay) {
    await this.transactionHost.tx.vnpayProvider.update({
      where: { paymentId },
      data: {
        vnp_PayDate: Number(cloneQuery.vnp_PayDate),
        vnp_TransactionStatus: cloneQuery.vnp_TransactionStatus as string,
        vnp_TransactionNo: cloneQuery.vnp_TransactionNo as string,
        metadata: cloneQuery,
      },
    });
  }
}
</file>

<file path="src/services/prisma/transactions/transaction-host.spec.ts">
import { Injectable } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AccountType, Prisma } from '@prisma/client';
import { ClsModule } from 'nestjs-cls';
import { PrismaModule } from '../prisma.module';
import { PrismaService } from '../prisma.service';
import { TransactionHost } from './transaction-host';
import { Transactional } from './transactional.decorator';

@Injectable()
class AccountRepository {
  constructor(private readonly txHost: TransactionHost) {}

  async getAccountById(id: number) {
    return this.txHost.tx.account.findUnique({ where: { id } });
  }

  async createAccount(name: string) {
    const random = Math.floor(Math.random() * 1000);
    const account = this.txHost.tx.account.create({
      data: {
        email: `${name}-${random}@gmail.com`,
        password: '12345678',
        phoneNumber: '0822333444',
        accountType: AccountType.STUDENT,
      },
    });
    return account;
  }
}

@Injectable()
class AccountService {
  constructor(
    private readonly accountRepository: AccountRepository,
    private readonly txHost: TransactionHost,
    private readonly prismaService: PrismaService,
  ) {}

  @Transactional()
  async transactionWithDecorator() {
    const r1 = await this.accountRepository.createAccount('john');
    const r2 = await this.accountRepository.getAccountById(r1.id as number);
    return { r1, r2 };
  }

  /*
   * The isolationLevel option is set to Serializable,
   * which means that the transaction is fully isolated from other transactions,
   * preventing phenomena like dirty reads, non-repeatable reads, and phantom reads.
   */
  @Transactional({
    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
  })
  async transactionWithDecoratorWithOptions() {
    const r1 = await this.accountRepository.createAccount('James');
    const r2 = await this.prismaService.account.findUnique({
      where: { id: r1.id },
    });
    const r3 = await this.accountRepository.getAccountById(r1.id);
    return { r1, r2, r3 };
  }

  async transactionWithFunctionWrapper() {
    return this.txHost.withTransaction(
      {
        isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
      },
      async () => {
        const r1 = await this.accountRepository.createAccount('joe');
        const r2 = await this.prismaService.account.findUnique({
          where: { id: r1.id },
        });
        const r3 = await this.accountRepository.getAccountById(r1.id);
        return { r1, r2, r3 };
      },
    );
  }

  @Transactional()
  async transactionWithDecoratorError() {
    await this.accountRepository.createAccount('nobody');
    throw new Error('Rollback');
  }
}

describe('Transactional', () => {
  let callingService: AccountService;
  let prisma: PrismaService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        PrismaModule,
        // Register the ClsModule,
        ClsModule.forRoot({
          global: true,
          middleware: {
            // automatically mount the
            // ClsMiddleware for all routes
            mount: true,
            // and use the setup method to
            // provide default store values.
          },
        }),
      ],
      providers: [AccountRepository, AccountService],
    }).compile();
    await moduleRef.init();
    callingService = moduleRef.get(AccountService);
    prisma = moduleRef.get(PrismaService);
  });

  describe('TransactionalDecorator', () => {
    it('should run a transaction with the default options with a decorator', async () => {
      const { r1, r2 } = await callingService.transactionWithDecorator();
      expect(r1).toEqual(r2);
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });

    it('should run a transaction with the specified options with a decorator', async () => {
      const { r1, r2, r3 } = await callingService.transactionWithDecoratorWithOptions();
      expect(r1).toEqual(r3);
      expect(r2).toBeNull();
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });
    it('should run a transaction with the specified options with a function wrapper', async () => {
      const { r1, r2, r3 } = await callingService.transactionWithFunctionWrapper();
      expect(r1).toEqual(r3);
      expect(r2).toBeNull();
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });

    it('should rollback a transaction on error', async () => {
      await expect(callingService.transactionWithDecoratorError()).rejects.toThrow(new Error('Rollback'));
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.not.arrayContaining([{ name: 'nobody' }]));
    });
  });
});
</file>

<file path="src/services/prisma/transactions/transaction-host.ts">
import { Injectable, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { isNotEmpty } from 'class-validator';
import { ClsService } from 'nestjs-cls';
import { Propagation } from 'src/domains/notification/shared/transation.enum';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PrismaService } from '../prisma.service';
import { TRANSACTIONAL_INSTANCE } from './transaction.constant';
import { PrismaTransactionOptions } from './transaction.type';

@Injectable()
export class TransactionHost {
  private readonly logger = new Logger(TransactionHost.name);
  constructor(
    private readonly clsService: ClsService,
    private readonly _default: PrismaService,
  ) {}

  /**
   *  The instance of the transaction object.
   *
   * this may be a transaction reference, a database client, or something else.
   *
   * If no transaction is active, this will return the _default (PrismaService) instance.
   */
  get tx(): PrismaClient {
    if (!this.clsService.isActive()) {
      return this._default;
    }

    return this.clsService.get(TRANSACTIONAL_INSTANCE) || this._default;
  }

  /**
   *
   * The transaction instance will be accessible on the TransactionHost as `tx`.
   *
   * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
   *
   * @param fn The function to run in a transaction.
   * @param propagation The propagation mode to use, @see{Propagation}.
   * @param options Transaction options
   * @returns Whatever the passed function returns
   */
  withTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(progation: Propagation, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(progation: Propagation, options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(firstParam: any, secondParam?: any, thirdParam?: (...args: any[]) => Promise<R>) {
    let propagation: string;
    let options: any;
    let fn: (...args: any[]) => Promise<R>;
    if (thirdParam) {
      propagation = firstParam;
      options = secondParam;
      fn = thirdParam;
    } else if (secondParam) {
      fn = secondParam;
      if (typeof firstParam === 'string') {
        propagation = firstParam;
      } else {
        options = firstParam;
      }
    } else {
      fn = firstParam;
    }
    propagation ??= Propagation.Required;
    options = { ...TRANSACTION_TIMEOUT, ...options };
    return this.runWithTransactionAndPropagation(propagation, options, fn);
  }

  runWithTransactionAndPropagation<R>(propagation: string, options: any, fn: (...args: any[]) => Promise<R>): Promise<R> {
    const fnName = fn.name || 'anonymous';
    switch (propagation) {
      case Propagation.Required:
        if (this.isTransactionActive()) {
          if (isNotEmpty(options)) {
            this.logger.warn(
              `Transaction options are ignored because a transaction is already active and the propagation mode is ${propagation} (for method ${fnName}).`,
            );
          }
          return fn();
        } else {
          return this.runWithTransaction(options, fn);
        }
      case Propagation.RequiresNew:
        return this.runWithTransaction(options, fn);
      default:
        throw new ActionFailedException(ActionFailed.UNKNOW_PROPAGATION_MODE, `Unknown propagation mode: ${propagation}`);
    }
  }

  /**
   * Run a function in a transaction.
   *
   * @param fn The function to run in a transaction.
   * @returns Whatever the passed function returns
   */
  runWithTransaction(options: any, fn: (...args: any[]) => Promise<any>) {
    return this.clsService.run({ ifNested: 'inherit' }, async () => {
      return await this._default.$transaction(async (tx: PrismaService) => {
        this.setTxInstance.bind(this)(tx);
        try {
          return await fn();
        } catch (error) {
          throw error;
        } finally {
          this.setTxInstance.bind(this)(undefined);
        }
      }, options);
    });
  }

  /**
   * Wrap a function call to run outside of a transaction.
   *
   * @param fn The function to run outside of a transaction.
   * @returns Whatever the passed function returns
   */
  withoutTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R> {
    return this.clsService.run({ ifNested: 'inherit' }, () => {
      this.setTxInstance(undefined);
      return fn().finally(() => this.setTxInstance(undefined));
    });
  }

  isTransactionActive() {
    if (!this.clsService.isActive()) {
      return false;
    }
    const instance = this.clsService.get(TRANSACTIONAL_INSTANCE);
    return !!instance;
  }

  private setTxInstance(txInstance?: PrismaClient) {
    if (!txInstance) {
      this.clsService.set(TRANSACTIONAL_INSTANCE, undefined);
      return;
    }

    this.clsService.set(TRANSACTIONAL_INSTANCE, txInstance);
  }
}
</file>

<file path="src/services/prisma/transactions/transaction.constant.ts">
export const TRANSACTIONAL_INSTANCE = Symbol('TRANSACTIONAL_CLIENT');
</file>

<file path="src/services/prisma/transactions/transaction.symbol.ts">
export const TRANSACTIONAL_INSTANCE = Symbol('TRANSACTIONAL_CLIENT');
</file>

<file path="src/services/prisma/transactions/transaction.type.ts">
import { Prisma, PrismaClient } from '@prisma/client';

export type PrismaTransactionalClient = Parameters<Parameters<PrismaClient['$transaction']>[0]>[0];

// export type PrismaTransactionOptions = Parameters<PrismaClient['$transaction']>[1];

export type PrismaTransactionOptions = { timeout?: number; maxWait: number; isolationLevel?: Prisma.TransactionIsolationLevel };
</file>

<file path="src/services/prisma/transactions/transactional.decorator.ts">
import { Inject } from '@nestjs/common';
import { copyMethodMetadata } from 'nestjs-cls';
import { Propagation } from 'src/domains/notification/shared/transation.enum';
import { TransactionHost } from './transaction-host';
import { PrismaTransactionOptions } from './transaction.type';

export function Transactional(propagation?: Propagation): MethodDecorator;
export function Transactional(options?: PrismaTransactionOptions): MethodDecorator;
export function Transactional(propagation: Propagation, options?: PrismaTransactionOptions): MethodDecorator;
export function Transactional(firstParam?: any, seconParam?: any): MethodDecorator {
  let propagation: Propagation | undefined;
  let options: any;

  if (seconParam) {
    propagation = firstParam;
    options = seconParam;
  } else if (firstParam) {
    if (paramIsPropagationType(firstParam)) {
      propagation = firstParam;
    } else {
      options = firstParam;
    }
  }

  const injectTransactionHost = Inject(TransactionHost);

  return ((target: any, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>) => {
    if (!target.__transactionHost) {
      injectTransactionHost(target, '__transactionHost');
    }
    const original = descriptor.value;
    if (typeof original !== 'function') {
      throw new Error(
        `The @Transactional decorator can be only used on functions, but ${propertyKey.toString()} is not a function.`,
      );
    }
    descriptor.value = new Proxy(original, {
      apply: function (_, outerThis, args: any[]) {
        if (!outerThis['__transactionHost']) {
          throw new Error(`Failed to inject transaction host into ${target.constructor.name}`);
        }
        return (outerThis['__transactionHost'] as TransactionHost).withTransaction(
          propagation as Propagation,
          options as never,
          original.bind(outerThis, ...args),
        );
      },
    });
    copyMethodMetadata(original, descriptor.value);
  }) as MethodDecorator;
}

const paramIsPropagationType = (param: any): param is Propagation => {
  return typeof param === 'string' && Object.values(Propagation).includes(param as Propagation);
};
</file>

<file path="src/services/prisma/prisma-raw.service.ts">
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaRawService extends PrismaClient implements OnModuleInit {
  constructor() {
    super({
      log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async gracefulShutdown(application: INestApplication) {
    this.$on('beforeExit' as never, async () => {
      await application.close();
    });
  }
}
</file>

<file path="src/services/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaRawService } from './prisma-raw.service';
import { PrismaService } from './prisma.service';
import { TransactionHost } from './transactions/transaction-host';

@Global()
@Module({
  providers: [PrismaService, PrismaRawService, TransactionHost],
  exports: [PrismaService, PrismaRawService, TransactionHost],
})
export class PrismaModule {}
</file>

<file path="src/services/prisma/prisma.service.ts">
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { Prisma, PrismaClient } from '@prisma/client';
import { PRE_FILTER_OPERATIONS } from 'src/shared/constants/prisma.constant';
import { addCreationTimestamps, addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

const uniqueFieldsByModel: Record<string, string[]> = {};
const uniqueIndexFieldsByModel: Record<string, string[]> = {};

Prisma.dmmf.datamodel.models.forEach((model) => {
  // add unique fields derived from indexes
  const uniqueIndexFields: string[] = [];
  model.uniqueFields.forEach((field) => {
    uniqueIndexFields.push(field.join('_'));
  });
  uniqueIndexFieldsByModel[model.name] = uniqueIndexFields;

  // add id field and unique fields from @unique decorator
  const uniqueFields: string[] = [];
  model.fields.forEach((field) => {
    if (field.isId || field.isUnique) {
      uniqueFields.push(field.name);
    }
  });
  uniqueFieldsByModel[model.name] = uniqueFields;
});

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  constructor() {
    super({
      // log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    await this.$connect();

    Object.assign(
      this,
      this.$extends({
        query: {
          $allModels: {
            async $allOperations({ operation, args, query, model }) {
              const prisma = new PrismaClient();
              // filter the active records
              const filteredWhereConditions = {
                ...(args as any).where,
                isActive: true,
              };

              // change the operation from delete action to update action
              switch (operation) {
                case 'delete':
                  return await prisma[model].update({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps({ isActive: false }),
                  });
                case 'deleteMany':
                  return await prisma[model].updateMany({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps({ isActive: false }),
                  });
                case 'create':
                  return query({
                    ...args,
                    data: addCreationTimestamps(args.data),
                  });
                case 'createMany':
                  return query({
                    ...args,
                    data: (args.data as unknown[]).map((item: unknown) => addCreationTimestamps(item)),
                  });
                case 'update':
                case 'updateMany':
                  return query({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps(args.data),
                  });
                default:
                  if (PRE_FILTER_OPERATIONS.includes(operation)) {
                    const filterdArgs = {
                      ...args,
                      where: filteredWhereConditions,
                    } as unknown;
                    return query(filterdArgs);
                  }
                  return query(args);
              }
            },
          },
        },
      }),
    );
  }

  async gracefulShutdown(application: INestApplication) {
    this.$on('beforeExit' as never, async () => {
      await application.close();
    });
  }
}
</file>

<file path="src/services/storage/dto/storage.dto.ts">
export type StorageDTO = {
  size: number;
  url: string;
};
</file>

<file path="src/services/storage/shared/interfaces/file.interface.ts">
import { Readable } from 'node:stream';

export interface IFile {
  /** Name of the form field associated with this file. */
  fieldname: string;
  /** Name of the file on the uploader's computer. */
  originalname: string;
  /** Value of the `Content-Type` header for this file. */
  mimetype: string;
  /** Size of the file in bytes. */
  size: number;
  /**
   * A readable stream of this file. Only available to the `_handleFile`
   * callback for custom `StorageEngine`s.
   */
  stream: Readable;
  /** `DiskStorage` only: Directory to which this file has been uploaded. */
  destination: string;
  /** `DiskStorage` only: Name of this file within `destination`. */
  filename: string;
  /** `DiskStorage` only: Full path to the uploaded file. */
  path: string;
  /** `MemoryStorage` only: A Buffer containing the entire file. */
  buffer: Buffer;
}
</file>

<file path="src/services/storage/shared/interfaces/sharp.interface.ts">
import sharp from 'sharp';

export interface ISharpInputOptions {
  width?: number;
  height?: number;
  options?: sharp.SharpOptions;
}
</file>

<file path="src/services/storage/shared/interfaces/signed-upload-url.interface.ts">
export interface ISignedUploadUrlOptions {
  folder?: string;
  eager?: string;
}
</file>

<file path="src/services/storage/shared/types/cloudinary-config.types.ts">
import type { ConfigOptions, UploadApiErrorResponse, UploadApiResponse } from 'cloudinary';

export type CloudinaryModuleOptions = ConfigOptions;

export type CloudinaryResultResponse =
  | UploadApiResponse
  | UploadApiErrorResponse
  | PromiseLike<UploadApiResponse | UploadApiErrorResponse>;
</file>

<file path="src/services/storage/storage.module.ts">
import { Module, OnModuleInit } from '@nestjs/common';
import { StorageService } from './storage.service';
import { ConfigurableModuleClass } from './storgare.module-definition';

@Module({
  providers: [StorageService],
  exports: [StorageService],
})
export class StorageModule extends ConfigurableModuleClass implements OnModuleInit {
  constructor(private readonly storageService: StorageService) {
    super();
  }

  async onModuleInit() {
    await this.storageService.pingCloudinary();
  }
}
</file>

<file path="src/services/storage/storage.provider.ts">
import { ConfigOptions, v2 } from 'cloudinary';
import { CLD_API_KEY, CLD_API_SECRET, CLD_CLOUD_NAME } from 'src/app.config';
import { CLOUDINARY } from 'src/shared/constants/storage.constant';
export const CloudinaryProvider = {
  provide: CLOUDINARY,
  useFactory: (): ConfigOptions => {
    return v2.config({
      cloud_name: CLD_CLOUD_NAME,
      api_key: CLD_API_KEY,
      api_secret: CLD_API_SECRET,
    });
  },
};
</file>

<file path="src/services/storage/storage.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StorageService } from './storage.service';

describe('StorageService', () => {
  let service: StorageService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [StorageService],
    }).compile();

    service = module.get<StorageService>(StorageService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/storage/storage.service.ts">
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ResourceType, TransformationOptions, UploadApiErrorResponse, UploadApiOptions, UploadApiResponse, v2 } from 'cloudinary';
import sharp from 'sharp';
import { defaultCreateSignedUploadUrlOptions } from 'src/shared/constants/storage.constant';
import { Readable } from 'stream';
import { StorageDTO } from './dto/storage.dto';
import { ISharpInputOptions } from './shared/interfaces/sharp.interface';
import { ISignedUploadUrlOptions } from './shared/interfaces/signed-upload-url.interface';
import { CloudinaryModuleOptions } from './shared/types/cloudinary-config.types';
import { MODULE_OPTIONS_TOKEN } from './storgare.module-definition';

@Injectable()
export class StorageService {
  private logger = new Logger(StorageService.name);

  constructor(
    @Inject(MODULE_OPTIONS_TOKEN)
    private readonly options: CloudinaryModuleOptions,
  ) {
    v2.config(Object.assign({}, options));
  }

  async pingCloudinary() {
    try {
      const res = await v2.api.ping();
      this.logger.log(`Cloudinary ping response: ${res.status}`);
    } catch (e) {
      this.logger.warn('Cloudinary connection failed.');
      this.logger.error(e.error);
    }
  }

  /**
   * It takes a file, uploads it to cloudinary, and returns a promise
   * @param {IFile} file - IFile - This is the file object that is passed to the uploadFile method.
   * @param {UploadApiOptions} [options] - This is the options object that you can pass to the
   * uploader.upload_stream method.
   * @param {ISharpInputOptions} [sharpOptions] - This is an object that contains the options for sharp.
   * @returns {CloudinaryResultResponse},
   */
  async uploadFile(
    file: Express.Multer.File,
    options?: UploadApiOptions,
    sharpOptions?: ISharpInputOptions,
  ): Promise<UploadApiResponse | UploadApiErrorResponse> {
    return new Promise(async (resolve, reject) => {
      const upload = v2.uploader.upload_stream(options, async (error, result) => {
        if (error) {
          this.logger.error(error);
          return reject(error);
        } else {
          resolve(result);
        }
      });

      const stream: Readable = new Readable();
      stream._read = () => {};

      if (sharpOptions && file.mimetype.match(/^image/)) {
        const options = { width: 320, ...sharpOptions };
        const shrinkedImage = await sharp(file.buffer).resize(options).toBuffer();
        stream.push(shrinkedImage);
      } else {
        stream.push(file.buffer);
      }

      stream.push(null);
      stream.pipe(upload);
    });
  }

  /**
   * It returns a signed upload URL.
   * @see https://cloudinary.com/documentation/signatures#using_cloudinary_backend_sdks_to_generate_sha_authentication_signatures
   * @param {string} publicId - This is the public id of the file.
   * @param {ResourceType} resourceType - The type of the resource. See ./node_modules/cloudinary/types/index.d.ts
   * @param {ISignedUploadUrlOptions} [options] - This is an object that contains the options for signing.
   * @returns string
   */
  async createSignedUploadUrl(publicId: string, resourceType: ResourceType, options?: ISignedUploadUrlOptions) {
    options = { ...defaultCreateSignedUploadUrlOptions, ...options };

    const url = `https://api.cloudinary.com/v1_1/${this.options.cloud_name}/${resourceType}/upload`;
    const timestamp = Math.round(new Date().getTime() / 1000);

    const signature = v2.utils.api_sign_request(
      {
        timestamp,
        public_id: publicId,
        // eager: options.eager,
      },
      this.options.api_secret,
    );

    return {
      url,
      publicId,
      api_key: this.options.api_key,
      timestamp,
      eager: options.eager,
      folder: options.folder,
      signature,
    };
  }

  async checkFileExist(publicId: string): Promise<boolean> {
    try {
      const res = await v2.api.resource(publicId);
      return true;
    } catch (error) {
      this.logger.error(error);
      return false;
    }
  }

  async getSignedUrl(publicId: string, options?: TransformationOptions) {
    const isExisted = await this.checkFileExist(publicId);

    if (!isExisted) return null;
    return v2.utils.url(publicId, options);
  }

  async getStorageFile(publicId: string): Promise<StorageDTO | null> {
    try {
      // This will throw error when key not exists
      const file = await v2.api.resource(publicId);
      const url = v2.utils.url(publicId);
      return { size: file.bytes, url };
    } catch (error) {
      this.logger.error(error);
      return null;
    }
  }
  async deleteFile(publicId: string) {
    const isExisted = await this.checkFileExist(publicId);
    if (!isExisted) return false;

    await v2.uploader.destroy(publicId);
    return true;
  }

  async deleteManyFiles(publicIds: string[]) {
    type FileStatus = { publicId: string; isDeleted: boolean };
    const deletedFiles = await Promise.all(
      publicIds.map(
        (publicId) =>
          new Promise<{ publicId: string; isDeleted: boolean }>(async (res) => {
            const isDeleted = await this.deleteFile(publicId);
            res({ publicId, isDeleted });
          }),
      ),
    );

    const getResult = (condition: (f: FileStatus) => boolean) => deletedFiles.filter(condition).map((f) => f.publicId);
    return {
      deletedKeys: getResult((f) => f.isDeleted),
      deletedFailedKeys: getResult((f) => !f.isDeleted),
    };
  }
}
</file>

<file path="src/services/storage/storgare.module-definition.ts">
import { ConfigurableModuleBuilder } from '@nestjs/common';
import { CloudinaryModuleOptions } from './shared/types/cloudinary-config.types';

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } = new ConfigurableModuleBuilder<CloudinaryModuleOptions>({
  moduleName: 'StorageModule',
})
  .setExtras(
    {
      isGlobal: true,
    },
    (definition, extras) => ({
      ...definition,
      global: extras.isGlobal,
    }),
  )
  .setClassMethodName('forRoot')
  .build();
</file>

<file path="src/services/common.module.ts">
import { Module } from '@nestjs/common';
import { CLD_API_KEY, CLD_API_SECRET, CLD_CLOUD_NAME } from 'src/app.config';
import { AxiosModule } from './axios/axios.module';
import { EmailModule } from './email/email.module';
import { EventNestModule } from './event-emitter/event-emitter.module';
import { FcmModule } from './fcm/fcm.module';
import { GetstreamModule } from './getstream/getstream.module';
import { PrismaModule } from './prisma/prisma.module';
import { StorageModule } from './storage/storage.module';

@Module({
  imports: [
    /* Third-party Services */
    StorageModule.forRootAsync({
      useFactory: async () => ({
        cloud_name: CLD_CLOUD_NAME,
        api_key: CLD_API_KEY,
        api_secret: CLD_API_SECRET,
      }),
    }),
    PrismaModule,
    GetstreamModule,
    AxiosModule,
    FcmModule,
    EventNestModule,
    EmailModule,
  ],
})
export class CommonModule {}
</file>

<file path="src/shared/constants/audio-room.constant.ts">
export enum AudioRoomActivity {
  JOIN = 'JOIN',
  LEAVE = 'LEAVE',
}

export const AUDIO_ROOM_CONSTANT = {
  DEFAULT_VALUE_LEFT_AT: 0,
};
</file>

<file path="src/shared/constants/auth.constant.ts">
export const AUTH_CONSTANT = {
  OTP_CODE_LENGTH: 6, // 615123
  OTP_NEXT_SEND_TIMEOUT: 60, // 60 seconds
  OTP_EXPIRATION_TIMEOUT: 3 * 60, // 3 minutes
  OTP_SMS_MESSAGE: (otp: string) => `BK Sharing, register code is ${otp}`,
};
</file>

<file path="src/shared/constants/category.constant.ts">
export const MAX_CATEGORY_LEVEL = 2;
export const CATEGORY_DEFAULT_LEVEL = 1;
</file>

<file path="src/shared/constants/chat-message.constant.ts">
export enum SOCKET_DOMAINS {
  //   HOST_CMS = '',
  //   HOST_ECM = '*',
  LOCAL_FE = 'http://localhost:3000',
}

export enum SOCKET_CHAT_MESSAGE_EVENT {
  SEND_MESSAGE = 'send-message',
  JOIN_ROOM = 'join-room',
  READ_MESSAGE = 'read-message',
  NEW_MESSAGE = 'newMessage',
}

export const NUMBER_OF_MESSAGE_DEFAULT = 0;
export const NUMBER_MESSAGE_INCREMENT_DEFAULT = 1;
export const NUMBER_PARTICIPANT_INCREMENT_DEFAULT = 1;
export const NUMBER_OF_PARTICIPANT_DEFAULT = 1;
</file>

<file path="src/shared/constants/common.constant.ts">
export const COMMON_CONSTANT = {
  ARRAY_MAX_SIZE: 10,
  ARRAY_MIN_SIZE: 1,
  DEFAULT_INCREMENT: 1,
  DEFAULT_DECREMENT: 1,
  ZERO_VALUE: 0,
};

export const AXIOS_CONFIG = Symbol('AXIOS_CONFIG');

export const numberRegex = /^[0-9]+$/;

export const ACCOUNT_NOT_ACTIVE = false;
</file>

<file path="src/shared/constants/course.constant.ts">
import { CourseStatus } from '@prisma/client';

export const COURSE_PUBLIC_STATUS: CourseStatus[] = [CourseStatus.STOPPED, CourseStatus.APPROVED];

export const COURSE_UPDATE_STATUS: CourseStatus[] = [
  CourseStatus.PENDING,
  CourseStatus.STOPPED,
  CourseStatus.ARCHIVED,
  CourseStatus.DRAFT,
];
</file>

<file path="src/shared/constants/dashboard.constant.ts">
import { PaymentStatus, SubscriptionStatus } from '@prisma/client';

export const StatisticSubsriptionStatus: SubscriptionStatus[] = [
  SubscriptionStatus.ACTIVE,
  SubscriptionStatus.EXPIRED,
  SubscriptionStatus.CANCELED,
];

export const StatisticPaymentStatus: PaymentStatus[] = [PaymentStatus.DONE, PaymentStatus.EXPIRED, PaymentStatus.CANCELED];
</file>

<file path="src/shared/constants/date.constant.ts">
export const DATE_FORMAT = {
  YEAR_MONTH: {
    HYPHEN: 'YYYY-MM',
    DOT: 'YYYY.MM',
  },
  DATE: {
    STICKY: 'YYYYMMDD',
    HYPHEN: 'YYYY-MM-DD',
    UNDERSCORE: 'YYYY_MM_DD',
    SLASH: 'YYYY/MM/DD',
    DOT: 'YYYY.MM.DD',
    STRING: 'MMMM DD, YYYY',
    TEXT: 'YYYY년 MM월 DD일',
    NO_SPACE: 'YYYYMMDD',
  },
  DATE_TIME: {
    HYPHEN: 'YYYY-MM-DD hh:mm',
    SLASH: 'YYYY/MM/DD hh:mm',
    DOT: 'YYYY.MM.DD hh:mm',
    DOWNLOAD: 'YYYY-MM-DD_hh:mm',
  },
  DATE_TIME_SECOND: {
    HYPHEN: 'YYYY-MM-DD hh:mm:ss',
    HYPHEN_V1: 'YYYY-MM-DD HH:mm:ss',
    SLASH: 'YYYY/MM/DD hh:mm:ss',
    DOT: 'YYYY.MM.DD hh:mm:ss',
    DOWNLOAD: 'YYYY-MM-DD_hh:mm:ss',
    NO_SPACE: 'YYYYMMDDHHmmss',
    ISO8601: 'YYYY-MM-DDThh:mm:ss',
    ISO8601_BEGIN: 'YYYY-MM-DDT00:00:00',
    ISO8601_END: 'YYYY-MM-DDT23:59:59',
  },
  TIME: {
    _12H: 'A hh:mm',
    _12H_PICKER: 'hh:mm A',
    _24H: 'H:m',
  },
  MONTH_YEAR: 'MM-YYYY',
};

export const NO_MONTHS_OF_YEAR = 12;
export const EXCEL_DATE_FORMAT = DATE_FORMAT.DATE.HYPHEN;

export const DAY_OF_WEEK = {
  0: 'SUNDAY',
  1: 'MONDAY',
  2: 'TUESDAY',
  3: 'WEDNESDAY',
  4: 'THURSDAY',
  5: 'FRIDAY',
  6: 'SATURDAY',
};
</file>

<file path="src/shared/constants/event.constant.ts">
export enum AudioCallChannel {
  LEAVE_CALL = 'call.session_participant_left',
}
</file>

<file path="src/shared/constants/notification.constant.ts">
import { AccountSuspensionType, CourseSuspensionType, NotificationType } from '@prisma/client';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';

export const NOTIFICATION_MESSAGES = new Map<NotificationType, Record<string, string>>([
  [NotificationType.COURSE_CREATED, { title: 'New Course Created', content: 'A new course has been created successfully.' }],
  [NotificationType.COURSE_UPDATED, { title: 'Course Updated', content: 'A course has been updated successfully.' }],
  [NotificationType.COURSE_DELETED, { title: 'Course Deleted', content: 'A course has been deleted from the platform.' }],
  [NotificationType.COURSE_APPROVED, { title: 'Course Approved', content: 'Your course has been approved successfully.' }],
  [NotificationType.COURSE_REJECTED, { title: 'Course Rejected', content: 'Your course has been rejected.' }],
  [
    NotificationType.COURSE_SUSPENDED_WARNING,
    { title: 'Course Suspension Warn', content: 'Please review your course content for ensuring the quality.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_3_DAYS,
    { title: 'Course Suspended', content: 'Your course has been suspended for 3 days.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_7_DAYS,
    { title: 'Course Suspended', content: 'Your course has been suspended for 7 days.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_PERMANENTLY,
    { title: 'Course Suspended', content: 'Your course has been suspended permanently.' },
  ],
  [
    NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION,
    { title: 'Subscription Canceled', content: 'Your subscription has been canceled because the course has been suspended.' },
  ],
  [
    NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION,
    { title: 'Subscription Canceled', content: 'Your subscription has been canceled by the mentor.' },
  ],
  [
    NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION,
    {
      title: 'Subscription Refunded',
      content: 'Your subscription has been refunded because the course has been suspended. We will try refunding within a week',
    },
  ],
  [
    NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION,
    {
      title: 'Subscription Refunded',
      content: 'Your subscription has been refunded by the mentor. We will try refunding within a week',
    },
  ],
  [
    NotificationType.MENTOR_REGISTERD,
    { title: 'Mentor Registered', content: 'A new mentor has been registered waiting for the consideration.' },
  ],
  [NotificationType.MENTOR_APPROVED, { title: 'Mentor Approved', content: 'Your mentor request has been approved.' }],
  [NotificationType.MENTOR_REJECTED, { title: 'Mentor Rejected', content: 'Your mentor request has been rejected.' }],
  [NotificationType.AUDIO_CALL_CREATED, { title: 'Audio Call Created', content: 'You have a new audio call' }],
  [
    NotificationType.SUBSCRIPTION_CREATED,
    { title: 'Subscription Request', content: 'A new subscription request has been made for your course.' },
  ],
  [
    NotificationType.SUBSCRIPTION_APPROVED,
    { title: 'Subscription Approved', content: 'Your subscription request has been approved successfully.' },
  ],
  [
    NotificationType.SUBSCRIPTION_REJECTED,
    { title: 'Subscription Rejected', content: 'Your subscription request has been rejected.' },
  ],
  [NotificationType.SUBSCRIPTION_EXPIRED, { title: 'Subscription Expired', content: 'This subscription has been expired.' }],
  [NotificationType.PAYMENT_SUCCESS, { title: 'Payment Successful', content: 'The subscription is paid successfully' }],
  [
    NotificationType.PAYMENT_FAILED,
    { title: 'Payment Failed', content: 'There was an issue processing your payment. Please try again.' },
  ],
  [
    NotificationType.DISCOUNT_AVAILABLE,
    { title: 'New Discount Available', content: "A new discount is now available. Don't miss out!" },
  ],
  [NotificationType.ADMIN_APPROVAL, { title: 'Admin Approval Required', content: 'Your request is awaiting admin approval.' }],
  [NotificationType.GENERAL_NOTIFICATION, { title: 'Notification', content: 'You have a new notification.' }],
  [NotificationType.COURSE_REPORTED, { title: 'Course Reported', content: 'One course has been reported.' }],
  [NotificationType.MENTOR_REPORTED, { title: 'Mentor Reported', content: 'One mentor has been reported.' }],
  [NotificationType.FEEDBACK_REPORTED, { title: 'Feedback Reported', content: 'One feedback has been reported.' }],
  [
    NotificationType.REPORT_RESOLVED,
    { title: 'Report Resolved', content: 'Your report has been resolved. Please check the resolution.' },
  ],
  [
    NotificationType.REPORT_REJECTED,
    { title: 'Report Rejected', content: 'Your report has been rejected. Please check the resolution.' },
  ],
  [
    NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
    {
      title: 'Your feedback has been reported by author of the course',
      content: 'Your feedback has been removed because of violation or inappropriate content.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_3_DAYS,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended for 3 days due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_7_DAYS,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended for 7 days due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_PERMANENTLY,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended permanently due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_WARNING,
    {
      title: 'Account Suspension Warning',
      content: 'Your account has been reported for violation of terms and conditions. Please review your activities.',
    },
  ],
]);

export const getNotificationMessage = (type: NotificationType) => {
  if (!NOTIFICATION_MESSAGES.has(type)) {
    throw new ActionFailedException(ActionFailed.NOTIFICATION_TYPE_NOT_FOUND, 'Notification type not found.');
  }
  return NOTIFICATION_MESSAGES.get(type);
};

export const NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER = new Map<AccountSuspensionType, NotificationType>([
  [AccountSuspensionType.ACCOUNT_NOT_SUSPENDED, NotificationType.ACCOUNT_SUSPENDED_WARNING],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_3_DAYS, NotificationType.ACCOUNT_SUSPENDED_3_DAYS],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_7_DAYS, NotificationType.ACCOUNT_SUSPENDED_7_DAYS],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_PERMANENTLY, NotificationType.ACCOUNT_SUSPENDED_PERMANENTLY],
]);

export const NOTIFICATION_SUSPENSION_COURSE_MAPPER = new Map<CourseSuspensionType, NotificationType>([
  [CourseSuspensionType.COURSE_NOT_SUSPENDED, NotificationType.COURSE_SUSPENDED_WARNING],
  [CourseSuspensionType.COURSE_SUSPENDED_3_DAYS, NotificationType.COURSE_SUSPENDED_3_DAYS],
  [CourseSuspensionType.COURSE_SUSPENDED_7_DAYS, NotificationType.COURSE_SUSPENDED_7_DAYS],
  [CourseSuspensionType.COURSE_SUSPENDED_PERMANENTLY, NotificationType.COURSE_SUSPENDED_PERMANENTLY],
]);

export const EMAIL_NOTIFICATION = {
  ACCOUNT_REGISTERED: {
    subject: 'BK SHARING - Welcome to BK Sharing',
    text: 'Welcome to BK Sharing. Your account has been created successfully. Please verify your email address.',
  },
  ACCOUNT_RESET_PASSWORD: {
    subject: 'BK SHARING - Reset Password',
    text: 'You have requested to reset your password. Please click on the link to reset your password.',
  },
};

export const EMAIL_TEMPLATES = {
  EMAIL_VERIFICATION: './authentication-email-verification',
  RESET_PASSWORD: './reset-password-verification',
};

export const EMAIL_PATH = {
  EMAIL_VERIFICATION: 'email-verification/',
  RESET_PASSWORD: 'reset-password-verification/',
};
</file>

<file path="src/shared/constants/payment.constant.ts">
export const ReturnPaymentStatus = {
  SUCCESSFUL_STATUS: '00',
  EXPIRED_STATUS: '11',
};
</file>

<file path="src/shared/constants/prisma.constant.ts">
import { defaultSortAsc, defaultSortDesc } from '../helpers/query.helper';

export const PRE_FILTER_OPERATIONS = ['findMany', 'findFirst', 'findFirstOrThrow', 'findUnique', 'findUniqueOrThrow', 'count'];
export const TRANSACTION_TIMEOUT = { timeout: 10000 * 60 * 3, maxWait: 100000 };
export const IS_ACTIVE_NESTED = { isActive: true };
export const IS_INACTIVE_NESTED = { isActive: false };
export const ORDER_CREATED_AT_DESC = { orderBy: defaultSortDesc };
export const ORDER_CREATED_AT_ASC = { orderBy: defaultSortAsc };
</file>

<file path="src/shared/constants/report.constant.ts">
import { NotificationType, ReportType } from '@prisma/client';

export const ReportNotificationMap = new Map<ReportType, NotificationType>([
  [ReportType.COURSE_UNQUALIFIED, NotificationType.COURSE_REPORTED],
  [ReportType.FEEDBACK_INAPPROPRIATE, NotificationType.FEEDBACK_REPORTED],
  [ReportType.MENTOR_ISSUES, NotificationType.MENTOR_REPORTED],
]);

export const REPORT_SUBSCRIPTION_TYPE: ReportType[] = [ReportType.COURSE_UNQUALIFIED, ReportType.MENTOR_ISSUES];
export const REPORT_FEEDBACK_TYPE: ReportType[] = [ReportType.FEEDBACK_INAPPROPRIATE];

export enum ReportSubscriptionPushnishment {
  MENTOR_SUSPENSION = 'MENTOR_SUSPENSION',
  COURSE_SUSPENSION = 'COURSE_SUSPENSION',
}

export const REPORT_DURATION_TIME_QUERY = 3 * 30 * 24 * 60 * 60;
</file>

<file path="src/shared/constants/storage.constant.ts">
import { ISignedUploadUrlOptions } from 'src/services/storage/shared/interfaces/signed-upload-url.interface';

export const CLOUDINARY = Symbol('CLOUDINARY');

export const defaultCreateSignedUploadUrlOptions: Partial<ISignedUploadUrlOptions> = {
  folder: undefined,
  eager: undefined,
};

export const CLD_UPLOAD_IMAGE_OPTIONS = {
  access_mode: 'public',
  folder: 'images',
  use_filename: true,
};

export enum CLD_FOLDER {
  IMAGES = 'images',
  VIDEOS = 'videos',
  CVs = 'CVs',
  FILES = 'files',
}

export const IMAGE_TYPE = 'image';
</file>

<file path="src/shared/constants/subscription.constant.ts">
import { SubscriptionStatus } from '@prisma/client';

export const SUBSCRIPTION_NOT_CANCELED_STATUS: SubscriptionStatus[] = [
  SubscriptionStatus.CANCELED,
  SubscriptionStatus.REJECTED,
  SubscriptionStatus.EXPIRED,
  SubscriptionStatus.ENDED,
];

export const SUBSCRIPTION_ACTIVE_STATUS: SubscriptionStatus[] = [
  SubscriptionStatus.ACTIVE,
  SubscriptionStatus.PENDING,
  SubscriptionStatus.ACCEPTED,
];

export const SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO: SubscriptionStatus[] = [
  SubscriptionStatus.ACCEPTED,
  SubscriptionStatus.ACTIVE,
];

// 3 days
// export const MIN_NEW_SUBSCRIPTION_DURATION = 60 * 60 * 24 * 3 * 1000;
export const MIN_NEW_SUBSCRIPTION_DURATION = 0;

// 2 days
export const EXPIRED_PENDING_SUBSCRIPTION = 60 * 60 * 24 * 2 * 1000;

// 1 days
// export const EXPIRED_SUBSCRIPTION_AFTER_APPROVED = 60 * 60 * 24 * 1000;
export const EXPIRED_SUBSCRIPTION_AFTER_APPROVED = 60 * 60 * 24 * 1000;
</file>

<file path="src/shared/enums/common.enum.ts">
export enum SYMBOL {
  PLUS = '+',
  MINUS = '-',
  TIMES = '*',
  DIVIDE = '/',
  COMMA = ',',
  DOT = '.',
}

export enum DateRangeFilter {
  ALL = 'ALL',
  TODAY = 'TODAY',
  ONE_WEEK = '1_WEEK',
  ONE_MONTH = '1_MONTH',
  THREE_MONTHS = '3_MONTHS',
  SIX_MONTHS = '6_MONTHS',
  ONE_YEAR = '1_YEAR',
}
</file>

<file path="src/shared/enums/query.enum.ts">
export enum SortOrder {
  ASC = 'asc',
  DESC = 'desc',
}
</file>

<file path="src/shared/exceptions/action-failed.exception.ts">
import { ConflictException } from '@nestjs/common';

export enum ActionFailed {
  DATE_TIME_INVALID = 'DATE_TIME_INVALID',
  AUTH_ACCOUNT_FORBIDDEN = 'AUTH_ACCOUNT_FORBIDDEN',
  AUTH_TOKEN_INVALID = 'AUTH_TOKEN_INVALID',
  UNKNOW_PROPAGATION_MODE = 'UNKNOW_PROPAGATION_MODE',
  ACCOUNT_NOT_FOUND = 'ACCOUNT_NOT_FOUND',
  ACCOUNT_INVALID_ROLE = 'ACCOUNT_INVALID_ROLE',
  ACCOUNT_EMAIL_EXISTED = 'ACCOUNT_EMAIL_EXISTED',
  ACCOUNT_PHONE_NUMBER_EXISTED = 'ACCOUNT_PHONE_NUMBER_EXISTED',
  ACCOUNT_NOT_VERIFIED = 'ACCOUNT_NOT_VERIFIED',
  ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED',
  ACCOUNT_EMAIL_NOT_FOUND = 'ACCOUNT_EMAIL_NOT_FOUND',
  CLASS_TYPE_NOT_FOUND = 'CLASS_TYPE_NOT_FOUND',
  INCORRECT_PASSWORD = 'INCORRECT_PASSWORD',
  AUTH_PHONE_EXISTED = 'AUTH_PHONE_EXISTED',
  AUTH_EMAIL_EXISTED = 'AUTH_EMAIL_EXISTED',
  AUTH_PHONE_NUMBER_NOT_REGISTERED = 'AUTH_PHONE_NUMBER_NOT_REGISTERED',
  AUTH_ACHIEVEMENT_INVALID_TYPE = 'AUTH_ACHIEVEMENT_INVALID_TYPE',
  AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED = 'AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED',
  CATEGORY_NOT_FOUND = 'CATEGORY_NOT_FOUND',
  CATEGORY_LEVEL_EXCEED_MAXIMUM = 'CATEGORY_LEVEL_EXCEED_MAXIMUM',
  CATEGORY_PARENT_SHOULD_NOT_RECOMMENDED = 'CATEGORY_PARENT_SHOULD_NOT_RECOMMENDED',
  CATEGORY_ORDINAL_OVERLAP = 'CATEGORY_ORDINAL_OVERLAP',
  CATEGORY_PARENT_DELETE_FAILED = 'CATEGORY_PARENT_DELETE_FAILED',
  CATEGORY_HAS_CHILD_CATEGORIES = 'CATEGORY_HAS_CHILD_CATEGORIES',
  IMAGE_ENABLE_QUANTITY_NOT_MATCH = 'IMAGE_ENABLE_QUANTITY_NOT_MATCH',
  AUDIO_CALL_STARTS_AT_INVALID = 'AUDIO_CALL_STARTS_AT_INVALID',
  MENTOR_NOT_FOUND = 'MENTOR_NOT_FOUND',
  MENTOR_INTERVIEW_ACCEPTED = 'MENTOR_INTERVIEW_ACCEPTED',
  MENTOR_INTERVIEW_EXISTED = 'MENTOR_INTERVIEW_EXISTED',
  MENTOR_CANNOT_UPDATE_RESULT = 'MENTOR_CANNOT_UPDATE_RESULT',
  MENTOR_NOT_BELONG_TO_THIS_ACCOUNT = 'MENTOR_NOT_BELONG_TO_THIS_ACCOUNT',
  MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND = 'MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND',
  MENTOR_NOT_YET_ACCEPTED = 'MENTOR_NOT_YET_ACCEPTED',
  MENTOR_SCHEDULE_OVERLAP = 'MENTOR_SCHEDULE_OVERLAP',
  MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR = 'MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR',
  MENTOR_SCHEDULE_END_TIME_BEFORE_START_TIME = 'MENTOR_SCHEDULE_END_TIME_BEFORE_START_TIME',
  MENTOR_SCHEDULE_NOT_FOUND = 'MENTOR_SCHEDULE_NOT_FOUND',
  CALL_INVALID = 'CALL_INVALID',
  CALL_NOT_FOUND = 'CALL_NOT_FOUND',
  CALL_AUDIO_CAN_NOT_START = 'CALL_AUDIO_CAN_NOT_START',
  CALL_AUDIO_NOT_HAVE_PERMISSION = 'CALL_AUDIO_NOT_HAVE_PERMISSION',
  CALL_AUDIO_CAN_NOT_JOIN = 'CALL_AUDIO_CAN_NOT_JOIN',
  CALL_AUDIO_CAN_NOT_LEAVE = 'CALL_AUDIO_CAN_NOT_LEAVE',
  CALL_AUDIO_CAN_NOT_CANCEL = 'CALL_AUDIO_CAN_NOT_CANCEL',
  CALL_PARTICIPANT_JOINED = 'CALL_PARTICIPANT_JOINED',
  CALL_PARTICIPANT_NOT_FOUND = 'CALL_PARTICIPANT_NOT_FOUND',
  COURSE_NOT_FOUND = 'COURSE_NOT_FOUND',
  COURSE_NOT_BELONG_TO_THIS_ACCOUNT = 'COURSE_NOT_BELONG_TO_THIS_ACCOUNT',
  COURSE_CANNOT_VIEW_DETAIL = 'COURSE_CANNOT_VIEW_DETAIL',
  COURSE_SECTION_NOT_FOUND_IN_COURSE = 'COURSE_SECTION_NOT_FOUND_IN_COURSE',
  COURSE_STATUS_CANNOT_UPDATE = 'COURSE_STATUS_CANNOT_UPDATE',
  COURSE_NOT_AVAILABLE = 'COURSE_NOT_AVAILABLE',
  COURSE_HAS_ACTIVE_SUBSCRIPTION = 'COURSE_HAS_ACTIVE_SUBSCRIPTION',
  SUBSCRIPTION_NOT_BELONG_TO_USER = 'SUBSCRIPTION_NOT_BELONG_TO_USER',
  SUBSCRIPTION_NOT_AVAILABLE = 'SUBSCRIPTION_NOT_AVAILABLE',
  SUBSCRIPTION_NOT_MAKE_PAYMENT = 'SUBSCRIPTION_NOT_MAKE_PAYMENT',
  SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW = 'SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW',
  SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE = 'SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE',
  SUBSCRIPTION_NOT_CANCEL = 'SUBSCRIPTION_NOT_CANCEL',
  SUBSCRIPTION_ALREADY_ACTIVE = 'SUBSCRIPTION_ALREADY_ACTIVE',
  SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS = 'SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS',
  SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT = 'SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT',
  SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE = 'SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE',
  PAYMENT_NOT_AVAILABLE = 'PAYMENT_NOT_AVAILABLE',
  MENTOR_SCHEDULE_NOT_AVAILABLE = 'MENTOR_SCHEDULE_NOT_AVAILABLE',
  MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK = 'MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK',
  MENTOR_SCHEDULE_IS_BOOKED = 'MENTOR_SCHEDULE_IS_BOOKED',
  CHAT_ROOM_NOT_INCLUDE_USER = 'CHAT_ROOM_NOT_INCLUDE_USER',
  NOTIFICATION_TYPE_NOT_FOUND = 'NOTIFICATION_TYPE_NOT_FOUND',
  NOTIFICATION_INVALID_RELATION_TYPE = 'NOTIFICATION_INVALID_RELATION_TYPE',
  FEEDBACK_NOT_ENOUGH_PERMISSION = 'FEEDBACK_NOT_ENOUGH_PERMISSION',
  FEEDBACK_STUDENT_MUST_TAKE_THE_COURSE_OF_MENTOR = 'FEEDBACK_STUDENT_MUST_TAKE_THE_COURSE_OF_MENTOR',
  FEEDBACK_NOT_FOUND = 'FEEDBACK_NOT_FOUND',
  FEEDBACK_NOT_BELONG_TO_REVIEWER = 'FEEDBACK_NOT_BELONG_TO_REVIEWER',
  FEEDBACK_ALREADY_EXISTS = 'FEEDBACK_ALREADY_EXISTS',
  FEEDBACK_REQUIRE_COURSE_OR_MENTOR_ID = 'FEEDBACK_REQUIRE_COURSE_OR_MENTOR_ID',
  REPORT_INVALID_TYPE = 'REPORT_INVALID_TYPE',
  REPORT_NOT_FOUND = 'REPORT_NOT_FOUND',
  REPORT_FEEDBACK_NOT_FOUND = 'REPORT_FEEDBACK_NOT_FOUND',
  REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO = 'REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO',
  REPORT_INVALID_PUSHNISHMENT = 'REPORT_INVALID_PUSHNISHMENT',
}

export class ActionFailedException extends ConflictException {
  constructor(action: ActionFailed, message?: string, attachment?: object) {
    super({ action, message, attachment });
    super.name = ActionFailedException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/asset-file-not-existed.exception.ts">
import { ConflictException } from '@nestjs/common';

export class AssetFileNotExisted extends ConflictException {
  constructor(fileId?: number | number[]) {
    const message = `File id(s) = ${typeof fileId === 'number' ? fileId : fileId.join(', ')} doesn't exist`;
    super(message);
    super.name = AssetFileNotExisted.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/database-connnection.exception.ts">
import { InternalServerErrorException } from '@nestjs/common';

export class DatabaseConnectionException extends InternalServerErrorException {
  constructor(message: string) {
    const errorMessage = `Database connection error: ${message}`;
    super(errorMessage);
    super.name = DatabaseConnectionException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/entity-not-found.exception.ts">
import { NotFoundException } from '@nestjs/common';
import { capitalize } from 'lodash';

export class EntityNotFoundException extends NotFoundException {
  constructor(entityName?: string, errorMsg?: string) {
    let message = entityName ? `${capitalize(entityName)} not found.` : 'Entity not found';
    if (errorMsg) message = errorMsg;
    super(message);
    super.name = EntityNotFoundException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/key-duplication.exception.ts">
import { ConflictException } from '@nestjs/common';

export class KeyDuplicationException extends ConflictException {
  constructor(keyName: string, entityName?: string) {
    const message = `Key ${entityName} in model [${keyName}] is duplicated`;
    super(message);
    super.name = KeyDuplicationException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/prisma-client-validation.exception.ts">
import { UnprocessableEntityException } from '@nestjs/common';

export class PrismaClientValidationException extends UnprocessableEntityException {
  constructor(message?: string) {
    message = message;
    super(message);
    super.name = PrismaClientValidationException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/relation-violation.request.ts">
import { ConflictException } from '@nestjs/common';

export class RelationViolationException extends ConflictException {
  constructor(relationName: string, modelA: string, modelB: string) {
    const errorMessage = `The change you are trying to make would violate the required relation ${relationName} between the ${modelA} and ${modelB} models.`;
    super(errorMessage);
    super.name = RelationViolationException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/toss-payment-validate.exception.ts">
export class ValidationException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationException';
  }
}
</file>

<file path="src/shared/exceptions/unknown-prisma.exception.ts">
import { ConflictException } from '@nestjs/common';

export class UnknownPrismaException extends ConflictException {
  constructor(message: string) {
    const errorMessage = `An unknown error occurred with Prisma: ${message}`;
    super(errorMessage);
    super.name = UnknownPrismaException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/write-fail-exception.ts">
import { ConflictException } from '@nestjs/common';

export class WriteFailedException extends ConflictException {
  constructor(action: 'create' | 'update' | 'delete', errorMessage: string) {
    const message = `Can't perform ${action} because ${errorMessage}`;
    super(message);
    super.name = WriteFailedException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/write-relation-not-found.exception.ts">
import { ConflictException } from '@nestjs/common';
import { capitalize, startCase, toLower } from 'lodash';

export class WriteRelationNotFoundException extends ConflictException {
  constructor(action?: 'create' | 'update' | 'delete', conflictEntityName: string = 'entity', realCause?: string) {
    const entityName = startCase(toLower(conflictEntityName));
    let message = action ? `${capitalize(action)} action` : 'Action';
    message += ` can't execute due to not found ${entityName} or related to ${entityName}.`;
    message += realCause ? ` Detail: ${realCause}` : '';
    super(message);
    super.name = WriteRelationNotFoundException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/generics/base.response.ts">
import { Nullable } from './type.helper';

export class BaseResponse<T> {
  data: Nullable<T | null>;
  message: string;

  private constructor(data: Nullable<T>, message: string) {
    this.data = data;
    this.message = message;
  }

  public static of<T>(data: T): BaseResponse<T> {
    return new BaseResponse(data, 'OK');
  }

  public static error<T>(error: any): BaseResponse<Nullable<T>> {
    return new BaseResponse(null, error);
  }

  public static ok<T>(): BaseResponse<Nullable<T>> {
    return new BaseResponse(null, 'OK');
  }
}

export type Success<T> = { success: true; data: T };
export type Failure<E> = { success: false; error: E };
export type Result<T, E> = Success<T> | Failure<E>;
</file>

<file path="src/shared/generics/pagination.request.ts">
import { Transform } from 'class-transformer';
import { IsNumber, IsOptional, Min } from 'class-validator';

export class PaginationREQ {
  @IsNumber()
  @IsOptional()
  @Min(1)
  @Transform(({ value }) => value && parseInt(value))
  pageSize?: number;

  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => value && parseInt(value))
  @Min(1)
  pageNumber?: number;
}
</file>

<file path="src/shared/generics/pagination.response.ts">
import { Nullable } from './type.helper';

export class PaginationResponse<T> {
  data: Nullable<T | null>;
  total: any;

  private constructor(data: Nullable<T>, total: number) {
    this.data = data;
    this.total = total;
  }

  public static of<T>(data: T[]): PaginationResponse<T[]> {
    return new PaginationResponse(data, data.length);
  }

  public static ofWithTotal<T>(data: T[], total: number): PaginationResponse<T[]> {
    return new PaginationResponse(data, total);
  }

  public static ok<T>(): PaginationResponse<T[]> {
    return new PaginationResponse(null, null);
  }
}
</file>

<file path="src/shared/generics/toss-payment-result.response.ts">
export type Success<T> = { success: true; _tag: 'Success'; data: T };
export type Failure<E> = { success: false; _tag: 'Failure'; error: E };
export type Result<T, E> = Success<T> | Failure<E>;
</file>

<file path="src/shared/generics/type.helper.ts">
/* Nil */
export type Nil<T> = T | null | undefined;
export type NilFields<T> = {
  [K in keyof T]?: T[K] | null | undefined;
};
export type WithNilFields<T, Fields extends keyof T> = {
  [K in keyof T]: K extends Fields ? T[K] | null | undefined : T[K];
};
export type WithNonNilFields<T, Fields extends keyof T> = {
  [K in Fields]-?: T[K]; // Ensure the keys in Fields are non-nullable and required
} & {
  [K in Exclude<keyof T, Fields>]?: T[K] | null | undefined; // Make all other keys nullable and optional
};

/* Nullable */
export type Nullable<T> = T | null;
export type NullableFields<T> = {
  [K in keyof T]?: T[K] | null;
};
export type WithNullableFields<T, Fields extends keyof T> = {
  [K in keyof T]: K extends Fields ? T[K] | null : T[K];
};
export type WithNonNullableFields<T, Fields extends keyof T> = {
  [K in Fields]-?: T[K]; // Ensure the keys in Fields are non-nullable and required
} & {
  [K in Exclude<keyof T, Fields>]?: T[K] | null; // Make all other keys nullable and optional
};

/* Deep Nullable */
export type DeepNullableBy<T, Fields extends keyof T> = {
  [K in keyof T]?: K extends Fields ? DeepNullableBy<T[K], any> | null : T[K];
};
export type DeepNullable<T> = {
  [K in keyof T]: DeepNullable<T[K]> | null;
};

export type DeepPartialBy<T, Fields extends keyof T> = {
  [K in keyof T]?: K extends Fields ? DeepPartialBy<T[K], any> : T[K];
};
export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type ExcelSheetValue<T> = { [key in keyof T]: { name: string; width?: number } };

export type ExcelSheetExtendValue<T> = {
  [K in keyof T]: T[K] extends Array<infer E>
    ? {
        [P in keyof E as `${K & string}${Extract<P, number>}`]: {
          name: `${Extract<P, number>}`;
          width?: number;
          idx: number;
        };
      }
    : { name: string; width?: number; idx: number };
};

export type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};

export type Success<T> = { success: true; _tag: 'Success'; data: T };
export type Failure<E> = { success: false; _tag: 'Failure'; error: E };
export type Result<T, E> = Success<T> | Failure<E>;

export const SuccessOrFailResponse = Object.freeze({
  Success: <T, E>(data: T): Result<T, E> => ({ success: true, _tag: 'Success', data }),
  Failure: <T, E>(error: E): Result<T, E> => ({ success: false, _tag: 'Failure', error }),
});
</file>

<file path="src/shared/helpers/add-timestamp.helper.ts">
import { Nil } from '../generics/type.helper';

export const addCreationTimestamps = (obj: Nil<any>) => {
  return {
    ...obj,
    createdAt: new Date().valueOf(),
    updatedAt: new Date().valueOf(),
  };
};

export const addUpdationTimestamps = (obj: Nil<any>) => {
  return {
    ...obj,
    updatedAt: new Date().valueOf(),
  };
};
</file>

<file path="src/shared/helpers/category.helper.ts">
import { Nil } from '../generics/type.helper';

export function generateSlug(str?: Nil<string>): string | undefined {
  if (!str) return undefined;
  return str.toLowerCase().replace(/ /g, '-');
}
</file>

<file path="src/shared/helpers/common.helper.ts">
import { AxiosError } from 'axios';
import { Result, SuccessOrFailResponse } from '../generics/type.helper';
import { parseHourMinFromString } from '../parsers/datetime.parse';

export const nowEpoch = () => new Date().valueOf();
export const runFunctionWithCondition = (condition: boolean, fn: (...args: any[]) => any | Promise<any>) => {
  if (condition) {
    fn();
  }
};

export const makeResult = async <T>(execution: () => Promise<T>): Promise<Result<T, AxiosError>> => {
  try {
    return SuccessOrFailResponse.Success(await execution());
  } catch (error) {
    if (error instanceof AxiosError) {
      return SuccessOrFailResponse.Failure<T, AxiosError>(error);
    }
    throw error;
  }
};

export const resolveUrlString = (host: string, path: string) => {
  let trimmedHost = host.trim();
  let trimmedPath = path.trim();

  while (trimmedHost.endsWith('/') && trimmedPath.startsWith('\\')) {
    trimmedHost = trimmedHost.slice(0, -1);
  }

  while (trimmedPath.startsWith('/') && trimmedPath.startsWith('\\')) {
    trimmedPath = trimmedPath.slice(1);
  }

  return `${trimmedHost}/${trimmedPath}`;
};

export const checkHourMinStartOverlap = (start1: string, end1: string, start2: string = null, end2: string = null) => {
  const start1Date = parseHourMinFromString(start1);
  const end1Date = parseHourMinFromString(end1);
  const start2Date = parseHourMinFromString(start2);
  const end2Date = parseHourMinFromString(end2);

  if (start1Date >= end1Date || start2Date >= end2Date) {
    return true;
  } else if (start1Date >= start2Date && start1Date < end2Date) {
    return true;
  } else if (end1Date > start2Date && end1Date <= end2Date) {
    return true;
  }

  return false;
};
</file>

<file path="src/shared/helpers/date-range.helper.ts">
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { DateRangeFilter } from '../enums/common.enum';
import { getDiffOfTwoDays, getMillisecondsFromCurrentDate } from '../parsers/datetime.parse';

export const filterByDateRange = (dateRange: DateRangeFilter) => {
  switch (dateRange) {
    case DateRangeFilter.TODAY:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ days: 0, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_WEEK:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ days: 7, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_MONTH:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 1, fromBeginning: true }) },
      };
    case DateRangeFilter.THREE_MONTHS:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 3, fromBeginning: true }) },
      };
    case DateRangeFilter.SIX_MONTHS:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 6, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_YEAR:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ years: 1, fromBeginning: true }) },
      };
    default:
      return {};
  }
};

export const getDiffDaysOfDateRange = (dateRange: DateRangeFilter) => {
  let diff: any;
  switch (dateRange) {
    case DateRangeFilter.TODAY:
      return 0;
    case DateRangeFilter.ONE_WEEK:
      return 7;
    case DateRangeFilter.ONE_MONTH:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 1 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.THREE_MONTHS:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 3 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.SIX_MONTHS:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 6 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.ONE_YEAR:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ years: 1 }), nowEpoch());
      return diff.days;
  }
};
</file>

<file path="src/shared/helpers/function.helper.ts">
export const asyncSome = async <T>(arr: T[], predicate: (e: T) => Promise<boolean>): Promise<boolean> => {
  for (const e of arr) {
    if (await predicate(e)) return true;
  }

  return false;
};
</file>

<file path="src/shared/helpers/pagination.helper.ts">
export class QueryPagingHelper {
  static queryPaging({ pageSize, pageNumber }: { pageSize?: number; pageNumber?: number }): {
    take?: number;
    skip?: number;
  } {
    if (!pageNumber || !pageSize) return {};
    return {
      skip: (pageNumber - 1) * pageSize,
      take: pageSize,
    };
  }
}
</file>

<file path="src/shared/helpers/path.helper.ts">
import { resolve } from 'path';

export const resolvePathFromRoot = (...paths: string[]): string => {
  return resolve(process.cwd(), ...paths);
};
</file>

<file path="src/shared/helpers/prisma.helper.ts">
import { isNil } from 'lodash';

export const removeRelation = () => ({ disconnect: true });
export const connectRelation = (value: number) => (isNil(value) ? undefined : { connect: { id: value } });
</file>

<file path="src/shared/helpers/query.helper.ts">
import { SortOrder } from '../enums/query.enum';

export const defaultSortDesc: Record<string, SortOrder> = {
  createdAt: SortOrder.DESC,
};

export const defaultSortAsc: Record<string, SortOrder> = {
  createdAt: SortOrder.ASC,
};
</file>

<file path="src/shared/helpers/response.helper.ts">
import { ActionFailedException } from '../exceptions/action-failed.exception';
import { Result as ResultType } from '../generics/base.response';

export const Result = Object.freeze({
  Success: <T, E>(data: T): ResultType<T, E> => ({ success: true, data }),
  Failure: <T, E>(error: E): ResultType<T, E> => ({ success: false, error }),
});

export const makeResult = async <T>(execution: () => Promise<T>): Promise<ResultType<T, ActionFailedException>> => {
  try {
    return Result.Success(await execution());
  } catch (error) {
    if (error instanceof ActionFailedException) {
      return Result.Failure<T, ActionFailedException>(error);
    }
    throw error;
  }
};
</file>

<file path="src/shared/messages/error-messages.ts">
export enum AccountErrorMessages {
  MSG01 = 'Account not found',
  MSG02 = 'Email existed',
  MSG03 = 'Phone number existed',
  MSG04 = 'Current password is incorrect',
}

export enum MentorErrorMessages {
  MSG01 = 'Please end the current interview before update result of mentor',
  MSG02 = 'This account is not belong to this mentor',
  MSG03 = 'Profile achievement not found',
  MSG04 = 'Mentor not found',
}
export enum CategoryErrorMessages {
  MSG01 = "Category level can't exceed 2",
  MSG02 = "Category root level can't be recommended",
  MSG03 = 'Duplicate category ordinal',
  MSG04 = 'Cannot delete parent category with children',
  MSG05 = 'Some categories not found',
}

export enum AudioCallErrorMessages {
  MSG01 = 'Call is invalid',
  MSG02 = 'Account don not have permission to start call',
  MSG03 = 'Account don not have permission to end call',
  MSG04 = 'Call was finished or cancelled',
  MSG05 = 'Account is in the other call',
  MSG06 = 'Account not included in the call or joined call',
  MSG07 = 'Subscription is still active',
  MSG08 = 'Account has been already in the call',
}

export enum CourseErrorMessages {
  MSG01 = 'Course not found',
  MSG02 = 'Invalid course status to update',
}

export enum SubscriptionErrorMessages {}
</file>

<file path="src/shared/parsers/common.parser.ts">
import { Decimal } from '@prisma/client/runtime/library';
import { IsArray } from 'class-validator';
import { isNil, omitBy } from 'lodash';
import { Nil } from '../generics/type.helper';
import { isBlank } from '../validators/query.validator';
import { notEmptyOrNull, orNull } from './io.parser';

export const parseEpoch = (value: Nil<bigint>) => orNull(value && String(value));
// export const parseSearchString = (value?: string) => value && value.trim().split(' ').join(' & ');
export const parsePrismaSearch = (key: string, value?: string) => {
  return {
    OR: [
      // notEmptyOrNull(leanObject({ [key]: { search: parseSearchString(value) } })),
      notEmptyOrNull(leanObject(value ? { [key]: { contains: value, mode: 'insensitive' } } : undefined)),
    ].filter((v) => !!v),
  };
};

export function leanObject(myObject: any) {
  if (typeof myObject !== 'object' || IsArray(myObject)) return myObject;
  const returnObject = {};
  for (const key2 of Object.keys(myObject)) {
    const afterClean = leanObject(myObject[key2]);
    returnObject[key2] = isBlank(afterClean) ? null : afterClean;
  }

  return omitBy(returnObject, isNil);
}

export const parseDecimalNumber = (value?: number | string | Decimal, fixed = 2): number => {
  if (isNil(value)) return 0;
  const roundedValue = parseFloat(Number(value).toFixed(fixed));
  return isNaN(roundedValue) ? 0 : roundedValue;
};
</file>

<file path="src/shared/parsers/datetime.parse.ts">
import dayjs, { Dayjs } from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import duration from 'dayjs/plugin/duration';
import relativeTime from 'dayjs/plugin/relativeTime';
import timezone from 'dayjs/plugin/timezone';
import uct from 'dayjs/plugin/utc';
import { DATE_FORMAT } from '../constants/date.constant';
import { Nil } from '../generics/type.helper';
import { orNullWithCondition } from './io.parser';

dayjs.extend(customParseFormat);
dayjs.extend(relativeTime);
dayjs.extend(duration);
dayjs.extend(uct);
dayjs.extend(timezone);

dayjs.tz.setDefault('Asia/Ho_Chi_Minh');

export const parseDatetimeISO8601 = (date: Nil<string>, defaultValue = undefined) => {
  const dateAfterParse = parseDateMonthYear(date, 'start');
  return !dateAfterParse ? defaultValue : dayjs(dateAfterParse).format(DATE_FORMAT.DATE_TIME_SECOND.ISO8601);
};

export const parseAndAddMinutes = (datetimeStr: Nil<string>, minutesToAdd: number = 0, format?: string) => {
  const formatOrDefault = format ? format : DATE_FORMAT.DATE_TIME_SECOND.ISO8601;
  // Parse the datetime string into a dayjs object
  const parsedDatetime = datetimeStr ? dayjs(datetimeStr, formatOrDefault).tz() : dayjs().tz();

  // Add the specified number of minutes
  const updatedDatetime = parsedDatetime.add(minutesToAdd, 'minute');

  // Format it back to the original format
  return updatedDatetime.format(formatOrDefault);
};

export const parsePrismaDate = (date: Nil<string>) => (date ? parseDatetimeISO8601(date) + 'Z' : date);

export const parseDateToEpoch = (date: Nil<Date | string>) => (date ? dayjs(date).valueOf() : date);

export const parseQueryDate = (date: Nil<Dayjs>, defaultValue: any = null) =>
  date ? date.format(DATE_FORMAT.DATE.HYPHEN) : defaultValue;

const parseApplyMonth = (month: number) => String(month).padStart(2, '0');

export const parseDateMonthYear = (date: Nil<string>, position: 'start' | 'end') => {
  const parsedDate = date ? fromDateMonthYear(date.split('/')[0], date.split('/')[1], date.split('/')[2])(position) : undefined;

  return parsedDate;
};

export const parsePadDate = (value: string | number) => String(value).padStart(2, '0');

export const fromDateMonthYear =
  (date: string | number, month: number | string, year: number | string) => (position: 'start' | 'end') => {
    const dateAfterParse = dayjs(`${year}-${parseApplyMonth(+month)}-${parsePadDate(date)}T00:00:00.000Z`).utc();
    if (position === 'start') return dateAfterParse.startOf('date');
    else return dateAfterParse.endOf('date');
  };

export const fromDateTimeMonthYear = (
  time: string | number,
  date: string | number,
  month: number | string,
  year: number | string,
) => {
  const dateAfterParse = dayjs(`${year}-${parseApplyMonth(+month)}-${parsePadDate(date)}T${parsePadDate(time)}:00.000Z`).utc();
  return dateAfterParse;
};

//parse date time in this format DD/MM/YY HH:MM:SS to Epoch dont use dayjs
export const parseDateTimeRequestToEpoch = (date: Nil<string>) => {
  if (!date) return undefined;
  const [day, month, year, hour, minute, second] = date.split(/[\/ :]/).map((value) => parseInt(value));
  const dateAfterParse = new Date(year, month - 1, day, hour, minute, second);
  return dateAfterParse.getTime();
};

export const parseDateTimeToEpochV2 = (date: Nil<string>) => {
  if (!date) return undefined;
  //2024-12-07T23:00:00.000Z
  const [year, month, day, hour, minute, second] = date.split(/[-T:.]/).map((value) => parseInt(value));

  const dateAfterParse = new Date(year, month - 1, day, hour, minute, second);
  return dateAfterParse.getTime();
};

export const checkDateIsBeforeNow = (date: string) => {
  const now = dayjs().tz().valueOf();
  const epoch = dayjs(date).tz().valueOf();

  return epoch < now;
};

export const parsePrismaDateToEpoch = (date: Date | string) => orNullWithCondition(!!date, dayjs(date).valueOf().toString());

export const parseDateTimeNowFormat = (format: string) => dayjs().format(format);

export const parseHourMinFromString = (hourMin: string) => dayjs(`2021-01-01T${hourMin}`).tz().format('HH:mm');

export const parseEpochToDate = (epoch: Nil<number>) => {
  if (!epoch) return undefined;
  return dayjs(epoch).tz().format(DATE_FORMAT.DATE_TIME_SECOND.HYPHEN_V1);
};

export const parseDateToHyphen = (date: Nil<string>) => {
  if (!date) return undefined;
  const [day, month, year] = date.split('/').map((value) => parseInt(value));

  return dayjs(`${year}-${month}-${day}`).format(DATE_FORMAT.DATE.HYPHEN);
};

//Get MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
export const getDayOfWeek = (date: string) => dayjs(date).day();

export const getMillisecondsFromCurrentDate = ({
  days = 0,
  months = 0,
  years = 0,
  fromBeginning = false,
  fromEnding = false,
}: {
  days?: number;
  months?: number;
  years?: number;
  fromBeginning?: boolean;
  fromEnding?: boolean;
}) => {
  const date = new Date();
  date.setDate(date.getDate() - days);
  date.setMonth(date.getMonth() - months);
  date.setFullYear(date.getFullYear() - years);
  if (fromBeginning) date.setHours(0, 0, 0, 0);
  if (fromEnding) date.setHours(23, 59, 59, 999);
  return date.valueOf();
};

export const getDiffOfTwoDays = (startDay: string | number | Date, endDay: string | number | Date) => {
  const from = dayjs(startDay).tz();
  const end = dayjs(endDay).tz();

  const duration = dayjs.duration(end.diff(from));

  const years = Math.floor(duration.asYears());
  const months = Math.floor(duration.asMonths());
  const days = Math.floor(duration.asDays());
  const hours = Math.floor(duration.asHours());
  const minutes = Math.floor(duration.asMinutes());
  const seconds = Math.floor(duration.asSeconds());

  return { years, months, days, hours, minutes, seconds };
};
</file>

<file path="src/shared/parsers/io.parser.ts">
import { isEmpty, isNil } from 'lodash';
import { Nil } from '../generics/type.helper';

export const orEmptyString = (value?: any) => value || '';
export const orUndefined = (value?: any) => value || undefined;
export const orNull = (value?: any) => value || null;
export const orFalse = (value?: any) => value || false;
export const orDefault = (value?: any, defaultValue: any = null) => (isNil(value) ? defaultValue : value);
export const safeString = (value?: string | number | null, defaultValue = '') => (!isNil(value) ? `${value}` : defaultValue);
export const stringOrUndefined = (value: string | number | null | undefined | boolean) =>
  !isNil(value) ? `${value}` : undefined;
export const notEmptyOrNull = (value?: any) => (isEmpty(value) ? null : value);
export const stringOrNull = (value?: string | number | null) => (value ? `${value}` : null);
export const numberOrNull = (value?: Nil<string | number>) =>
  !isNil(value) ? (typeof value === 'string' ? parseInt(value) : value) : null;
export const numberOrUndefined = (value?: Nil<string | number>) =>
  !isNil(value) ? (typeof value === 'string' ? parseInt(value) : value) : undefined;
export const numberOrZero = (value?: Nil<string | number>) => (!value ? 0 : typeof value === 'string' ? parseInt(value) : value);
export const booleanToNumber = (value: boolean) => (value ? 1 : 0);
export const parseImage = (url: Nil<string>) => url || 'https://www.sikkimexpress.com/assets/frontend/images/no-image.png';
export const formatMoney = (money: number) => new Intl.NumberFormat('en-EN').format(money);
export const formatPhone = (phoneNumber?: string | null) => {
  if (!phoneNumber) return '';
  const cleaned = phoneNumber.replace(/\D/g, ''); // Remove any non-numeric characters from the input string
  const pattern = /^(.{3})(.{4})(.*)$/; // Define the format pattern
  const formatted = cleaned.replace(pattern, '$1-$2-$3'); // Apply the pattern and format the phone number accordingly
  return formatted;
};

export function deepFreeze<T>(object: T): T {
  Object.keys(object).forEach((prop) => {
    if (typeof object[prop] === 'object' && !Object.isFrozen(object[prop])) deepFreeze(object[prop]);
  });
  return Object.freeze(object);
}

export const orUndefinedWithCondition = (condition?: boolean, value?: any) => (condition ? orUndefined(value) : undefined);
export const orNullWithCondition = (condition?: boolean, value?: any) => (condition ? orNull(value) : null);

export const parseRoomChatId = (roomId: number) => {
  return `room_${roomId}`;
};
</file>

<file path="src/shared/request-validator/account.validator.ts">
import { IsEmail, IsLowercase, IsNotEmpty, IsNumberString, IsString, Length, Matches, MaxLength } from 'class-validator';
import { AUTH_CONSTANT } from '../constants/auth.constant';

export function PhoneNumberValidator() {
  return function (object: object, propertyName: string) {
    IsNumberString()(object, propertyName);
    Length(8, 12)(object, propertyName);
  };
}

export function UsernameValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    Length(1, 20, { message: 'username should be between 1 and 20 characters' })(object, propertyName);
    Matches(/^[a-z][a-z0-9]{0,19}$/, {
      message: 'username should start with a lowercase English letter and can contain lowercase letters and numbers only',
    })(object, propertyName);
    IsLowercase({ message: 'username should be in lowercase' })(object, propertyName);
    IsNotEmpty({ message: 'username is required' })(object, propertyName);
  };
}

export function PasswordValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    Length(6, 20, { message: 'password should be between 6 and 20 characters' })(object, propertyName);
    Matches(/^(?=.*[a-zA-Z])(?=.*[0-9])[a-zA-Z0-9!@#$%^&*()_+{}\[\]:;<>,.?~\\/-]*$/, {
      message: 'password should contain a combination of English letters and numbers with optional special characters',
      each: true,
    })(object, propertyName);
  };
}

export function EmailValidator() {
  return function (object: object, propertyName: string) {
    IsString({ message: 'email must be a string' })(object, propertyName);
    IsEmail()(object, propertyName);
  };
}

export function NameValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    IsNotEmpty()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}

export function OtpValidator() {
  return function (object: object, propertyName: string) {
    IsNumberString()(object, propertyName);
    Length(AUTH_CONSTANT.OTP_CODE_LENGTH)(object, propertyName);
  };
}

export function AddressBaseValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}

export function AddressDetailValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/array-not-duplicated.request-validator.ts">
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';
import { uniq } from 'lodash';

export function ArrayNotDuplicated<T>(classType: T | (new () => T), field?: keyof T, validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'ArrayNotDuplicated',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [classType, field],
      options: validationOptions,
      validator: {
        validate(value: any[], args: ValidationArguments) {
          if (!Array.isArray(value) || !value.length) return true;
          const [type, field] = args.constraints;

          if (typeof type === 'function') {
            // Handle class type
            if (field) {
              const fieldValues = value.map((item) => item[field]);
              return uniq(fieldValues).length === fieldValues.length;
            }
            return uniq(value).length === value.length;
          } else if (typeof type === 'object') {
            // Handle enum or object type
            if (field && !Object.keys(type).includes(field as string)) {
              return false;
            }
            if (field) {
              const fieldValues = value.map((item) => item[field]);
              return uniq(fieldValues).length === fieldValues.length;
            }
            return uniq(value).length === value.length;
          }
          return false;
        },
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must not contain duplicated items`;
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/boolean.request-validator.ts">
import { Transform } from 'class-transformer';
import { IsBoolean } from 'class-validator';

export function BooleanValidator() {
  return function (object: object, propertyName: string) {
    IsBoolean()(object, propertyName);
    Transform(({ value }) => value && Boolean(value.toString() === 'true'))(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/date-time.request.validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function DateTimeValidator(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'DateTimeValidator',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be in the format DD/MM/YYYY HH:MM:SS`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[1-9]|[12]\d|3[01])\/(0[1-9]|1[0-2])\/\d{4} (0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/hour-min-format.validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function HourMinValidator(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'HourMinValidator',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be in the format HH:MM`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/id.validator.ts">
import { IsNumber } from 'class-validator';

export function IdValidator() {
  return function (object: object, propertyName: string) {
    IsNumber()(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/month-year-compare.request-validator.ts">
import { ValidationArguments, ValidationOptions, registerDecorator } from 'class-validator';
import { parseDateMonthYear } from '../parsers/datetime.parse';

export function DateMonthYearCompare(
  validationOptions?: ValidationOptions & {
    startField: string;
  },
) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'DateMonthYearCompare',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const endDate = value && parseDateMonthYear(value, 'end');
          const startStringDate = (args.object as any)[validationOptions.startField];
          const startDate = startStringDate && parseDateMonthYear(startStringDate, 'start');
          if (!endDate || !startDate) return true;
          return startDate.valueOf() < endDate.valueOf();
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        defaultMessage(validationArguments?: ValidationArguments) {
          return (validationOptions?.message as string) || `${validationOptions.startField} must less than ${propertyName}`;
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/only-date.request-validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function OnlyDate(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'OnlyDate',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be date format eg: 30/10/2020`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[1-9]|[12]\d|3[01])\/(0[1-9]|1[0-2])\/[12]\d{3}$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/query-array.validate.ts">
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';
import { isNil, isNull, isUndefined } from 'lodash';

export function QueryArrayValidate(
  validationOptions?: ValidationOptions & {
    fieldType: 'number' | 'string';
    minSize?: number;
    maxSize?: number;
  },
) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'QueryArrayValidate',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: string[] | number[], args: ValidationArguments) {
          if (isUndefined(value)) return true;
          if (isNull(value)) return false;
          if (!isNil(validationOptions.minSize) && value.length < validationOptions.minSize) return false;
          if (!isNil(validationOptions.maxSize) && value.length > validationOptions.maxSize) return false;
          return true;
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        defaultMessage(validationArguments?: ValidationArguments) {
          return (
            (validationOptions?.message as string) ||
            `${validationArguments.property} must be array format, eg: [1,2,3] or [name_1, name_2]`
          );
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/query-array.validator.ts">
import { Transform } from 'class-transformer';
import { QueryArrayValidate } from './query-array.validate';

export function QueryArray(options: { fieldType: 'number' | 'string'; minSize?: number; maxSize?: number }) {
  return function (object: object, propertyName: string) {
    QueryArrayValidate(options)(object, propertyName);
    Transform(({ value }) => {
      if (!value) return undefined;
      const numberRegex = /^\[\s*\d+(\s*,\s*\d+)*\s*\]$/;
      const stringRegex = /^\[\s*\w+(\s*,\s*\w+)*\s*\]$/;

      // Check if the transformation might have already been applied
      if (Array.isArray(value)) {
        console.log('Transformation previously applied, skipping.');
        return value;
      }

      if (options.fieldType === 'number' && !numberRegex.test(value)) return null;
      else if (options.fieldType === 'string' && !stringRegex.test(value)) return null;
      const param = String(value).replace('[', '').replace(']', '');
      const items = param.split(',').map((v) => v.trim());
      return items.map((i) => {
        return options.fieldType === 'number' ? Number.parseInt(i) : i;
      });
    })(object, propertyName);
  };
}
</file>

<file path="src/shared/types/payload-prisma.ts">
import { Prisma } from '@prisma/client';

export type CourseGetPayload = Prisma.CourseGetPayload<{
  include: {
    Creator: true;
    Category: true;
    Image: true;
    Sections: true;
    MentorSchedules: true;
    _count: { select: { Sections: true; Subscriptions: true } };
  };
}>;

export type CourseSectionGetPayload = Prisma.CourseSectionGetPayload<{
  include: { Course: true; SectionAttachments: true };
}>;
</file>

<file path="src/shared/validators/query.validator.ts">
import { isBoolean, isEmpty, isNumber } from 'lodash';

/*
  isBlank(undefined)
  // => true

  isBlank(null)
  // => true

  isBlank('')
  // => true

  isBlank([])
  // => true

  isBlank({})
  // => true

  isBlank(NaN)
  // => true

  isBlank(0)
  // => false
*/
export function isBlank(value: any) {
  return isEmpty(value) && !isNumber(value) && !isBoolean(value);
}
</file>

<file path="src/app.config.ts">
import { config } from 'dotenv';
config();

export const CREDENTIALS = process.env.CREDENTIALS === 'true';

export const {
  PORT,
  ORIGIN,
  DATABASE_URL,
  NODE_ENV,
  APP_SECRET,
  HOST,
  JWT_SECRET_KEY,
  JWT_ACCESS_TOKEN_EXPIRE_HOURS,
  API_DOMAIN,
  API_VERSION,
  /* CLD CONFIG */
  CLD_API_KEY,
  CLD_API_SECRET,
  CLD_CLOUD_NAME,
  /* GETSTREAM.IO CONFIG */
  GETSTREAM_API_KEY,
  GETSTREAM_API_SECRET,
  GETSTREAM_WEBHOOK_URL,
  /* VNPAY CONFIG*/
  VNP_TMNCODE,
  VNP_HASHSECRET,
  VNP_COMMAND,
  VNPAY_SANDBOX_HOST,
  VNPAY_ENDPOINT,
  VNPAY_RETURN_URL,
  VNPAY_TEST_MODE,
  VNPAY_MODE,
  VNP_VERSION,
  /* FIREBASE */
  FIREBASE_CLOUD_MESSAGE_CERTIFICATION,
  /* EMAIL */
  EMAIL_SERVICE,
  EMAIL_HOST,
  EMAIL_PORT,
  EMAIL_USER,
  EMAIL_PASSWORD,
  EMAIL_FROM,
  EMAIL_VERIFY_URL,
} = process.env;
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { ScheduleModule } from '@nestjs/schedule';
import { ClsModule } from 'nestjs-cls';
import { AccountModule } from './domains/accounts/accounts.module';
import { AudioCallModule } from './domains/audio-call/audio-call.module';
import { AuthModule } from './domains/auth/auth.module';
import { CategoryModule } from './domains/category/category.module';
import { ChatMessageModule } from './domains/chat-message/chat-message.module';
import { CourseModule } from './domains/course/course.module';
import { DashboardModule } from './domains/dashboard/dashboard.module';
import { FeedbackModule } from './domains/feedback/feedback.module';
import { FileModule } from './domains/file/file.module';
import { ImageModule } from './domains/image/image.module';
import { MentorModule } from './domains/mentor/mentor.module';
import { NotificationModule } from './domains/notification/notification.module';
import { PaymentModule } from './domains/payment/payment.module';
import { ReportModule } from './domains/report/report.module';
import { StudentModule } from './domains/student/student.module';
import { SubscriptionModule } from './domains/subscription/subscription.module';
import { UtilityModule } from './domains/utility/utility.module';
import { CommonModule } from './services/common.module';
import { VnpayModule } from './services/payment-gateway/vn-pay/vnpay.module';

@Module({
  imports: [
    // Register the ClsModule,
    ScheduleModule.forRoot(),
    ClsModule.forRoot({
      global: true,
      middleware: {
        // automatically mount the
        // ClsMiddleware for all routes
        mount: true,
        // and use the setup method to
        // provide default store values.
        setup: (cls, req) => {
          cls.set('userId', req.headers['x-user-id']);
        },
      },
    }),
    EventEmitterModule.forRoot({
      wildcard: false,
      delimiter: '.',
      newListener: false,
      removeListener: false,
      maxListeners: 10,
      verboseMemoryLeak: false,
      ignoreErrors: false,
    }),
    CommonModule,
    UtilityModule,
    FileModule,
    ImageModule,
    /* API Service */
    VnpayModule,
    CategoryModule,
    AccountModule,
    AuthModule,
    CourseModule,
    StudentModule,
    MentorModule,
    AudioCallModule,
    PaymentModule,
    SubscriptionModule,
    ChatMessageModule,
    NotificationModule,
    FeedbackModule,
    DashboardModule,
    ReportModule,
  ],
})
export class AppModule {}
</file>

<file path="src/main.ts">
import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import bodyParser from 'body-parser';
import chalk from 'chalk';
import compression from 'compression';
import cookieParser from 'cookie-parser';
import { cleanEnv, port, str } from 'envalid';
import helmet from 'helmet';
import morgan from 'morgan';

import { APP_SECRET, CREDENTIALS, HOST, NODE_ENV, ORIGIN, PORT } from './app.config';
import { AppModule } from './app.module';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { PrismaExceptionInterceptor } from './interceptors/prisma-exception.interceptor';
import { HttpExceptionMiddleware } from './middlewares/http-exception.middlewave';
import { ValidationCustomPipe } from './pipes/validation-custom.pipe';
import { setupSwagger } from './swagger';

async function bootstrap(): Promise<void> {
  try {
    validateEnv();

    const app = await NestFactory.create<NestExpressApplication>(AppModule, {
      logger: ['error', 'warn', 'log', 'verbose'],
      cors: {
        origin: ORIGIN,
        credentials: CREDENTIALS,
      },
    });

    Logger.log(`🚀 Environment: ${chalk.hex('#33d32e').bold(`${NODE_ENV}`)}`);

    app.use(helmet());
    app.use(compression());
    app.use(morgan('combined'));
    app.use(cookieParser(APP_SECRET));
    app.use(bodyParser.json({ limit: '50mb' }));
    app.use(
      bodyParser.urlencoded({
        limit: '50mb',
        extended: true,
        parameterLimit: 50000,
      }),
    );
    // app.use(
    //   rateLimit({
    //     windowMs: 1000 * 60 * 60,
    //     max: 1000, // 1000 requests per windowMs
    //     message: '🚫  Too many request created from this IP, please try again after an hour',
    //   }),
    // );

    app.useGlobalInterceptors(new LoggingInterceptor());
    app.useGlobalInterceptors(new PrismaExceptionInterceptor());
    app.useGlobalPipes(ValidationCustomPipe.compactVersion());
    app.useGlobalFilters(new HttpExceptionMiddleware());
    app.setGlobalPrefix('api/v1');

    // Swagger
    setupSwagger(app);

    await app.listen(PORT || 3000);

    if (NODE_ENV !== 'production') {
      Logger.log(`🪭 Server ready at http://${chalk.hex('#e5ff00').bold(`${HOST}`)}:${chalk.hex('#ff6e26').bold(`${PORT}`)}`);
    } else {
      Logger.log(`🪽 Server is listening on port ${chalk.hex('#87e8de').bold(`${PORT}`)}`);
    }
    Logger.log(
      `📚 Swagger ready at http://${chalk.hex('#e5ff00').bold(`${HOST}`)}:${chalk.hex('#ff6e26').bold(`${PORT}`)}/documentation`,
    );
  } catch (error) {
    Logger.error(`❌  Error starting server, ${error}`);
    process.exit();
  }
}

function validateEnv() {
  cleanEnv(process.env, {
    DATABASE_URL: str(),
    PORT: port(),
  });
}

bootstrap().catch((e) => {
  Logger.error(`❌  Error starting server, ${e}`);
  throw e;
});
</file>

<file path="src/swagger.ts">
import { type INestApplication } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

import { API_VERSION } from './app.config';

export function setupSwagger(app: INestApplication): void {
  const documentBuilder = new DocumentBuilder().setTitle('API').setDescription(`
### REST

Routes is following REST standard (Richardson level 3)

<details><summary>Detailed specification</summary>
<p>

**List:**
  - \`GET /<resources>/\`
    - Get the list of **<resources>** as admin
  - \`GET /user/<user_id>/<resources>/\`
    - Get the list of **<resources>** for a given **<user_id>**
    - Output a **403** if logged user is not **<user_id>**

**Detail:**
  - \`GET /<resources>/<resource_id>\`
    - Get the detail for **<resources>** of id **<resource_id>**
    - Output a **404** if not found
  - \`GET /user/<user_id>/<resources>/<resource_id>\`
    - Get the list of **<resources>** for a given **user_id**
    - Output a **404** if not found
    - Output a **403** if:
      - Logged user is not **<user_id>**
      - The **<user_id>** have no access to **<resource_id>**

**Creation / Edition / Replacement / Suppression:**
  - \`<METHOD>\` is:
    - **POST** for creation
    - **PATCH** for update (one or more fields)
    - **PUT** for replacement (all fields, not used)
    - **DELETE** for suppression (all fields, not used)
  - \`<METHOD> /<resources>/<resource_id>\`
    - Create **<resources>** with id **<resource_id>** as admin
    - Output a **400** if **<resource_id>** conflicts with existing **<resources>**
  - \`<METHOD> /user/<user_id>/<resources>/<resource_id>\`
    - Create **<resources>** with id **<resource_id>** as a given **user_id**
    - Output a **409** if **<resource_id>** conflicts with existing **<resources>**
    - Output a **403** if:
      - Logged user is not **<user_id>**
      - The **<user_id>** have no access to **<resource_id>**
</p>
</details>
    `);
  // .addBearerAuth();

  if (API_VERSION) {
    documentBuilder.setVersion(process.env.API_VERSION);
  }

  const document = SwaggerModule.createDocument(app, documentBuilder.build());
  SwaggerModule.setup('documentation', app, document, {
    swaggerOptions: {
      persistAuthorization: false,
    },
  });
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
