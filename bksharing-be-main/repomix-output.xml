This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T17:37:47.699Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
prisma/
  schema.prisma
src/
  domains/
    accounts/
      dto/
        account-change-password.dto.ts
        account-create.dto.ts
        account-detail.dto.ts
        account-update.dto.ts
      response/
        account.response.ts
      account.controller.ts
      account.service.ts
      accounts.module.ts
    audio-call/
      admin/
        dto/
          audio-call-admin-detail.dto.ts
          participant-dto.ts
        request/
          audio-call-admin-create.request.ts
          audio-call-admin-list.request.ts
        response/
          audio-call-admin-detail.response.ts
          audio-call-admin-list.response.ts
        audio-call-admin.controller.ts
        audio-call-admin.module.ts
        audio-call-admin.service.ts
      base/
        audio-call-list-base.request.ts
      client/
        request/
          audio-call-client-list.request.ts
        audio-call-client.controller.ts
        audio-call-client.module.ts
        audio-call-client.service.ts
      dto/
        audio-call-end.dto.ts
        audio-call-join.dto.ts
        audio-call-start.dto.ts
      response/
        audio-call-participant-history.response.ts
      shared/
        helpers.ts
        types.ts
      audio-call.controller.ts
      audio-call.gateway.ts
      audio-call.module.ts
      audio-call.service.spec.ts
      audio-call.service.ts
    auth/
      dto/
        auth-jwt-payload.dto.ts
        auth-login.dto.ts
        auth-request.dto.ts
        auth-user.dto.ts
      request/
        auth-email--reset-password.request.ts
        auth-email-verification.request.ts
        auth-find-password-reset.request.ts
        auth-login.request.ts
        auth-mentor-register.request.ts
        auth-otp-checkout.request.ts
        auth-otp-send.request.ts
        auth-student-register.request.ts
        auth-test-account.request.ts
      response/
        auth-find-password.response.ts
        auth-login.response.ts
        auth-register.response.ts
      auth-jwt.guard.ts
      auth-jwt.strategy.ts
      auth-public.decorator.ts
      auth-role.decorator.ts
      auth-role.guard.ts
      auth.controller.ts
      auth.module.ts
      auth.service.ts
    category/
      admin/
        dto/
          category-cms-detail.dto.ts
        request/
          category-admin-create.request.ts
          category-admin-list.request.ts
          category-admin-reordinal.request.ts
          category-admin-update.request.ts
        response/
          category-admin-detail.response.ts
          category-admin-list.response.ts
        category-admin.controller.ts
        category-admin.service.ts
      client/
        dto/
          category-client-statistics.dto.ts
        request/
          category-client-list.request.ts
          category-client-select-interested-choice.request.ts
        response/
          category-client-list.response.ts
          category-client-statistics.response.ts
        category-client.controller.ts
        category-client.service.ts
      shared/
        enums.ts
        types.ts
      category.module.ts
    chat-message/
      helper/
        chat-room-create.helper.ts
        chat-room-detail.helper.ts
        chat-room-list-helper.ts
        chat-room-read-message.helper.ts
      request/
        chat-message-create.request.ts
        chat-room-create.request.ts
        chat-room-detail.request.ts
        chat-room-list.request.ts
        chat-room-read-message.request.ts
      response/
        chat-room-detail.response.ts
        chat-room-list.response.ts
        message-chat-create.response.ts
      shared/
        types.ts
      chat-message.controller.spec.ts
      chat-message.controller.ts
      chat-message.gateway.ts
      chat-message.module.ts
      chat-message.service.spec.ts
      chat-message.service.ts
    course/
      admin/
        request/
          course-approve.request.ts
        response/
          course-admin-detail.response.ts
          course-admin-list.response.ts
        course-admin.controller.spec.ts
        course-admin.controller.ts
        course-admin.module.ts
        course-admin.service.spec.ts
        course-admin.service.ts
      client/
        request/
          course-client-create.request.ts
          course-client-update.request.ts
          course-section-client-update.request.ts
        response/
          course-client-detail.response.ts
          course-client-list.response.ts
          course-section-client.response.ts
        course-client.controller.spec.ts
        course-client.controller.ts
        course-client.module.ts
        course-client.service.spec.ts
        course-client.service.ts
      dto/
        course-section.dto.ts
      factory/
        list/
          course-admin-list.request.ts
          course-client-list.request.ts
        course-list.factory.ts
      shared/
        helper/
          course-detail-query.helper.ts
          course-list-query.helper.ts
          course-section.helper.ts
          course-update-query.helper.ts
        course-base-list.request.ts
        enums.ts
        types.ts
      course.module.ts
    dashboard/
      admin/
        dashboard-admin.controller.spec.ts
        dashboard-admin.controller.ts
        dashboard-admin.module.ts
        dashboard-admin.service.spec.ts
        dashboard-admin.service.ts
      client/
        dashboard-client.controller.spec.ts
        dashboard-client.controller.ts
        dashboard-client.module.ts
        dashboard-client.service.spec.ts
        dashboard-client.service.ts
      helper/
        statistic-overview-admin-list.helper.ts
        statistic-overview-client-list.helper.ts
        statistic-payment-list.helper.ts
        statistic-subscription-list.helper.ts
      request/
        statistic-base-list.request.ts
        statistic-course-list.request.ts
        statistic-overview-list.request.ts
        statistic-payment-list.request.ts
        statistic-subscription-list.request.ts
        statistic-top-course-list.request.ts
      response/
        statistic-overview-list.response.ts
        statistic-payment-list.response.ts
      shared/
        types.ts
      dashboard.controller.ts
      dashboard.module.ts
      dashboard.service.ts
    feedback/
      admin/
        feedback-admin.controller.spec.ts
        feedback-admin.controller.ts
        feedback-admin.module.ts
        feedback-admin.service.spec.ts
        feedback-admin.service.ts
      client/
        feedback-client.controller.spec.ts
        feedback-client.controller.ts
        feedback-client.module.ts
        feedback-client.service.spec.ts
        feedback-client.service.ts
      helper/
        feedback-create.helper.ts
        feedback-list.helper.ts
        feedback-update.helper.ts
      request/
        feedback-create.request.ts
        feedback-list.request.ts
        feedback-update.request.ts
      response/
        feedback-list.response.ts
      shared/
        type.ts
      feedback.module.ts
    file/
      dto/
        file-link.dto.ts
      request/
        file-create.request.ts
        file-upload-signed-url.request.ts
      response/
        file-create.response.ts
        file.response.ts
      file.controller.spec.ts
      file.controller.ts
      file.module.ts
      file.service.spec.ts
      file.service.ts
    image/
      response/
        image-version.response.ts
        image.response.ts
      image.controller.ts
      image.module.ts
      image.service.ts
    mentor/
      admin/
        dto/
          mentor-admin-detail.dto.ts
          mentor-client-detail.dto.ts
        request/
          mentor-admin-approve.request.ts
          mentor-admin-interview.request.ts
          mentor-admin-list.request.ts
          mentor-client-list.request.ts
        response/
          mentor-admin-detail.response.ts
          mentor-admin-interview.response.ts
          mentor-admin-list.response.ts
          mentor-client-detail.response.ts
          mentor-client-list.response.ts
        mentor-admin.controller.spec.ts
        mentor-admin.controller.ts
        mentor-admin.module.ts
        mentor-admin.service.spec.ts
        mentor-admin.service.ts
      client/
        request/
          mentor-client-achievement-create.request.ts
          mentor-client-achievement-update.request.ts
          mentor-client-course-list.request.ts
          mentor-client-schedule-create.request.ts
          mentor-client-schedule-list.request.ts
          mentor-client-schedule-update.request.ts
          mentor-client-update.request.ts
        response /
          mentor-schedule-list.response.ts
        mentor-client.controller.spec.ts
        mentor-client.controller.ts
        mentor-client.module.ts
        mentor-client.service.spec.ts
        mentor-client.service.ts
        mentor-schedule.service.ts
      shared/
        enums.ts
        types.ts
      mentor.module.ts
    notification/
      helper/
        notification-common.helper.ts
      request/
        notification-create.request.ts
        notification-list.request.ts
        notification-read.request.ts
      response/
        notification.response.ts
      shared/
        interfaces.ts
        transation.enum.ts
        types.ts
      notification.controller.ts
      notification.gateway.ts
      notification.module.ts
      notification.service.ts
    payment/
      client/
        payment-client.controller.spec.ts
        payment-client.controller.ts
        payment-client.module.ts
        payment-client.service.spec.ts
        payment-client.service.ts
      dto/
        payment-continue.request.ts
        payment-create.request.ts
      payment.module.ts
    report/
      helper/
        report-create.helper.ts
        report-detail.helper.ts
        report-list.helper.ts
        report-resolve.helper.ts
      request/
        report-client-feedback-create.request.ts
        report-client-subscription-create.request.ts
        report-list.request.ts
        report-resolve-base.request.ts
        report-resolve-feeback.request.ts
        report-resolve-subscription.request.ts
      response/
        report-detail.response.ts
        report-list.response.ts
      shared/
        interface.ts
        type.ts
        utilities.ts
      report.controller.ts
      report.module.ts
      report.service.spec.ts
      report.service.ts
    student/
      client/
        student-client.controller.spec.ts
        student-client.controller.ts
        student-client.module.ts
        student-client.service.spec.ts
        student-client.service.ts
      shared/
        types.ts
      student.module.ts
    subscription/
      client/
        subscription-client.controller.ts
        subscription-client.module.ts
        subscription-client.service.spec.ts
        subscription-client.service.ts
      dto/
        request/
          subscription-admin-list.request.ts
          subscription-create.request.ts
          subscription-mentor-approve.ts
          subscription-payment-create.ts
        response/
          subscription-admin-list.response.ts
          subscription-detail.response.ts
          subscription-list.response.ts
      helper/
        subcription-create.helper.ts
        subscription-approve.helper.ts
        subscription-common.helper.ts
        subscription-detail.helper.ts
        subscription-list.helper.ts
        subscription-make-payment.helper.ts
      shared/
        types.ts
      subscription-admin/
        subscription-admin.controller.spec.ts
        subscription-admin.controller.ts
        subscription-admin.module.ts
        subscription-admin.service.spec.ts
        subscription-admin.service.ts
      subscription.module.ts
    utility/
      request/
        utility-enum.request.ts
      utility.controller.ts
      utility.module.ts
      utility.service.ts
  interceptors/
    logging.interceptor.ts
    prisma-exception.interceptor.ts
  middlewares/
    http-exception.middlewave.ts
    socket-auth.middleware.ts
  pipes/
    validation-array.pipe.ts
    validation-custom.pipe.ts
    validation.pipe.ts
  services/
    axios/
      axios.module.ts
      axios.service.spec.ts
      axios.service.ts
    email/
      shared/
        types.ts
      email.module.ts
      email.service.ts
    event-emitter/
      event-emitter.interface.ts
      event-emitter.module.ts
      event-emitter.service.ts
    fcm/
      request/
        fcm-register-token.request.ts
        fcm-remove-token.request.ts
      shared/
        helpers.ts
      fcm.controller.ts
      fcm.module.ts
      fcm.service.ts
      fcm.types.ts
    getstream/
      request/
        getstream.request.ts
      getstream.controller.ts
      getstream.module.ts
      getstream.service.spec.ts
      getstream.service.ts
    payment-gateway/
      vn-pay/
        shared/
          vnpay.constant.ts
          vnpay.enum.ts
          vnpay.helper.ts
          vnpay.type.ts
        vnpay.module.ts
        vnpay.service.ts
    prisma/
      transactions/
        transaction-host.spec.ts
        transaction-host.ts
        transaction.constant.ts
        transaction.symbol.ts
        transaction.type.ts
        transactional.decorator.ts
      prisma-raw.service.ts
      prisma.module.ts
      prisma.service.ts
    storage/
      dto/
        storage.dto.ts
      shared/
        interfaces/
          file.interface.ts
          sharp.interface.ts
          signed-upload-url.interface.ts
        types/
          cloudinary-config.types.ts
      storage.module.ts
      storage.provider.ts
      storage.service.spec.ts
      storage.service.ts
      storgare.module-definition.ts
    common.module.ts
  shared/
    constants/
      audio-room.constant.ts
      auth.constant.ts
      category.constant.ts
      chat-message.constant.ts
      common.constant.ts
      course.constant.ts
      dashboard.constant.ts
      date.constant.ts
      event.constant.ts
      notification.constant.ts
      payment.constant.ts
      prisma.constant.ts
      report.constant.ts
      storage.constant.ts
      subscription.constant.ts
    enums/
      common.enum.ts
      query.enum.ts
    exceptions/
      action-failed.exception.ts
      asset-file-not-existed.exception.ts
      database-connnection.exception.ts
      entity-not-found.exception.ts
      key-duplication.exception.ts
      prisma-client-validation.exception.ts
      relation-violation.request.ts
      toss-payment-validate.exception.ts
      unknown-prisma.exception.ts
      write-fail-exception.ts
      write-relation-not-found.exception.ts
    generics/
      base.response.ts
      pagination.request.ts
      pagination.response.ts
      toss-payment-result.response.ts
      type.helper.ts
    helpers/
      add-timestamp.helper.ts
      category.helper.ts
      common.helper.ts
      date-range.helper.ts
      function.helper.ts
      pagination.helper.ts
      path.helper.ts
      prisma.helper.ts
      query.helper.ts
      response.helper.ts
    messages/
      error-messages.ts
    parsers/
      common.parser.ts
      datetime.parse.ts
      io.parser.ts
    request-validator/
      account.validator.ts
      array-not-duplicated.request-validator.ts
      boolean.request-validator.ts
      date-time.request.validator.ts
      hour-min-format.validator.ts
      id.validator.ts
      month-year-compare.request-validator.ts
      only-date.request-validator.ts
      query-array.validate.ts
      query-array.validator.ts
    types/
      payload-prisma.ts
    validators/
      query.validator.ts
  app.config.ts
  app.module.ts
  main.ts
  swagger.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="prisma/schema.prisma">
// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// ==================== ACCOUNT ====================
model Account {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  email       String      @db.VarChar(255)
  password    String      @db.VarChar(255)
  accountType AccountType @map("account_type")
  phoneNumber String      @map("phone_number") @db.VarChar(20)
  name String @map("name") @db.VarChar(50)
  gender Gender 
  status AccountStatus @default(ACTIVE)
  dob   DateTime @map("dob")
  bio   String? @db.Text
  addressBase    String? @map("address_base") @db.VarChar(255)
  addressDetail  String? @map("address_detail") @db.VarChar(255)
  suspendedAt BigInt? @map("suspended_at")
  suspensionType AccountSuspensionType? @map("suspension_type") @default(ACCOUNT_NOT_SUSPENDED)

  avatarId Int?  @map("avatar_id")  
  Avatar   File? @relation("accoun_avatar", fields: [avatarId], references: [id])
  
  Students Student[] @relation("student_account")
  Mentors Mentor[]  @relation("mentor_account")
  UserInterestedCategories UserInterestedCategory[] @relation("user_interested_category")
  MentorAcceptants Mentor[] @relation("mentor_acceptant")
  Files File[]
  Rooms AudioRoom[]
  Participants AudioRoomParticipant[]
  CourseCreators Course[] @relation("course_creator")
  Subscriptions Subscription[] @relation("account_subscription")
  ChatMessages ChatMessage[] @relation("chat_message_sender")
  ChatRegistrants ChatParticipant[] @relation("conversation_registrant")
  ChatParticipants ChatParticipant[] @relation("conversation_participant")
  Notifications Notification[] @relation("notification_target_account")
  DeviceTokens DeviceToken[] @relation("account_device_token")
  Reviewers Feedback[] @relation("reviewer_account")
  Tokens Token[]
  Reports Report[] @relation("reporter_account")
  
  @@unique([email, phoneNumber, isActive])
  @@map("accounts")
}

enum AccountSuspensionType {
  ACCOUNT_NOT_SUSPENDED
  ACCOUNT_SUSPENDED_3_DAYS
  ACCOUNT_SUSPENDED_7_DAYS
  ACCOUNT_SUSPENDED_PERMANENTLY
}

model Token {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  token String @unique
  accountId Int @map("account_id")
  type TokenType @map("type")
  Account   Account @relation(fields: [accountId], references: [id])

  @@map("tokens")
}

enum TokenType {
  SESSION
  VERIFY
}

enum AccountStatus {
  ACTIVE
  DEACTIVE
  SUSPENSIVE
}

// ==================== STUDENT ====================
model Student {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  major String @db.VarChar(50)
  educationalLevel EducationalLevel @map("educational_level") 

  accountId Int @map("account_id")
  Account   Account @relation("student_account",fields: [accountId], references: [id])

  @@map("students") 
}

model UserInterestedCategory {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  userId Int @map("user_id")
  User   Account @relation("user_interested_category", fields: [userId], references: [id])

  categoryId Int      @map("category_id")
  Category   Category @relation("interested_category_user", fields: [categoryId], references: [id])

  @@id([userId, categoryId])
  @@map("user_interested_categories")
}

// ==================== MENTOR ==================== 
model Mentor {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  status MentorStatus @map("status")
  description String? @db.Text
  accpetedAt BigInt? @map("accepted_at")

  acceptantId    Int?           @map("acceptant_id")
  Acceptant      Account?       @relation("mentor_acceptant", fields: [acceptantId], references: [id])
  fileId Int? @map("file_id")
  File   File? @relation("cv_file",fields: [fileId], references: [id])
  accountId Int @map("account_id")
  Account   Account @relation("mentor_account", fields: [accountId], references: [id])

  ProfileAchievements ProfileAchievement[] @relation("mentor_profile_achievements")
  MentorSchedules MentorSchedule[] @relation("mentor_schedules")

  @@unique([accountId])
  @@map("mentors")
}

enum Gender {
  MALE
  FEMALE
  OTHER
}

enum MentorStatus {
  PENDING
  ACCEPTED
  REJECTED
}

model ProfileAchievement {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")
  
  type           AchievementType // experience, education, certification
  isCurrent     Boolean         @default(false) @map("is_current")
  name          String? //name of the achievement
  isVisible      Boolean         @default(true) @map("is_visible")
  organization   String?         // Can be company or institution or certification body
  position       String?         // For experience
  major          String?         // For education
  startDate      DateTime?
  endDate        DateTime?
  description    String?
  mentorId Int           @map("mentor_id")
  Mentor   Mentor @relation( "mentor_profile_achievements",fields: [mentorId], references: [id])

  @@index([mentorId, type, isVisible,  isActive])
  @@map("profile_achievements")
}

enum AchievementType {
  EXPERIENCE
  EDUCATION
  CERTIFICATION
}

model MentorSchedule {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  dayOfWeek DayOfWeek @map("day_of_week")
  startTime String @map("start_time") // Format: HH:mm
  endTime String @map("end_time") // Format: HH:mm
  // isBooked Boolean @default(false) @map("is_booked")

  mentorId Int @map("mentor_id")
  Mentor   Mentor @relation("mentor_schedules",fields: [mentorId], references: [id])
  courseId Int? @map("course_id")
  Course   Course? @relation("mentor_schedule_subscription",fields: [courseId], references: [id])

  Subscriptions Subscription[] @relation("mentor_schedule_subscription")

  @@map("mentor_schedules")
}

enum DayOfWeek {
  MONDAY
  TUESDAY
  WEDNESDAY
  THURSDAY
  FRIDAY
  SATURDAY
  SUNDAY
}


// ==================== Course ====================
model Course {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  name        String  @db.VarChar(255)
  status CourseStatus @map("status")
  description String? @db.Text 
  totalDuration     Int? @default(0) @map("total_duration")  // In hours
  price            Decimal @default(0) @map("price")  @db.Decimal(14,2)                       // In VND
  isPublic         Boolean           @default(true) @map("is_public") // If course is public, it can be accessed by anyone
  startDate        DateTime?         @map("start_date")// Start date of the course
  endDate          DateTime?         @map("end_date")// End date of the course
  objectives      String[]           // Course objectives
  targetAudiences TargetAudience[] @map("target_audiences")   // Target audiences for the course
  prerequisites    String[]           // Prerequisites for the course
  litmitOfStudents Int?              @default(100) @map("limit_of_students") // Limit of students for the course
  suspendedAt        BigInt?           @map("stopped_at") // Stop date of the course
  suspensionType CourseSuspensionType? @map("suspension_type") // Suspension type of the course

  imageId Int? @map("image_id")
  Image  File? @relation("course_image",fields: [imageId], references: [id])
  categoryId Int @map("category_id")
  Category   Category @relation("course_category", fields: [categoryId], references: [id])
  creatorId  Int @map("creator_id")
  Creator    Account @relation("course_creator",fields: [creatorId], references: [id])

  Sections          CourseSection[]         // Program courses have multiple sections
  Subscriptions Subscription[] @relation("course_subscription")
  MentorSchedules MentorSchedule[] @relation("mentor_schedule_subscription")

  @@map("courses")
}

enum CourseSuspensionType {
  COURSE_NOT_SUSPENDED
  COURSE_SUSPENDED_1_DAY
  COURSE_SUSPENDED_3_DAYS
  COURSE_SUSPENDED_7_DAYS
  COURSE_SUSPENDED_PERMANENTLY
}

enum CourseStatus {
  DRAFT
  PENDING
  STOPPED
  SUSPENDED
  ARCHIVED
  APPROVED
  REJECTED
}

enum TargetAudience { 
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

enum CourseType {
  SINGLE_EVENT
  PROGRAM
}

model CourseSection {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title       String  @db.VarChar(255)
  isPublic     Boolean  @map("is_public")          @default(false) // If section is public, it can be accessed by anyone
  ordinal     Int               
  description  String? @db.Text
  data         String?              // Additional data for the section

  courseId Int @map("course_id")
  Course   Course @relation(fields: [courseId], references: [id])

  SectionAttachments SectionAttachment[]

  @@map("course_sections")
}

model SectionAttachment {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  isPublic Boolean @default(true) @map("is_public")

  sectionId Int @map("section_id")
  Section   CourseSection @relation(fields: [sectionId], references: [id])
  fileId   Int @map("file_id")
  File     File @relation(fields: [fileId], references: [id])

  @@id([sectionId, fileId])
  @@map("section_attachments")
}

enum AttachmentType {
  VIDEO
  DOCUMENT
  IMAGE
}

// ==================== CATEGORY ====================
model Category {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  name          String  @db.VarChar(255)
  slug          String  @db.VarChar(255)
  description   String? @db.Text
  noOfProduct   Int     @default(0) @map("no_of_product")
  level         Int     @db.SmallInt
  ordinal       Int     @default(0)
  isRecommended Boolean @default(false) @map("is_recommended")

  parentCategoryId Int?      @map("parent_category_id")
  ParentCategory   Category? @relation("CategoryParentChild", fields: [parentCategoryId], references: [id])

  imageId Int? @map("image_id")
  Image   File? @relation("category_image",fields: [imageId], references: [id])

  Courses Course[] @relation("course_category")
  ChildrenCategories        Category[]                  @relation("CategoryParentChild")
  UserInterestedCategory UserInterestedCategory[] @relation("interested_category_user")

  @@index([name, isActive])
  @@map("categories")
}


enum EducationalLevel {
  PRIMARY
  SECONDARY
  HIGH_SCHOOL
  UNIVERSITY
}

enum AccountType {
  STUDENT
  MENTOR
  ADMIN
}


// ==================== File ====================
model File {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  filename String @default("hello_world") @map("file_name") @db.VarChar(255)
  publicId String @unique @map("public_id")
  url      String @map("url")
  version  Int @default(0) @map("version")
  signature String @map("signature")
  resourceType String @map("resource_type")
  size    Int    @default(0) @map("size")
  uploadedAt BigInt @map("uploaded_at")
  isUploaded Boolean @default(false) @map("is_uploaded")

  registrantId Int?     @map("registrant_id") 
  Registrant   Account? @relation(fields: [registrantId], references: [id])

  AccountAvatars Account[] @relation("accoun_avatar")
  Categories Category[] @relation("category_image")
  SectionAttachments SectionAttachment[]
  ImageVersions ImageVersion[]
  CvFileMentors Mentor[] @relation("cv_file")
  CourseImages Course[] @relation("course_image")

  @@map("files")
}


model ImageVersion {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  type ImageVersionType

  fileId  Int   @unique @map("file_id")
  File    File  @relation(fields: [fileId], references: [id])

  @@map("image_versions")
}

enum ImageVersionType {
  THUMBNAIL
  MEDIUM
  LARGE
}

// ==================== ROOM ====================
model AudioRoom {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title          String    @map("title")
  cid            String?    @unique @map("cid")
  type           AudioRoomType  @map("type")
  activeParticipantCount Int @map("active_participant_count") @default(0)
  isPublic       Boolean  @default(false) @map("is_public")
  status         RoomStatus @map("status") @default(SCHEDULED)
  startsAt       BigInt    @map("starts_at")
  roomUrl        String?    @map("room_url")
  duration       BigInt?    @map("duration")
  metadata       Json?      @map("metadata")
  iat            BigInt?    @map("iat")

  creatorId      Int       @map("creator_id")
  Creator        Account   @relation(fields: [creatorId], references: [id])

  Participants   AudioRoomParticipant[]

  Subscription Subscription? 
  ChatRoom ChatRoom?

  @@map("audio_rooms")
}

enum RoomStatus {
  SCHEDULED
  ONGOING
  FINISHED
  CANCELLED
}

model AudioRoomActivityHistory {
  id       Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  joinedAt       BigInt     @map("joined_at")
  leftAt         BigInt?     @map("left_at") @default(0)

  audioRoomParticipantId Int @map("audio_room_participant_id")
  AudioRoomParticipant   AudioRoomParticipant @relation(fields: [audioRoomParticipantId], references: [id])

  @@map("audio_room_activity_histories")
}

model AudioRoomParticipant {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  role           ParticipantAudioRoomRole  @map("role")
  isInCall       Boolean     @default(false) @map("is_in_room")

  roomId         Int        @map("room_id")
  AudioRoom      AudioRoom  @relation(fields: [roomId], references: [id])
  accountId      Int        @map("account_id") 
  Account        Account    @relation(fields: [accountId], references: [id])

  AudioRoomActivityHistories AudioRoomActivityHistory[]

  @@unique([roomId, accountId])
  @@map("audio_room_participants")
}


enum AudioRoomType {
  DEFAULT
  INTERVIEW
  AUDIOROOM
}

enum ParticipantAudioRoomRole {
  ADMIN
  USER
}


// ==================== SUBSCRIPTION ====================
model Subscription {
  id        Int      @id @default(autoincrement())
  isActive  Boolean  @default(true) @map("is_active")
  createdAt BigInt   @default(0) @map("created_at")
  updatedAt BigInt   @default(0) @map("updated_at")

  status         SubscriptionStatus @default(PENDING)
  originalPrice  Decimal            @default(0) @map("original_price") @db.Decimal(14, 2)
  wageStatus   WageStatus? @map("wage_status") 
  message       String?            @db.Text
  courseAccessStartAt BigInt? @map("course_access_start_at")
  courseAccessEndAt   BigInt? @map("course_access_end_at")
  rejectedAt    BigInt? @map("rejected_at")
  canceledAt    BigInt? @map("canceled_at")
  approvedAt    BigInt? @map("approved_at")
  
  courseId       Int                @map("course_id")
  Course         Course             @relation("course_subscription", fields: [courseId], references: [id])
  accountId      Int                @map("account_id")
  Account        Account            @relation("account_subscription", fields: [accountId], references: [id])
  
  mentorScheduleId Int? @map("mentor_schedule_id")
  MentorSchedule   MentorSchedule? @relation("mentor_schedule_subscription", fields: [mentorScheduleId], references: [id])
  audioRoomId Int? @map("audio_room_id") @unique
  AudioRoom   AudioRoom? @relation(fields: [audioRoomId], references: [id])
  Feedback Feedback?
  Report Report?

  Payment Payment? @relation("subscription_payment")

  @@map("subscriptions")
}

enum WageStatus {
  FULL_WAGE
  PARTIAL_30_PERCENT
  PARTIAL_70_PERCENT
  NOT_PAID
}


enum SubscriptionStatus {
  PENDING
  ACCEPTED
  REJECTED
  ACTIVE
  EXPIRED
  CANCELED
  ENDED
}

// ==================== PAYMENT ====================
model Payment {
  id           Int            @id @default(autoincrement())
  isActive     Boolean        @default(true) @map("is_active")
  createdAt    BigInt         @default(0) @map("created_at")
  updatedAt    BigInt         @default(0) @map("updated_at")

  status       PaymentStatus  @default(IN_PROGRESS)
  price        Decimal        @default(0) @map("price") @db.Decimal(14, 2)
  refundedPrice Decimal?      @map("refunded_price") @db.Decimal(14, 2) @default(0)
  refundedAt   BigInt?        @map("refunded_at")

  subscriptionId Int @map("subscription_id") @unique
  Subscription   Subscription @relation("subscription_payment", fields: [subscriptionId], references: [id])

  VnpayProviders VnpayProvider[] @relation("vnpay_payment")

  @@map("payments")
}

enum PaymentStatus {
  IN_PROGRESS
  DONE // Authorization Succeeded
  CANCELED
  REFUNDED
  PARTIAL_REFUNDED
  EXPIRED
}

model VnpayProvider {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  vnp_TxnRef String @map("vnp_TxnRef")
  vnp_OrderInfo String @map("vnp_OrderInfo")
  vnp_Amount Decimal @map("vnp_Amount") @db.Decimal(14,2)
  vnp_BankCode String? @map("vnp_BankCode")
  vnp_CreatedDate BigInt @map("vnp_createdDate")
  vnp_PayDate BigInt? @map("vnp_PayDate")
  vnp_TransactionNo String? @map("vnp_TransactionNo")
  vnp_TransactionStatus String? @map("vnp_TransactionStatus")

  metadata Json? @map("metadata")

  paymentId Int @map("payment_id") @unique
  Payment   Payment @relation("vnpay_payment",fields: [paymentId], references: [id])

  @@map("vnpay_providers")
}

enum VnpayCardType {
  ATM
  QR_CODE
}


// ==================== Chat Message ====================
model ChatMessage {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  message String? @db.Text
  type   ChatMessageType @map("type")
  isRead  Boolean @default(false) @map("is_read")
  readAt  BigInt? @map("read_at")

  senderId       Int          @map("sender_id")
  Sender         Account      @relation("chat_message_sender", fields: [senderId], references: [id])
  chatRoomId Int          @map("chat_room_id")
  ChatRoom   ChatRoom @relation("chat_messages_room", fields: [chatRoomId], references: [id])

  @@map("chat_messages")
}

enum ChatMessageType {
  TEXT
  FILE
}

model ChatRoom {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  numberOfMessages     Int              @default(0) @map("number_of_messages")
  numberOfParticipants Int              @default(0) @map("number_of_participants")
  chatRoomType     ChatRoomType @default(PRIVATE) @map("chat_room_type")
  lastMessageId        Int?             @map("last_message_id")

  audioRoomId Int? @map("audio_room_id") @unique
  AudioRoom   AudioRoom? @relation(fields: [audioRoomId], references: [id])

  ChatMessages             ChatMessage[]             @relation("chat_messages_room")
  ChatParticipants ChatParticipant[] @relation("chat_participants")

  @@map("chat_rooms")
}

enum ChatRoomType {
  PRIVATE
  GROUP
}

model ChatParticipant {
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  chatRoomId Int          @map("chat_room_id")
  ChatRoom   ChatRoom @relation("chat_participants", fields: [chatRoomId], references: [id])
  participantId  Int          @map("participant_id")
  Participant    Account      @relation("conversation_participant", fields: [participantId], references: [id])

  registrantId Int?     @map("registrant_id")
  Registrant   Account? @relation("conversation_registrant", fields: [registrantId], references: [id])

  @@id([chatRoomId, participantId])
  @@map("chat_participants")
}

// ==================== NOTIFICATION ====================
model Notification {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  title    String @db.VarChar(255)
  content  String @db.Text

  type   NotificationType
  isRead Boolean          @default(false) @map("is_read")
  readAt BigInt?          @map("read_at")

  scopes NotificationScope[] @default([]) @map("scopes")

  relationType NotificationRelationType @map("relation_type")
  relationId   Int? @map("relation_id")

  targetAccountId Int?     @map("target_account_id") // target account id is used to show notifications of specific account
  TargetAccount   Account? @relation("notification_target_account", fields: [targetAccountId], references: [id])


  @@map("notifications")
}

enum NotificationRelationType {
  COURSE
  SUBSCRIPTION
  PAYMENT
  MENTOR
  AUDIO_CALL
  ADMIN
  FEEDBACK
  REPORT
}

enum NotificationType {
  COURSE_CREATED
  COURSE_UPDATED
  COURSE_DELETED
  COURSE_APPROVED
  COURSE_REJECTED
  COURSE_SUSPENDED_WARNING
  COURSE_SUSPENDED_3_DAYS
  COURSE_SUSPENDED_7_DAYS
  COURSE_SUSPENDED_PERMANENTLY
  SUBSCRIPTION_CREATED
  SUBSCRIPTION_APPROVED
  SUBSCRIPTION_REJECTED
  SUBSCRIPTION_EXPIRED
  SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION
  SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION
  SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION
  SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION
  ACCOUNT_SUSPENDED_WARNING
  ACCOUNT_SUSPENDED_1_DAY
  ACCOUNT_SUSPENDED_3_DAYS
  ACCOUNT_SUSPENDED_7_DAYS
  ACCOUNT_SUSPENDED_PERMANENTLY
  AUDIO_CALL_CREATED
  MENTOR_REGISTERD
  MENTOR_APPROVED
  MENTOR_REJECTED
  PAYMENT_SUCCESS
  PAYMENT_FAILED
  DISCOUNT_AVAILABLE
  ADMIN_APPROVAL
  GENERAL_NOTIFICATION

  //FOR REPORT
  COURSE_REPORTED
  MENTOR_REPORTED
  FEEDBACK_REPORTED
  FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT
  REPORT_RESOLVED
  REPORT_REJECTED
}


enum NotificationScope {
  ALL
  INDIVIDUAL
}

model DeviceToken {
  id        Int     @id @default(autoincrement())
  isActive  Boolean @default(true) @map("is_active")
  createdAt BigInt  @default(0) @map("created_at")
  updatedAt BigInt  @default(0) @map("updated_at")

  token String @unique

  accountId Int?     @map("account_id")
  Account   Account? @relation("account_device_token", references: [id], fields: [accountId])

  @@map("device_tokens")
}

// ==================== Reviews ====================
model Feedback {
  id          Int      @id @default(autoincrement())
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   BigInt   @default(0) @map("created_at")
  updatedAt   BigInt   @default(0) @map("updated_at")

  isVisible   Boolean  @default(true) @map("is_visible") // Whether the review is visible to others
  courseReview String? @db.Text @map("course_review") // Review content
  courseRating Int @map("course_rating") // Rating for the course
  mentorReview String? @db.Text @map("mentor_review") // Review content
  mentorRating Int @map("mentor_rating") // Rating for the mentor

  reviewerId  Int      @map("reviewer_id") // The account ID of the reviewer
  Reviewer    Account  @relation("reviewer_account", fields: [reviewerId], references: [id])

  subscriptionId Int @map("subscription_id") @unique
  Subscription   Subscription @relation(fields: [subscriptionId], references: [id])

  Report Report?

  @@map("feedbacks")
}

enum ReviewType {
  COURSE
  MENTOR
}


//==================== REPORT ====================
model Report {
  id          Int      @id @default(autoincrement())
  isActive    Boolean  @default(true) @map("is_active")
  createdAt   BigInt   @default(0) @map("created_at")
  updatedAt   BigInt   @default(0) @map("updated_at")

  reporterId  Int      @map("reporter_id") // The account ID of the reporter
  Reporter    Account  @relation("reporter_account", fields: [reporterId], references: [id])
  description String @db.Text
  type        ReportType @map("type")
  status     ReportStatus @default(PENDING)
  resolution String? @db.Text

  subscriptionId Int? @map("subscription_id") @unique
  Subscription   Subscription? @relation(fields: [subscriptionId], references: [id])

  feedbackId Int? @map("feedback_id") @unique
  Feedback   Feedback? @relation(fields: [feedbackId], references: [id])

  @@map("reports")
}

enum ReportStatus {
  PENDING
  RESOLVED
  REJECTED
}

enum ReportType {
  COURSE_UNQUALIFIED
  MENTOR_ISSUES
  FEEDBACK_INAPPROPRIATE
}
</file>

<file path="src/domains/accounts/dto/account-change-password.dto.ts">
import { PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AccountChangePasswordDTO {
  @PasswordValidator()
  currentPassword: string;

  @PasswordValidator()
  newPassword: string;
}
</file>

<file path="src/domains/accounts/dto/account-create.dto.ts">
import { AccountType, Gender } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AccountCreateDTO {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @IsEnum(AccountType)
  accountType: AccountType;

  @NameValidator()
  name: string;

  @IsEnum(Gender)
  gender: Gender;

  @OnlyDate()
  dob: Date;

  @IsString()
  @IsOptional()
  bio?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;
}
</file>

<file path="src/domains/accounts/dto/account-detail.dto.ts">
export type AccountDetailDTO = {
  email: string;
  phoneNumber: string;
};
</file>

<file path="src/domains/accounts/dto/account-update.dto.ts">
import { Gender, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, MaxLength } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AccountUpdateDTO {
  @IsString()
  @IsOptional()
  name?: string;

  @EmailValidator()
  @IsOptional()
  email?: string;

  @PhoneNumberValidator()
  @IsOptional()
  phoneNumber?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @AddressDetailValidator()
  @IsOptional()
  addressDetail?: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  bio?: string;

  @IdValidator()
  @IsOptional()
  avatarId?: number;

  @IsEnum(Gender)
  @IsOptional()
  gender?: Gender;

  @OnlyDate()
  @IsOptional()
  dob?: string;

  static toUpdate(user: AuthUserDTO, body: AccountUpdateDTO): Prisma.AccountUpdateArgs {
    return {
      where: { id: user.accountId },
      data: {
        name: body.name,
        email: body.email,
        gender: body.gender,
        bio: body.bio,
        phoneNumber: body.phoneNumber,
        addressBase: body.addressBase,
        addressDetail: body.addressDetail,
        dob: body.dob && parsePrismaDate(body.dob),
        Avatar: body.avatarId && connectRelation(body.avatarId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/accounts/response/account.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';

export class AccountRESP {
  id: number;
  name: string;
  email: string;
  phoneNumber: string;
  gender: string;
  dob: string;
  addressBase: string | null;
  addressDetail: string | null;
  thumbnail?: ImageRESP;

  static fromEntity(e: AccountRESP, thumbnail?: ImageRESP): AccountRESP {
    return {
      id: e.id,
      name: e.name,
      email: e.email,
      gender: e.gender,
      phoneNumber: e.phoneNumber,
      dob: String(parsePrismaDateToEpoch(e.dob)),
      addressBase: e.addressBase,
      addressDetail: e.addressDetail,
      thumbnail,
    };
  }
}
</file>

<file path="src/domains/accounts/account.controller.ts">
import { Body, Controller, Get, Patch, Post, Req, UseGuards } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountChangePasswordDTO } from 'src/domains/accounts/dto/account-change-password.dto';
import { AccountUpdateDTO } from 'src/domains/accounts/dto/account-update.dto';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';

@Controller('accounts')
@UseGuards(AuthJwtGuard)
export class AccountController {
  constructor(private readonly accountService: AccountService) {}

  @Get('me')
  async get(@Req() req: AuthRequestDTO) {
    const { account, thumbnail } = await this.accountService.getMe(req.user.accountId);

    return BaseResponse.of(
      AccountRESP.fromEntity(
        {
          ...account,
          dob: String(account.dob),
        },
        thumbnail,
      ),
    );
  }

  @Patch('me')
  async update(@Req() req: AuthRequestDTO, @Body() body: AccountUpdateDTO) {
    const response = await this.accountService.updateAccount(req.user, body);
    return BaseResponse.of(response.id);
  }

  @Post('change-password')
  async changePassword(@Req() req: AuthRequestDTO, @Body() body: AccountChangePasswordDTO) {
    const response = await this.accountService.changePassword(req.user.accountId, body);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/accounts/account.service.ts">
import { Injectable } from '@nestjs/common';
import bcrypt from 'bcrypt';

import { AccountStatus } from '@prisma/client';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountErrorMessages } from 'src/shared/messages/error-messages';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ImageService } from '../image/image.service';
import { AccountChangePasswordDTO } from './dto/account-change-password.dto';
import { AccountCreateDTO } from './dto/account-create.dto';
import { AccountUpdateDTO } from './dto/account-update.dto';

@Injectable()
export class AccountService {
  private readonly HASH_ROUND = 10;
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async getMe(accountId: number) {
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: accountId },
      select: {
        id: true,
        name: true,
        email: true,
        gender: true,
        phoneNumber: true,
        dob: true,
        accountType: true,
        addressBase: true,
        addressDetail: true,
        avatarId: true,
      },
    });

    const thumbnail = await this.imageService.getImageOriginal(account.avatarId);

    return { account, thumbnail };
  }

  async createAccount(body: AccountCreateDTO) {
    const account = await this.transactionHost.tx.account.create({
      data: {
        name: body.name,
        gender: body.gender,
        email: body.email,
        dob: body.dob,
        bio: body.bio,
        password: this.hashPassword(body.password),
        phoneNumber: body.phoneNumber,
        accountType: body.accountType,
        addressBase: body.addressBase,
        addressDetail: body.addressDetail,
        status: AccountStatus.DEACTIVE,
      },
      select: { id: true, avatarId: true, name: true, email: true, accountType: true, status: true },
    });

    return account;
  }

  async updateAccount(user: AuthUserDTO, body: AccountUpdateDTO) {
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: user.accountId },
      select: { id: true },
    });

    if (!account) throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_FOUND, AccountErrorMessages.MSG01);

    if (body.avatarId) {
      await this.imageService.linkImageToAccount(user.accountId, body.avatarId);
    }

    if (body.email) {
      const existedAccount = await this.transactionHost.tx.account.findFirst({
        where: { email: body.email, id: { not: user.accountId } },
        select: { id: true },
      });

      if (existedAccount) {
        throw new ActionFailedException(ActionFailed.ACCOUNT_EMAIL_EXISTED, AccountErrorMessages.MSG02);
      }
    }

    if (body.phoneNumber) {
      const existedAccount = await this.transactionHost.tx.account.findFirst({
        where: { phoneNumber: body.phoneNumber, id: { not: user.accountId } },
        select: { id: true },
      });

      if (existedAccount) {
        throw new ActionFailedException(ActionFailed.ACCOUNT_PHONE_NUMBER_EXISTED, AccountErrorMessages.MSG03);
      }
    }

    return await this.transactionHost.tx.account.update(AccountUpdateDTO.toUpdate(user, body));
  }

  async changePassword(accountId: number, body: AccountChangePasswordDTO) {
    await this.checkCurrentPassword(accountId, body.currentPassword);

    return await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { password: this.hashPassword(body.newPassword) },
      select: { id: true },
    });
  }

  async resetPassword(accountId: number, password: string) {
    return await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { password: this.hashPassword(password) },
      select: { id: true },
    });
  }

  async checkCurrentPassword(id: number, currentPassword: string) {
    const account = await this.transactionHost.tx.account.findUniqueOrThrow({
      where: { id: id },
      select: { password: true },
    });

    const isMatch = this.verifyPassword(currentPassword, account.password);
    if (!isMatch) {
      throw new ActionFailedException(ActionFailed.INCORRECT_PASSWORD, AccountErrorMessages.MSG04);
    }
  }

  hashPassword(password: string) {
    return bcrypt.hashSync(password, this.HASH_ROUND);
  }

  verifyPassword(password: string, savedPassword: string) {
    return bcrypt.compareSync(password, savedPassword);
  }
}
</file>

<file path="src/domains/accounts/accounts.module.ts">
import { Module } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { AccountController } from 'src/domains/accounts/account.controller';
import { CommonModule } from 'src/services/common.module';
import { AccountService } from './account.service';

@Module({
  imports: [CommonModule],
  providers: [AccountService, JwtService],
  exports: [AccountService],
  controllers: [AccountController],
})
export class AccountModule {}
</file>

<file path="src/domains/audio-call/admin/dto/audio-call-admin-detail.dto.ts">
import { AudioRoomType, Prisma, RoomStatus } from '@prisma/client';

export class AudioCallAdminDetailDTO {
  id: number;
  name: string;
  title: string;
  cid: string;
  status: RoomStatus;
  type: AudioRoomType;
  startsAt: string;
  roomUrl: string;
  duration: string;
  isPublic: boolean;
  creator: { id: number; name: string };
  custom: Record<string, any>;

  static toFindFirst(roomId: number): Prisma.AudioRoomFindFirstOrThrowArgs {
    return {
      where: { id: roomId },
      select: {
        id: true,
        title: true,
        cid: true,
        status: true,
        isPublic: true,
        type: true,
        startsAt: true,
        roomUrl: true,
        duration: true,
        Creator: { select: { id: true, name: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/dto/participant-dto.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class AudioRoomParticipantDTO {
  @IdValidator()
  accountId: number;

  @IsEnum(ParticipantAudioRoomRole)
  @IsOptional()
  role?: ParticipantAudioRoomRole;

  @IsOptional()
  custom?: Record<string, any>;
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-create.request.ts">
import { AudioRoomType, ParticipantAudioRoomRole, Prisma, RoomStatus } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsJSON, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDateTimeRequestToEpoch } from 'src/shared/parsers/datetime.parse';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';
import { AudioRoomParticipantDTO } from '../dto/participant-dto';

export class AudioCallAdminCreateREQ {
  @IsString()
  title: string;

  @IsEnum(AudioRoomType)
  type: AudioRoomType;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  @IsArray()
  @Type(() => AudioRoomParticipantDTO)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  members: AudioRoomParticipantDTO[];

  @IsString()
  @IsOptional()
  roomUrl?: string;

  @IsEnum(RoomStatus)
  status: RoomStatus;

  @IsJSON()
  @IsOptional()
  metadata?: Record<string, any>;

  static toCreateInput(user: AuthUserDTO, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log(' ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(user.accountId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: user.accountId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }

  static toCreateMemberInput(ownerId: number, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log(' ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(ownerId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: ownerId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallAdminListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallAdminListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-detail.response.ts">
import { AccountType, AudioRoomType, Gender, RoomStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../../shared/types';

export class AudioRoomParticipantRESP {
  id: number;
  name: string;
  gender: Gender;
  dob: string;
  accountType: AccountType;
  thumbnail?: ImageRESP;
  cv?: FileRESP;

  static fromEntity(entity: AudioRoomParticipantGetPayload, thumbnail?: ImageRESP, cv?: FileRESP): AudioRoomParticipantRESP {
    return {
      id: entity.Account.id,
      name: entity.Account.name,
      gender: entity.Account.gender,
      accountType: entity.Account.accountType,
      dob: String(parseDateToEpoch(entity.Account.dob)),
      thumbnail: thumbnail,
      cv: cv,
    };
  }
}

export class AudioCallAdminDetailRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminDetailRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      participants: participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-list.response.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomGetPayload } from '../../shared/types';
import { AudioRoomParticipantRESP } from './audio-call-admin-detail.response';

export class AudioCallAdminListRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  activeParticipantCount: number;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminListRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      activeParticipantCount: entity.activeParticipantCount,
      participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../../auth/dto/auth-request.dto';
import { AudioCallAdminService } from './audio-call-admin.service';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';

@Controller('admin/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class AudioCallAdminController {
  constructor(private readonly audioCallAdminService: AudioCallAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallAdminListREQ) {
    const data = await this.audioCallAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) roomId: number) {
    const room = await this.audioCallAdminService.detail(roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallAdminController } from './audio-call-admin.controller';
import { AudioCallAdminService } from './audio-call-admin.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallAdminController],
  providers: [AudioCallAdminService],
  exports: [AudioCallAdminService],
})
export class AudioCallAdminModule {}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { FileService } from 'src/domains/file/file.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { AuthUserDTO } from '../../auth/dto/auth-user.dto';
import { ImageService } from '../../image/image.service';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallAdminDetailDTO } from './dto/audio-call-admin-detail.dto';
import { AudioCallAdminCreateREQ } from './request/audio-call-admin-create.request';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';
import { AudioCallAdminDetailRESP } from './response/audio-call-admin-detail.response';
import { AudioCallAdminListRESP } from './response/audio-call-admin-list.response';

@Injectable()
export class AudioCallAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createAudioCall(user: AuthUserDTO, body: AudioCallAdminCreateREQ) {
    const call = await this.transactionHost.tx.audioRoom.create(AudioCallAdminCreateREQ.toCreateInput(user, body));
    console.log(' ~ AudioCallAdminService ~ createAudioCall ~ call:', call);

    return call;
  }

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallAdminListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          true,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }

  async detail(roomId: number) {
    const call = (await this.transactionHost.tx.audioRoom.findFirstOrThrow(
      AudioCallAdminDetailDTO.toFindFirst(roomId),
    )) as AudioRoomGetPayload;

    const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
      AudioCallAdminDetailDTO.toFindManyParticipants(roomId),
    )) as AudioRoomParticipantGetPayload[];

    const participantDTOs = await participantMapper(
      participants,
      this.imageService,
      this.fileService,
      this.transactionHost,
      true,
    );

    return AudioCallAdminDetailRESP.fromEntity(call, participantDTOs);
  }

  // @Transactional(TRANSACTION_TIMEOUT)
  // async joinAudioCall(user: AuthUserDTO, roomId: number) {
  //   const call = await this.transactionHost.tx.audioRoom.findFirstOrThrow({
  //     where: { id: roomId },
  //     select: { id: true, status: true, isPublic: true, Participants: { select: { accountId: true, isInCall: true } } },
  //   });

  //   const isPartipatedOrInCall = call.Participants.some(
  //     (participant) => participant.accountId === user.accountId && !participant.isInCall,
  //   );

  //   if (!call.isPublic && !isPartipatedOrInCall) {
  //     throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN);
  //   }

  //   if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
  //     throw new ActionFailedException(ActionFailed.CALL_INVALID);
  //   }

  //   const updatedCall = await this.transactionHost.tx.audioRoom.update({
  //     where: { id: roomId },
  //     data: { activeParticipantCount: { increment: isPartipatedOrInCall ? 0 : COMMON_CONSTANT.DEFAULT_INCREMENT } },
  //     select: { id: true },
  //   });

  //   await this.transactionHost.tx.audioRoomParticipant.upsert({
  //     where: { roomId_accountId: { roomId: updatedCall.id, accountId: user.accountId } },
  //     create: {
  //       isInCall: true,
  //       role: ParticipantAudioRoomRole.USER,
  //       Account: connectRelation(user.accountId),
  //       AudioRoom: connectRelation(updatedCall.id),
  //     },
  //     update: { isInCall: true, joinedAt: nowEpoch() },
  //     select: { roomId: true },
  //   });

  //   return updatedCall;
  // }
}
</file>

<file path="src/domains/audio-call/base/audio-call-list-base.request.ts">
import { AccountType, AudioRoomType, Prisma, RoomStatus } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class AudioCallBaseListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  title?: string;

  @IsEnum(AudioRoomType)
  @IsOptional()
  type?: AudioRoomType;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsEnum(RoomStatus)
  @IsOptional()
  status?: RoomStatus;

  static toFilterByAccount(user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    if (!user) return;
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.MENTOR:
        return {
          OR: [{ Creator: { id: user.accountId } }, { Participants: { some: { accountId: user.accountId } } }],
        };
      case AccountType.STUDENT:
        return {
          isPublic: false,
          Participants: {
            some: { accountId: user.accountId },
          },
        };
      default:
        throw new ActionFailedException(ActionFailed.ACCOUNT_INVALID_ROLE);
    }
  }

  static toQueryCondition(query: AudioCallBaseListREQ, user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    const filtetByAccount = this.toFilterByAccount(user);
    return {
      AND: [filtetByAccount, parsePrismaSearch('title', query.title)],
      type: query.type,
      isPublic: query.isPublic,
      status: query.status,
    };
  }
}
</file>

<file path="src/domains/audio-call/client/request/audio-call-client-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallClientListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallClientListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.controller.ts">
import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AudioCallClientService } from './audio-call-client.service';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Controller('client/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class AudioCallClientController {
  constructor(private readonly audioCallClientService: AudioCallClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallClientListREQ) {
    const data = await this.audioCallClientService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallClientController } from './audio-call-client.controller';
import { AudioCallClientService } from './audio-call-client.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallClientController],
  providers: [AudioCallClientService],
})
export class AudioCallClientModule {}
</file>

<file path="src/domains/audio-call/client/audio-call-client.service.ts">
import { Injectable } from '@nestjs/common';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { AudioCallAdminListREQ } from '../admin/request/audio-call-admin-list.request';
import { AudioCallAdminListRESP } from '../admin/response/audio-call-admin-list.response';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Injectable()
export class AudioCallClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallClientListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          false,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-end.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

export class AudioCallEndDTO {
  static toEnd(roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.FINISHED,
        Participants: {
          updateMany: {
            where: { roomId },
            data: addUpdationTimestamps({ isInCall: false }),
          },
        },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-join.dto.ts">
import { ParticipantAudioRoomRole, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { addCreationTimestamps, addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class AudioCallJoinDTO {
  static toUpsertParticipant(user: AuthUserDTO, roomId: number): Prisma.AudioRoomParticipantUpsertArgs {
    return {
      where: { roomId_accountId: { roomId: roomId, accountId: user.accountId } },
      create: addCreationTimestamps({
        isInCall: true,
        role: ParticipantAudioRoomRole.USER,
        Account: connectRelation(user.accountId),
        AudioRoom: connectRelation(roomId),
      }),

      update: addUpdationTimestamps({
        isInCall: true,
      }),
      select: { roomId: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-start.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class AudioCallStartDTO {
  static toStart(user: AuthUserDTO, roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.ONGOING,
        // Participants: {
        //   update: {
        //     where: { roomId_accountId: { roomId, accountId: user.accountId } },
        //     data: addUpdationTimestamps({ joinedAt: nowEpoch(), isInCall: true }),
        //   },
        // },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/response/audio-call-participant-history.response.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomActivityHistoryGetPayload, AudioRoomParticipantAccount } from '../shared/types';

export class AudioCallParticipantHistoryRESP {
  id: number;
  joinedAt: string;
  leftAt: string;
  AudioParticipant: { accountId: number; role: ParticipantAudioRoomRole } & AudioRoomParticipantAccount;

  static fromEntity(
    e: AudioRoomActivityHistoryGetPayload,
    account: AudioRoomParticipantAccount,
  ): AudioCallParticipantHistoryRESP {
    return {
      id: e.id,
      joinedAt: parseEpoch(e.joinedAt),
      leftAt: parseEpoch(e.leftAt),
      AudioParticipant: {
        accountId: e.AudioRoomParticipant.accountId,
        name: account.name,
        thumbnail: account.thumbnail,
        role: e.AudioRoomParticipant.role,
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/shared/helpers.ts">
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { AudioRoomParticipantRESP } from '../admin/response/audio-call-admin-detail.response';
import { AudioRoomParticipantGetPayload } from './types';

export const participantMapper = async (
  participants: AudioRoomParticipantGetPayload[],
  imageService: ImageService,
  fileService: FileService,
  transactionHost: any,
  isCvPublic: boolean = false,
): Promise<AudioRoomParticipantRESP[]> => {
  return await Promise.all(
    participants.map(async (participant: AudioRoomParticipantGetPayload) => {
      const thumbnail = await imageService.getImageOriginal(participant.Account.avatarId);
      let cv: any;
      if (participant.Account.accountType === 'MENTOR') {
        const mentor = await transactionHost.tx.mentor.findFirst({
          where: { accountId: participant.Account.id },
          select: {
            fileId: true,
          },
        });

        cv = isCvPublic ? await fileService.detail(mentor.fileId) : null;
      }

      return AudioRoomParticipantRESP.fromEntity(participant, thumbnail, cv);
    }),
  );
};
</file>

<file path="src/domains/audio-call/shared/types.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';

export type AudioRoomParticipantAccount = Pick<AccountRESP, 'name' | 'thumbnail'>;

export type AudioRoomGetPayload = Prisma.AudioRoomGetPayload<{
  include: {
    Participants: true;
    Creator: true;
    Subscription: true;
  };
}>;

export type AudioRoomParticipantGetPayload = Prisma.AudioRoomParticipantGetPayload<{
  include: { Account: true; AudioRoom: true; AudioRoomActivityHistories: true };
}>;

export type AudioRoomActivityHistoryGetPayload = Prisma.AudioRoomActivityHistoryGetPayload<{
  include: { AudioRoomParticipant: true };
}>;

export type AudioRoomSessionParticipantLeave = {
  call_cid: string;
  participant: { user: { id: number } };
};
</file>

<file path="src/domains/audio-call/audio-call.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Patch, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { AudioCallService } from './audio-call.service';

@Controller('audio-call')
@UseGuards(AuthJwtGuard)
export class AudioCallController {
  constructor(private readonly AudioCallService: AudioCallService) {}

  @Get(':id/histories')
  async histories(@Param('id', ParseIntPipe) roomId: number) {
    const histories = await this.AudioCallService.getAudioCallHistory(roomId);
    return BaseResponse.of(histories);
  }

  @Patch(':id/join')
  async join(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.joinAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/leave')
  async leave(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.leaveAudioCall(req.user.accountId, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/start')
  async start(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.startAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/end')
  async end(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.endAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/audio-call.gateway.ts">
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { AudioCallChannel } from 'src/shared/constants/event.constant';
import { AudioCallService } from './audio-call.service';
import { AudioRoomSessionParticipantLeave } from './shared/types';

@Injectable()
export class AudioCallGateway {
  private readonly logger = new Logger(AudioCallGateway.name);
  constructor(private readonly audioCallService: AudioCallService) {}

  @OnEvent(AudioCallChannel.LEAVE_CALL)
  async handleParticipantSessionLeave(payload: AudioRoomSessionParticipantLeave) {
    const cid = payload.call_cid;
    this.logger.log(' ~ AudioCallGateway ~ handleParticipantSessionLeave ~ cid:', cid);

    const roomId = cid.split('-')[1];
    if (!payload) {
      return;
    }

    await this.audioCallService.leaveAudioCall(Number(payload.participant.user.id), Number(roomId));
  }
}
</file>

<file path="src/domains/audio-call/audio-call.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from './admin/audio-call-admin.module';
import { AudioCallController } from './audio-call.controller';
import { AudioCallGateway } from './audio-call.gateway';
import { AudioCallService } from './audio-call.service';
import { AudioCallClientModule } from './client/audio-call-client.module';

@Module({
  imports: [AudioCallAdminModule, AudioCallClientModule],
  controllers: [AudioCallController],
  providers: [AudioCallService, AudioCallGateway],
  exports: [AudioCallService],
})
export class AudioCallModule {}
</file>

<file path="src/domains/audio-call/audio-call.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AudioCallService } from './admin/audio-call-admin.service';

describe('AudioCallService', () => {
  let service: AudioCallService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AudioCallService],
    }).compile();

    service = module.get<AudioCallService>(AudioCallService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/audio-call/audio-call.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomParticipant,
  AudioRoomType,
  ParticipantAudioRoomRole,
  RoomStatus,
  SubscriptionStatus,
  WageStatus,
} from '@prisma/client';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { AUDIO_ROOM_CONSTANT, AudioRoomActivity } from 'src/shared/constants/audio-room.constant';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { asyncSome } from 'src/shared/helpers/function.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { AudioCallErrorMessages } from 'src/shared/messages/error-messages';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ImageService } from '../image/image.service';
import { AudioCallEndDTO } from './dto/audio-call-end.dto';
import { AudioCallJoinDTO } from './dto/audio-call-join.dto';
import { AudioCallStartDTO } from './dto/audio-call-start.dto';
import { AudioCallParticipantHistoryRESP } from './response/audio-call-participant-history.response';
import { AudioRoomActivityHistoryGetPayload, AudioRoomGetPayload } from './shared/types';

@Injectable()
export class AudioCallService {
  private readonly logger = new Logger(AudioCallService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async getAudioCallHistory(audioRoomId: number) {
    await this.checkExistedRoom(audioRoomId);
    const histories = await this.transactionHost.tx.audioRoomActivityHistory.findMany({
      where: { AudioRoomParticipant: { roomId: audioRoomId } },
      select: {
        id: true,
        joinedAt: true,
        leftAt: true,
        AudioRoomParticipant: { select: { accountId: true, role: true } },
      },
    });

    return await Promise.all(
      histories.map(async (history: AudioRoomActivityHistoryGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(history.AudioRoomParticipant.accountId);
        const account = await this.transactionHost.tx.account.findFirst({
          where: { id: history.AudioRoomParticipant.accountId },
          select: { name: true },
        });

        return AudioCallParticipantHistoryRESP.fromEntity(history, {
          name: account.name,
          thumbnail,
        });
      }),
    );
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async startAudioCall(user: AuthUserDTO, roomId: number) {
    console.log(' ~ AudioCallService ~ startAudioCall ~ user:', user.accountId);
    /* Check existed call */
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const havePermissionToStart = await asyncSome<AudioRoomParticipant>(call.Participants, async (participant) => {
      const isInOtherCall = await this.checkAccountInCall(participant.accountId, roomId);
      console.log(' ~ AudioCallService ~ havePermissionToStart ~ isInOtherCall:', isInOtherCall);

      const tmp =
        participant.accountId === user.accountId &&
        participant.role === ParticipantAudioRoomRole.ADMIN &&
        !participant.isInCall &&
        !isInOtherCall;

      return tmp;
    });

    if (!havePermissionToStart) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG02);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* Update status of call & participant started call */
    const updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallStartDTO.toStart(user, roomId));

    //TODO: Implement push notification to all participants

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async endAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const canEndCall = call.Participants.some(
      (participant) => participant.accountId === user.accountId && participant.role === ParticipantAudioRoomRole.ADMIN,
    );

    if (!canEndCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG03);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const now = nowEpoch();
    let updatedCall: any;
    if (call.Subscription) {
      const courseAccessStartAt = parseEpoch(call.Subscription.courseAccessStartAt);
      const courseAccessEndAt = parseEpoch(call.Subscription.courseAccessEndAt);

      if (now > courseAccessStartAt && now < courseAccessEndAt) {
        throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      } else {
        const subcription = await this.transactionHost.tx.subscription.update({
          where: { id: call.Subscription.id },
          data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
          select: { id: true },
        });

        this.logger.log(` ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      }

      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      // if (now > courseAccessStartAt && now < courseAccessEndAt) {
      //   throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      // } else if (now < courseAccessStartAt) {
      //   this.logger.log(` ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      //   updatedCall = await this.transactionHost.tx.audioRoomParticipant.updateMany({
      //     where: { roomId: roomId, isInCall: true },
      //     data: { isInCall: false },
      //   });
      // } else {
      //   const subcription = await this.transactionHost.tx.subscription.update({
      //     where: { id: call.Subscription.id },
      //     data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
      //     select: { id: true },
      //   });

      //   this.logger.log(` ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      //   updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));
      // }

      /* Update status of call & participant started call */
      this.logger.log(` ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    } else if (call.type === AudioRoomType.INTERVIEW) {
      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    }

    const callId = updatedCall ? updatedCall.id : roomId;

    await this.transactionHost.tx.audioRoomActivityHistory.updateMany({
      where: { AudioRoomParticipant: { roomId: callId }, leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT },
      data: { leftAt: nowEpoch() },
    });

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async joinAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);
    const isInCall = await this.checkAccountInCall(user.accountId, roomId);

    const isPartipated = call.Participants.some(
      (participant) => participant.accountId === user.accountId && !participant.isInCall,
    );

    if (isInCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG05);
    } else if (!call.isPublic && !isPartipated) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG06);
    }

    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { increment: COMMON_CONSTANT.DEFAULT_INCREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.upsert(AudioCallJoinDTO.toUpsertParticipant(user, roomId));
    await this.createPaticipantHistory(user.accountId, updatedCall.id, AudioRoomActivity.JOIN);

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async leaveAudioCall(accountId: number, roomId: number) {
    /* Check existed audio room */
    const call = await this.checkExistedRoom(roomId);
    const participants = await this.getAllParticipants(roomId);

    /* Check if user is joinning the audio room */
    const isPartipated = participants.some((participant) => participant.accountId === accountId && participant.isInCall);

    if (!isPartipated) {
      this.logger.error(` ~ AudioCallService ~ leaveAudioCall ~ the user with id ${accountId} is not in call`);
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_LEAVE);
    }

    /* Check the status of room */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      this.logger.error(` ~ AudioCallService ~ leaveAudioCall ~ the call status is invalid`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* We must decrement the number of participant */
    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { decrement: COMMON_CONSTANT.DEFAULT_DECREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.update({
      where: { roomId_accountId: { roomId: updatedCall.id, accountId: accountId } },
      data: { isInCall: false },
      select: { roomId: true },
    });

    await this.createPaticipantHistory(accountId, updatedCall.id, AudioRoomActivity.LEAVE);

    return updatedCall;
  }

  async createPaticipantHistory(accountId: number, roomId: number, type: AudioRoomActivity) {
    if (!accountId || !roomId) {
      this.logger.error(` ~ AudioCallService ~ createPaticipantHistory ~ invalid accountId or roomId`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID);
    }

    const participant = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: { accountId, roomId },
      select: { id: true },
    });

    if (!participant) {
      this.logger.error(` ~ AudioCallService ~ createPaticipantHistory ~ the participant is not existed`);
      throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_NOT_FOUND);
    }

    //Find the lastest record of participant
    const lastestRecord = await this.transactionHost.tx.audioRoomActivityHistory.findFirst({
      where: { leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT, audioRoomParticipantId: participant.id },
      select: { id: true },
    });
    this.logger.log(' ~ AudioCallService ~ createPaticipantHistory ~ lastestRecord:', lastestRecord);

    if (type === AudioRoomActivity.JOIN) {
      //If the lastest record is existed with joinedAt but not leftAt
      // then the user is already in call
      if (lastestRecord) {
        throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_JOINED, AudioCallErrorMessages.MSG08);
      }

      await this.transactionHost.tx.audioRoomActivityHistory.create({
        data: {
          AudioRoomParticipant: connectRelation(participant.id),
          joinedAt: nowEpoch(),
        },
      });
    } else {
      // If the lastest record is existed with joinedAt but not leftAt
      // Then we will update the leftAt field
      await this.transactionHost.tx.audioRoomActivityHistory.update({
        where: { id: lastestRecord.id },
        data: { leftAt: nowEpoch() },
      });
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancelCall(roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    if (call.status === RoomStatus.FINISHED || call.status === RoomStatus.ONGOING) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { status: RoomStatus.CANCELLED },
      select: { id: true },
    });

    return updatedCall;
  }

  private async checkExistedRoom(roomId: number): Promise<AudioRoomGetPayload> {
    const call = (await this.transactionHost.tx.audioRoom.findFirst({
      where: { id: roomId },
      select: {
        id: true,
        status: true,
        type: true,
        isPublic: true,
        Subscription: { select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true } },
        Participants: { select: { accountId: true, isInCall: true, role: true } },
        activeParticipantCount: true,
      },
    })) as AudioRoomGetPayload;

    if (!call) {
      throw new ActionFailedException(ActionFailed.CALL_NOT_FOUND);
    }

    return call;
  }

  private async checkAccountInCall(accountId: number, roomId: number): Promise<boolean> {
    const call = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: {
        accountId,
        isInCall: true,
        roomId: { not: roomId },
        AudioRoom: { status: RoomStatus.ONGOING },
      },
      select: { roomId: true },
    });

    console.log(' ~ AudioCallService ~ checkAccountInCall ~ isInCall:', call);

    return !!call;
  }

  private async getAllParticipants(roomId: number) {
    const participants = await this.transactionHost.tx.audioRoomParticipant.findMany({
      where: { roomId },
      select: { accountId: true, role: true, isInCall: true },
    });

    return participants;
  }
}
</file>

<file path="src/domains/auth/dto/auth-jwt-payload.dto.ts">
import jwt from 'jsonwebtoken';
export type AuthJwtPayloadDTO = Pick<jwt.JwtPayload, 'sub'>;
</file>

<file path="src/domains/auth/dto/auth-login.dto.ts">
import { Prisma } from '@prisma/client';

import { AuthLoginREQ } from '../request/auth-login.request';

export class AuthLoginDTO {
  email: string;
  password: string;
  ipAddress?: string;

  static fromRequest(body: AuthLoginREQ, ipAddress: string): AuthLoginDTO {
    return { email: body.email, password: body.password, ipAddress };
  }

  static toFindAccountUnique(body: AuthLoginDTO): Prisma.AccountFindFirstOrThrowArgs {
    return {
      where: { email: body.email },
      select: {
        name: true,
        id: true,
        email: true,
        password: true,
        accountType: true,
        avatarId: true,
      },
    };
  }
}
</file>

<file path="src/domains/auth/dto/auth-request.dto.ts">
import { Request } from 'express';

import { AuthUserDTO } from './auth-user.dto';

export type AuthRequestDTO = Request & { user: AuthUserDTO };
</file>

<file path="src/domains/auth/dto/auth-user.dto.ts">
import { Account, Prisma } from '@prisma/client';

export class AuthUserDTO {
  accountId: Account['id'];
  email: Account['email'];
  phoneNumber: Account['phoneNumber'];
  accountType: Account['accountType'];

  static fromEntity(a: Prisma.AccountGetPayload<unknown>): AuthUserDTO {
    return {
      accountId: a.id,
      email: a.email,
      phoneNumber: a.phoneNumber,
      accountType: a.accountType,
    };
  }
}
</file>

<file path="src/domains/auth/request/auth-email--reset-password.request.ts">
import { EmailValidator } from 'src/shared/request-validator/account.validator';

export class AuthFindPasswordResetREQ {
  @EmailValidator()
  email: string;
}
</file>

<file path="src/domains/auth/request/auth-email-verification.request.ts">
import { EmailValidator } from 'src/shared/request-validator/account.validator';

export class AuthEmailVerificationREQ {
  @EmailValidator()
  email: string;
}
</file>

<file path="src/domains/auth/request/auth-find-password-reset.request.ts">
import { IsString } from 'class-validator';
import { PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AuthFindPasswordResetREQ {
  @PasswordValidator()
  password: string;

  @IsString()
  token: string;
}
</file>

<file path="src/domains/auth/request/auth-login.request.ts">
import { EmailValidator, PasswordValidator } from 'src/shared/request-validator/account.validator';

export class AuthLoginREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;
}
</file>

<file path="src/domains/auth/request/auth-mentor-register.request.ts">
import { AccountType, AchievementType, Gender, MentorStatus, Prisma } from '@prisma/client';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  ArrayMinSize,
  IsArray,
  IsEnum,
  IsNotEmpty,
  IsNumber,
  IsOptional,
  IsString,
  MaxLength,
  ValidateIf,
  ValidateNested,
} from 'class-validator';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  OtpValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthMentorRegisterREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @NameValidator()
  name: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @OnlyDate()
  dob: string;

  @IsEnum(Gender)
  gender: Gender;

  @IsArray()
  @IsNotEmpty()
  @ArrayMaxSize(3)
  @ArrayMinSize(1)
  @Type(() => AuthMentorAchievementREQ)
  @ValidateNested({ each: true })
  achievements: AuthMentorAchievementREQ[];

  @OtpValidator()
  @IsOptional()
  phoneOtpCode?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  @IsOptional()
  @IsNumber()
  avatarId?: number;

  static toCreateAccountDto(body: AuthMentorRegisterREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);

    return {
      name: body.name,
      gender: body.gender,
      email: body.email,
      password: body.password,
      phoneNumber: body.phoneNumber,
      addressBase: body.addressBase,
      addressDetail: body.addressDetail,
      dob: new Date(parseDob),
      accountType: AccountType.MENTOR,
    };
  }

  static toCreateMentorArgs(body: AuthMentorRegisterREQ, accountId: number): Prisma.MentorCreateArgs {
    return {
      data: {
        status: MentorStatus.PENDING,
        Account: connectRelation(accountId),
      },
      select: { id: true, accountId: true },
    };
  }

  static toCreateMentorProfileArgs(body: AuthMentorRegisterREQ, mentorId: number): Prisma.ProfileAchievementCreateManyArgs {
    console.log(' ~ AuthMentorRegisterREQ ~ toCreateMentorProfileArgs ~ mentorId:', mentorId);
    console.log(' ~ AuthMentorRegisterREQ ~ toCreateMentorProfileArgs ~ body:', body);
    return {
      data: body.achievements.map((achievement) => {
        return AuthMentorAchievementREQ.ToCreateByAchievementType(achievement, mentorId);
      }),
    };
  }
}

export class AuthMentorAchievementREQ {
  @NameValidator()
  @ValidateIf((o) => o.achievementType === AchievementType.CERTIFICATION)
  name: string;

  @IsString()
  @MaxLength(255)
  organization: string; // Can be company or institution or certification body

  @IsEnum(AchievementType)
  achievementType: AchievementType;

  @IsString()
  @MaxLength(255)
  @IsOptional()
  description?: string;

  @BooleanValidator()
  @IsOptional()
  isCurrent?: boolean = false;

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EXPERIENCE)
  position: string; // For experience

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EDUCATION)
  major: string; // For education

  @OnlyDate()
  startDate: string;

  @OnlyDate()
  @DateMonthYearCompare({ startField: 'startDate' })
  @ValidateIf((o) => !o.isCurrent)
  endDate: string;

  static ToCreateByAchievementType(body: AuthMentorAchievementREQ, mentorId: number): Prisma.ProfileAchievementCreateManyInput {
    const endDate = body.isCurrent ? null : parsePrismaDate(body.endDate);

    switch (body.achievementType) {
      case AchievementType.EXPERIENCE:
        return {
          mentorId: mentorId,
          organization: body.organization,
          description: body.description,
          position: body.position,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          mentorId: mentorId,
          organization: body.organization,
          description: body.description,
          major: body.major,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          mentorId: mentorId,
          name: body.name,
          organization: body.organization,
          description: body.description,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: endDate,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
</file>

<file path="src/domains/auth/request/auth-otp-checkout.request.ts">
import { OtpValidator, PhoneNumberValidator } from 'src/shared/request-validator/account.validator';

export class AuthOtpCheckoutREQ {
  @PhoneNumberValidator()
  phoneNumber: string;

  @OtpValidator()
  otpCode: string;
}
</file>

<file path="src/domains/auth/request/auth-otp-send.request.ts">
import { PhoneNumberValidator } from 'src/shared/request-validator/account.validator';

export class AuthOtpSendREQ {
  @PhoneNumberValidator()
  phoneNumber: string;
}
</file>

<file path="src/domains/auth/request/auth-student-register.request.ts">
import { AccountType, EducationalLevel, Gender, Prisma } from '@prisma/client';
import { IsEnum, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import {
  AddressBaseValidator,
  AddressDetailValidator,
  EmailValidator,
  NameValidator,
  OtpValidator,
  PasswordValidator,
  PhoneNumberValidator,
} from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthRegistrationStudentREQ {
  @EmailValidator()
  email: string;

  @PasswordValidator()
  password: string;

  @NameValidator()
  name: string;

  @PhoneNumberValidator()
  phoneNumber: string;

  @IsString()
  @MaxLength(255)
  major: string;

  @IsEnum(EducationalLevel)
  educationLevel: EducationalLevel;

  @OnlyDate()
  dob: string;

  @IsEnum(Gender)
  gender: Gender;

  @OtpValidator()
  @IsOptional()
  phoneOtpCode?: string;

  @IsOptional()
  @AddressBaseValidator()
  addressBase?: string;

  @IsOptional()
  @AddressDetailValidator()
  addressDetail?: string;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  static toCreateAccountDto(body: AuthRegistrationStudentREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);

    return {
      name: body.name,
      gender: body.gender,
      email: body.email,
      password: body.password,
      phoneNumber: body.phoneNumber,
      addressBase: body.addressBase,
      addressDetail: body.addressDetail,
      dob: new Date(parseDob),
      accountType: AccountType.STUDENT,
    };
  }

  static toCreateStudentArgs(body: AuthRegistrationStudentREQ, accountId: number): Prisma.StudentCreateArgs {
    return {
      data: {
        Account: connectRelation(accountId),
        major: body.major,
        educationalLevel: body.educationLevel,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/auth/request/auth-test-account.request.ts">
import { AccountType, Gender } from '@prisma/client';
import { IsOptional } from 'class-validator';
import { random } from 'lodash';
import { AccountCreateDTO } from 'src/domains/accounts/dto/account-create.dto';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { EmailValidator, NameValidator, PasswordValidator } from 'src/shared/request-validator/account.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class AuthTestAccountREQ {
  @EmailValidator()
  email: string;

  @NameValidator()
  name: string;

  @OnlyDate()
  dob: string;

  @PasswordValidator()
  password: string;

  @IsOptional()
  accountType?: AccountType = AccountType.STUDENT;

  static toAccountDto(body: AuthTestAccountREQ): AccountCreateDTO {
    const parseDob = parsePrismaDate(body.dob);
    return {
      name: body.name,
      dob: new Date(parseDob),
      gender: Gender.MALE,
      email: body.email,
      password: body.password,
      phoneNumber: `628${random(1000000000)}`,
      accountType: body.accountType,
    };
  }
}
</file>

<file path="src/domains/auth/response/auth-find-password.response.ts">
export class AuthFindPasswordRESP {
  phoneNumber: string;
  verificationCode: string;

  static fromBuyer(phoneNumber: string, verificationCode: string): AuthFindPasswordRESP {
    return { phoneNumber, verificationCode };
  }
}
</file>

<file path="src/domains/auth/response/auth-login.response.ts">
import { Prisma } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';

export class AuthLoginRESP {
  id: number;
  accessToken: string;
  accountType: string;
  name: string;
  avatar: ImageRESP;

  static fromAccount(account: Prisma.AccountGetPayload<unknown>, accessToken: string, avatar: ImageRESP): AuthLoginRESP {
    return {
      id: account.id,
      name: account.name,
      accessToken,
      accountType: account.accountType,
      avatar: avatar,
    };
  }
}
</file>

<file path="src/domains/auth/response/auth-register.response.ts">
import { AccountStatus, AccountType, Prisma } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';

export class AuthRegisterRESP {
  id: number;
  accountType: AccountType;
  name: string;
  status: AccountStatus;
  avatar: ImageRESP;
  token?: string;

  static fromAccount(account: Prisma.AccountGetPayload<unknown>, avatar: ImageRESP, token?: string): AuthRegisterRESP {
    return {
      id: account.id,
      name: account.name,
      avatar: avatar,
      status: account.status,
      accountType: account.accountType,
      token,
    };
  }
}
</file>

<file path="src/domains/auth/auth-jwt.guard.ts">
import { ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';
import { AuthGuard } from '@nestjs/passport';
import { Observable } from 'rxjs';
import { IS_PUBLIC_KEY } from './auth-public.decorator';

@Injectable()
export class AuthJwtGuard extends AuthGuard('jwt') {
  constructor(private reflector: Reflector) {
    super();
  }

  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    // const token = this.extractTokenFromHeader(request);

    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [context.getHandler(), context.getClass()]);
    if (isPublic) return true;

    return super.canActivate(context);
  }

  private extractTokenFromHeader(request: Request): string | undefined {
    const [type, token] = request.headers['authorization']?.split(' ') ?? [];
    return type === 'Bearer' ? token : undefined;
  }
}
</file>

<file path="src/domains/auth/auth-jwt.strategy.ts">
import { Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { AccountStatus, TokenType } from '@prisma/client';
import { ExtractJwt, Strategy } from 'passport-jwt';
import { JWT_SECRET_KEY } from 'src/app.config';
import { PrismaService } from 'src/services/prisma/prisma.service';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AuthJwtPayloadDTO } from './dto/auth-jwt-payload.dto';
import { AuthUserDTO } from './dto/auth-user.dto';

@Injectable()
export class AuthJwtStrategy extends PassportStrategy(Strategy, 'jwt') {
  private readonly logger = new Logger(AuthJwtStrategy.name);
  constructor(private readonly prismaService: PrismaService) {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: JWT_SECRET_KEY,
      ignoreExpiration: false,
      passReqToCallback: true,
    });
  }

  async validate(req: Request, payload: AuthJwtPayloadDTO): Promise<AuthUserDTO> {
    const accessToken = req.headers['authorization'].split(' ')[1];
    const existedToken = await this.prismaService.token.findFirst({
      where: { token: accessToken, type: TokenType.VERIFY },
      select: { id: true },
    });

    if (existedToken) {
      this.logger.warn(`Token ${accessToken} is taken by another account, this token will be revoked`);
      await this.prismaService.token.delete({ where: { id: existedToken.id } });
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID);
    }

    const account = await this.prismaService.account.findUnique({
      where: { id: Number(payload.sub) },
      select: {
        id: true,
        email: true,
        phoneNumber: true,
        accountType: true,
        status: true,
      },
    });

    if (!account) throw new UnauthorizedException('Account not found');
    if (account.status === AccountStatus.SUSPENSIVE) throw new ActionFailedException(ActionFailed.ACCOUNT_SUSPENDED);
    if (account.status !== AccountStatus.ACTIVE) throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_VERIFIED);

    return AuthUserDTO.fromEntity(account as any);
  }
}
</file>

<file path="src/domains/auth/auth-public.decorator.ts">
import { SetMetadata } from '@nestjs/common';

export const IS_PUBLIC_KEY = 'isPublic';
export const Public = () => SetMetadata(IS_PUBLIC_KEY, true);
</file>

<file path="src/domains/auth/auth-role.decorator.ts">
import { SetMetadata } from '@nestjs/common';
import { AccountType } from '@prisma/client';

export const ROLES_KEY = 'roles';
export const Roles = (...roles: AccountType[]) => SetMetadata(ROLES_KEY, roles);
</file>

<file path="src/domains/auth/auth-role.guard.ts">
import { CanActivate, ExecutionContext, Injectable } from '@nestjs/common';
import { Reflector } from '@nestjs/core';

import { IS_PUBLIC_KEY } from './auth-public.decorator';
import { AuthRequestDTO } from './dto/auth-request.dto';
import { AccountType } from '.prisma/client';
import { ROLES_KEY } from './auth-role.decorator';

@Injectable()
export class AuthRoleGuard implements CanActivate {
  constructor(private reflector: Reflector) {}
  canActivate(context: ExecutionContext): boolean {
    const isPublic = this.reflector.getAllAndOverride<boolean>(IS_PUBLIC_KEY, [context.getHandler(), context.getClass()]);
    if (isPublic) return true;

    const requiredRoles = this.reflector.getAllAndOverride<AccountType[]>(ROLES_KEY, [context.getHandler(), context.getClass()]);
    if (!requiredRoles) return true;
    const { user } = context.switchToHttp().getRequest<AuthRequestDTO>();
    return requiredRoles.some((role) => role === user?.accountType);
  }
}
</file>

<file path="src/domains/auth/auth.controller.ts">
import { Body, Controller, Get, HttpCode, HttpStatus, Ip, Logger, Param, Patch, Post, Req } from '@nestjs/common';
import { ApiResponse, ApiTags } from '@nestjs/swagger';

import { BaseResponse } from 'src/shared/generics/base.response';
import { ImageService } from '../image/image.service';
import { AuthService } from './auth.service';
import { AuthLoginDTO } from './dto/auth-login.dto';
import { AuthEmailVerificationREQ } from './request/auth-email-verification.request';
import { AuthFindPasswordResetREQ } from './request/auth-find-password-reset.request';
import { AuthLoginREQ } from './request/auth-login.request';
import { AuthMentorRegisterREQ } from './request/auth-mentor-register.request';
import { AuthRegistrationStudentREQ } from './request/auth-student-register.request';
import { AuthTestAccountREQ } from './request/auth-test-account.request';
import { AuthRegisterRESP } from './response/auth-register.response';

@Controller('auth')
@ApiTags('Auth')
export class AuthController {
  private readonly logger = new Logger(AuthController.name);
  constructor(
    private readonly authService: AuthService,
    private readonly imageService: ImageService,
  ) {}

  @HttpCode(HttpStatus.OK)
  @Post('login')
  @ApiResponse({
    status: HttpStatus.OK,
    description: 'Login successfully',
    type: BaseResponse<AuthLoginDTO>,
    example: {
      data: {
        accessToken:
          'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxIiwiaWF0IjoxNzI1NDczOTg2LCJleHAiOjE3MjgwNjU5ODZ9.Um00Niu0CP6WsaaS4jRjWUKbelFkgqMCP4COBKI-xYk',
        accountType: 'STUDENT',
      },
      message: 'OK',
    },
  })
  async login(@Body() body: AuthLoginREQ, @Ip() ip: string, @Req() req) {
    const ipAddress = req.headers['x-forwarded-for'] || ip;
    return await this.authService.login(AuthLoginDTO.fromRequest(body, ipAddress));
  }

  @Post('students/register')
  @ApiResponse({
    status: HttpStatus.CREATED,
    description: 'Register student successfully',
    type: BaseResponse,
    example: {
      data: 201,
      message: 'OK',
    },
  })
  async registerStudent(@Body() body: AuthRegistrationStudentREQ) {
    const { account, imageId } = await this.authService.registerStudent(body);

    return BaseResponse.of(AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId)));
  }

  @Post('mentors/register')
  async registerMentor(@Body() body: AuthMentorRegisterREQ) {
    const { account, imageId } = await this.authService.registerMentor(body);
    this.logger.log(' ~ AuthController ~ registerMentor ~ imageId:', imageId);

    return BaseResponse.of(AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId)));
  }

  @Patch('verification/:token')
  async verifyEmail(@Param('token') token: string) {
    const { account, jwtToken, imageId } = await this.authService.verifyEmail(token);

    return BaseResponse.of(
      AuthRegisterRESP.fromAccount(account as any, await this.imageService.getImageOriginal(imageId), jwtToken),
    );
  }

  @Get('tokens/:token')
  async verifyToken(@Param('token') token: string) {
    await this.authService.verifyToken(token);

    return BaseResponse.ok();
  }

  @Post('email/forgot-password')
  async sendEmailResetPassword(@Body() body: AuthEmailVerificationREQ) {
    await this.authService.sendEmailForgotPassword(body);

    return BaseResponse.ok();
  }

  @Patch('/reset-password')
  @ApiResponse({ description: 'Reset password successfully' })
  async findPasswordReset(@Body() body: AuthFindPasswordResetREQ) {
    await this.authService.resetPassword(body);

    return BaseResponse.ok();
  }

  @Post('test-accounts')
  async createTestAccount(@Body() body: AuthTestAccountREQ) {
    const account = await this.authService.createTestAccount(body);
    return account;
  }
}
</file>

<file path="src/domains/auth/auth.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { PassportModule } from '@nestjs/passport';
import { JWT_ACCESS_TOKEN_EXPIRE_HOURS, JWT_SECRET_KEY } from 'src/app.config';

import { CommonModule } from 'src/services/common.module';
import { AccountModule } from '../accounts/accounts.module';
import { AuthJwtStrategy } from './auth-jwt.strategy';
import { AuthController } from './auth.controller';
import { AuthService } from './auth.service';

@Module({
  imports: [
    CommonModule,
    PassportModule.register({ defaultStrategy: 'jwt' }),
    JwtModule.register({
      secret: JWT_SECRET_KEY,
      signOptions: { algorithm: 'HS256', expiresIn: JWT_ACCESS_TOKEN_EXPIRE_HOURS },
      verifyOptions: { algorithms: ['HS256'] },
    }),
    AccountModule,
  ],
  controllers: [AuthController],
  providers: [AuthJwtStrategy, AuthService],
  exports: [AuthService],
})
export class AuthModule {}
</file>

<file path="src/domains/auth/auth.service.ts">
import { BadRequestException, Injectable, Logger, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { AccountStatus, AccountType, NotificationRelationType, NotificationType, Token, TokenType } from '@prisma/client';
import { EMAIL_VERIFY_URL } from 'src/app.config';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { PrismaRawService } from 'src/services/prisma/prisma-raw.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { EMAIL_NOTIFICATION, EMAIL_PATH, EMAIL_TEMPLATES } from 'src/shared/constants/notification.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { BaseResponse } from 'src/shared/generics/base.response';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { AccountErrorMessages } from 'src/shared/messages/error-messages';
import { AccountService } from '../accounts/account.service';
import { FileService } from '../file/file.service';
import { ImageService } from '../image/image.service';
import { NotificationHelper } from '../notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel, NotificationEmailPayload } from '../notification/shared/types';
import { AuthJwtPayloadDTO } from './dto/auth-jwt-payload.dto';
import { AuthLoginDTO } from './dto/auth-login.dto';
import { AuthEmailVerificationREQ } from './request/auth-email-verification.request';
import { AuthFindPasswordResetREQ } from './request/auth-find-password-reset.request';
import { AuthMentorRegisterREQ } from './request/auth-mentor-register.request';
import { AuthRegistrationStudentREQ } from './request/auth-student-register.request';
import { AuthTestAccountREQ } from './request/auth-test-account.request';
import { AuthLoginRESP } from './response/auth-login.response';

@Injectable()
export class AuthService {
  private readonly logger = new Logger(AuthService.name);
  constructor(
    private readonly jwtService: JwtService,
    private readonly transactionHost: TransactionHost,
    private readonly prismaRawService: PrismaRawService,
    private readonly accountService: AccountService,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  async login(body: AuthLoginDTO) {
    /* 1. Validate credential */
    try {
      const account = await this.transactionHost.tx.account.findFirstOrThrow(AuthLoginDTO.toFindAccountUnique(body));
      const isMatched = this.accountService.verifyPassword(body.password, account.password);
      if (!isMatched) throw new BadRequestException('Wrong password or username');

      /* 2. Validate login request (SKIP for SUPER_ADMIN) */
      const jwtToken = this.jwtService.sign({
        sub: String(account.id),
      } as AuthJwtPayloadDTO);

      return BaseResponse.of(
        AuthLoginRESP.fromAccount(account as any, jwtToken, await this.imageService.getImageOriginal(account.avatarId)),
      );
    } catch (e) {
      this.logger.error(' ~ AuthService ~ login ~ e:', e);
      throw new UnauthorizedException();
    }
  }

  @Transactional()
  async createTestAccount(body: AuthTestAccountREQ) {
    const account = await this.accountService.createAccount(AuthTestAccountREQ.toAccountDto(body));

    return account;
  }

  async validateEmail(body: AuthEmailVerificationREQ) {
    const account = await this.transactionHost.tx.account.findFirst({ where: { email: body.email } });
    if (account) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, 'Email existed');
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async registerStudent(body: AuthRegistrationStudentREQ) {
    /* 2. Check email duplicate */
    const existedAccount = await this.transactionHost.tx.account.findFirst({
      where: { email: body.email, status: AccountStatus.ACTIVE },
      select: { id: true },
    });

    if (existedAccount) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, AccountErrorMessages.MSG02);

    /* 3. Create account */
    const account = await this.accountService.createAccount(AuthRegistrationStudentREQ.toCreateAccountDto(body));

    await this.transactionHost.tx.student.create(AuthRegistrationStudentREQ.toCreateStudentArgs(body, account.id));
    let imageId: number;
    if (body.fileId) imageId = await this.imageService.linkImageToAccount(account.id, body.fileId);

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    await this.registerTokenVerification(account.id, jwtToken);

    /* 4. Send Email */
    runFunctionWithCondition(!!account, () => {
      this.eventEmitterService.emit<NotificationEmailPayload>(
        NotificationChannel.EMAIL,
        this.createEmailVerificationPayload(
          account.email,
          account.name,
          EMAIL_VERIFY_URL + EMAIL_PATH.EMAIL_VERIFICATION + jwtToken,
        ),
      );
    });

    return { account, imageId };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async registerMentor(body: AuthMentorRegisterREQ) {
    /* 1. Check email duplicate */
    const existedAccount = await this.transactionHost.tx.account.findFirst({
      where: { email: body.email, status: AccountStatus.ACTIVE },
      select: { id: true },
    });

    if (existedAccount) throw new ActionFailedException(ActionFailed.AUTH_EMAIL_EXISTED, AccountErrorMessages.MSG02);

    /* 2. Create mentor account */
    const account = await this.accountService.createAccount(AuthMentorRegisterREQ.toCreateAccountDto(body));

    const mentor = await this.transactionHost.tx.mentor.create(AuthMentorRegisterREQ.toCreateMentorArgs(body, account.id));

    /* 3. Create profile/ achivement */
    if (body.achievements && body.achievements.length > 0) {
      let isOneCurrent = false;

      body.achievements.forEach((achievement) => {
        if (achievement.isCurrent) {
          if (isOneCurrent)
            throw new ActionFailedException(
              ActionFailed.AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED,
              'Current achievement duplicated',
            );
          isOneCurrent = true;
        }
      });

      await this.transactionHost.tx.profileAchievement.createMany(
        AuthMentorRegisterREQ.toCreateMentorProfileArgs(body, mentor.id),
      );
    }

    let imageId: number;
    if (body.avatarId) imageId = await this.imageService.linkImageToAccount(account.id, body.avatarId);

    //TODO: Check file in the format PDF, WORD
    if (body.fileId) await this.linkCVToMentor(mentor.id, body.fileId);

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    await this.registerTokenVerification(account.id, jwtToken);

    //NOTIFICATION: Send notification to admin
    const appPayload = NotificationHelper.makeAppNotificationPayload(
      { id: mentor.id, type: NotificationRelationType.MENTOR },
      admin.id,
      NotificationType.MENTOR_REGISTERD,
    );

    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, appPayload);
      this.eventEmitterService.emit<NotificationEmailPayload>(
        NotificationChannel.EMAIL,
        this.createEmailVerificationPayload(
          account.email,
          account.name,
          EMAIL_VERIFY_URL + EMAIL_PATH.EMAIL_VERIFICATION + jwtToken,
        ),
      );
    });

    return { account, imageId };
  }

  async registerTokenVerification(accountId: number, token: string) {
    await this.transactionHost.tx.token.create({
      data: {
        token: token,
        type: TokenType.VERIFY,
        Account: connectRelation(accountId),
      },
      select: { id: true },
    });
  }

  createEmailVerificationPayload(email: string, name: string, url: string): NotificationEmailPayload {
    return {
      data: {
        email: email,
        ...EMAIL_NOTIFICATION.ACCOUNT_REGISTERED,
      },
      template: {
        path: EMAIL_TEMPLATES.EMAIL_VERIFICATION,
        context: {
          url: url,
          name: name,
        },
      },
    };
  }

  async verifyEmail(token: string) {
    try {
      await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      });
    } catch (e) {
      this.logger.error(' ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    const newAccount = await this.transactionHost.tx.account.update({
      where: { id: this.getAccountIdFromToken(token) },
      data: { status: AccountStatus.ACTIVE },
      select: { id: true, avatarId: true, name: true, email: true, accountType: true, status: true },
    });

    const deletedAccountCondition = { email: newAccount.email, status: AccountStatus.DEACTIVE };

    await this.prismaRawService.profileAchievement.deleteMany({
      where: { Mentor: { Account: deletedAccountCondition } },
    });

    await this.prismaRawService.mentor.deleteMany({
      where: { Account: deletedAccountCondition },
    });

    await this.prismaRawService.student.deleteMany({
      where: { Account: deletedAccountCondition },
    });

    await this.prismaRawService.account.deleteMany({
      where: deletedAccountCondition,
    });

    await this.prismaRawService.token.deleteMany({
      where: {
        OR: [{ accountId: this.getAccountIdFromToken(token) }, { Account: deletedAccountCondition }],
      },
    });

    return { account: newAccount, jwtToken: token, imageId: newAccount.avatarId };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async sendEmailForgotPassword(body: AuthEmailVerificationREQ) {
    let account: any;
    try {
      account = await this.transactionHost.tx.account.findFirstOrThrow({
        where: { email: body.email, status: AccountStatus.ACTIVE },
        select: { id: true, email: true },
      });
    } catch (e) {
      this.logger.error(' ~ AuthService ~ sendEmailResetPassword ~ e:', e);
      throw new ActionFailedException(ActionFailed.ACCOUNT_EMAIL_NOT_FOUND, 'Email not found');
    }

    const jwtToken = this.jwtService.sign({
      sub: String(account.id),
    } as AuthJwtPayloadDTO);

    await this.registerTokenVerification(account.id, jwtToken);

    const emailPayload: NotificationEmailPayload = {
      data: {
        email: account.email,
        ...EMAIL_NOTIFICATION.ACCOUNT_RESET_PASSWORD,
      },
      template: {
        path: EMAIL_TEMPLATES.RESET_PASSWORD,
        context: {
          url: EMAIL_VERIFY_URL + EMAIL_PATH.RESET_PASSWORD + jwtToken,
        },
      },
    };

    this.eventEmitterService.emit<NotificationEmailPayload>(NotificationChannel.EMAIL, emailPayload);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async verifyToken(token: string) {
    let existedToken: Token;
    try {
      existedToken = (await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      })) as Token;
    } catch (e) {
      this.logger.error(' ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    await this.prismaRawService.token.deleteMany({
      where: { AND: [{ id: { not: existedToken.id } }, { accountId: this.getAccountIdFromToken(token) }] },
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resetPassword(body: AuthFindPasswordResetREQ) {
    let token: Token;
    try {
      token = (await this.transactionHost.tx.token.findFirstOrThrow({
        where: { token: body.token, type: TokenType.VERIFY },
        select: { id: true, accountId: true },
      })) as Token;
    } catch (e) {
      this.logger.error(' ~ AuthService ~ verifyEmail ~ e:', e);
      throw new ActionFailedException(ActionFailed.AUTH_TOKEN_INVALID, 'Token invalid');
    }

    await this.accountService.resetPassword(token.accountId, body.password);

    await this.prismaRawService.token.deleteMany({
      where: { accountId: token.accountId },
    });
  }

  getAccountIdFromToken(token: string) {
    if (!token) return null;

    const accountId = this.jwtService.decode(token, { json: true }).sub;

    return Number(accountId);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkCVToMentor(mentorId: number, fileId: number) {
    await this.fileService.checkAttachmentUploadedOrThrow([fileId]);
    await this.fileService.checkFileLinked([fileId]);

    /* Create and link file */
    await this.fileService.enableUploaded([fileId]);
    await this.transactionHost.tx.mentor.update({
      where: { id: mentorId },
      data: { File: connectRelation(fileId) },
      select: { id: true },
    });
  }
}
</file>

<file path="src/domains/category/admin/dto/category-cms-detail.dto.ts">
import { Prisma } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class CategoryCMSDetailDTO {
  static findUnique(id: number): Prisma.CategoryFindUniqueOrThrowArgs {
    return {
      where: { id },
      include: { Courses: { where: IS_ACTIVE_NESTED } },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-create.request.ts">
import { Prisma } from '@prisma/client';
import { IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { generateSlug } from 'src/shared/helpers/category.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { CategoryErrorMessages } from '../../../../shared/messages/error-messages';

export class CategoryAdminCreateREQ {
  @IsString()
  @MaxLength(255)
  name: string;

  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;

  @IsOptional()
  @IdValidator()
  parentCategoryId?: number;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  static toFindMaxOrdinal(parentCategoryId?: number): Prisma.CategoryAggregateArgs {
    return {
      where: parentCategoryId ? { parentCategoryId: parentCategoryId } : { parentCategoryId: { equals: null } },
      _max: { ordinal: true },
    };
  }

  static toCreateInput(body: CategoryAdminCreateREQ, level: number, maxOrdinal: number): Prisma.CategoryCreateInput {
    if (level > MAX_CATEGORY_LEVEL)
      throw new ActionFailedException(ActionFailed.CATEGORY_LEVEL_EXCEED_MAXIMUM, CategoryErrorMessages.MSG01);

    return {
      name: body.name,
      slug: generateSlug(body.name),
      description: body.description,
      ordinal: maxOrdinal + 1,
      level,
      ParentCategory: connectRelation(body.parentCategoryId),
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-list.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CategorySortableFields } from '../../shared/enums';

export class CategoryAdminListREQ extends PaginationREQ {
  @IsOptional()
  @IsString()
  name?: string;

  @IsOptional()
  @IsEnum(CategorySortableFields)
  sortBy?: CategorySortableFields;

  @IsOptional()
  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  static toOrderBy(
    query: CategoryAdminListREQ,
  ): Prisma.CategoryOrderByWithAggregationInput | Prisma.CategoryOrderByWithAggregationInput[] {
    if (!query.sortBy) return [{ level: SortOrder.ASC }, { ordinal: SortOrder.ASC }];
    return { [query.sortBy]: query.sortOrder };
  }

  static toQueryCondition(query: CategoryAdminListREQ) {
    const searchName = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    return {
      ...searchName,
    } as Prisma.CategoryFindManyArgs['where'];
  }

  static toFindMany(query: CategoryAdminListREQ): Prisma.CategoryFindManyArgs {
    const orderBy = this.toOrderBy(query);
    const condition: Prisma.CategoryFindManyArgs['where'] = this.toQueryCondition(query);
    return {
      ...QueryPagingHelper.queryPaging(query),
      where: condition,
      orderBy,
      include: { Courses: { where: IS_ACTIVE_NESTED } },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-reordinal.request.ts">
import { Prisma } from '@prisma/client';
import { Type } from 'class-transformer';
import { IsArray, IsNumber, IsOptional, Min, ValidateNested } from 'class-validator';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class CategoryAdminOrdinalREQ {
  @IdValidator()
  categoryId: number;

  @IsNumber()
  @Min(1)
  ordinal: number;
}

export class CategoryCmsReOrdinalREQ {
  @IsArray()
  @Type(() => CategoryAdminOrdinalREQ)
  @ValidateNested({ each: true })
  categoryOrdinals: CategoryAdminOrdinalREQ[];

  @IsOptional()
  @IdValidator()
  parentCategoryId: number;

  static toFindByOrdinal(categoryIds: number[], ordinal: number, parentCategoryId?: number): Prisma.CategoryFindFirstArgs {
    const isRearrangeParent = Boolean(parentCategoryId);

    return {
      where: {
        id: { notIn: categoryIds },
        ordinal: ordinal,
        ...(isRearrangeParent ? { level: 1 } : { parentCategoryId: parentCategoryId }),
      },
      select: { id: true },
    };
  }

  static toFindBySubCategoryOrdinal(
    categoryIds: number[],
    ordinal: number,
    parentCategoryId: number,
  ): Prisma.CategoryFindFirstArgs {
    return {
      where: { id: { notIn: categoryIds }, ordinal: ordinal, parentCategoryId: parentCategoryId },
      select: { id: true },
    };
  }

  static validateOrdinal(body: CategoryCmsReOrdinalREQ) {
    const ordinals = body.categoryOrdinals.map(({ ordinal }) => ordinal);

    const hasDuplicates = ordinals.length !== new Set(ordinals).size;
    if (hasDuplicates) throw new ActionFailedException(ActionFailed.CATEGORY_ORDINAL_OVERLAP, CategoryErrorMessages.MSG03);
  }

  static toUpdateOrdinal(body: CategoryAdminOrdinalREQ): Prisma.CategoryUpdateArgs {
    return {
      where: { id: body.categoryId },
      data: { ordinal: body.ordinal },
    };
  }
}
</file>

<file path="src/domains/category/admin/request/category-admin-update.request.ts">
import { Prisma } from '@prisma/client';
import { IsBoolean, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { isNull } from 'lodash';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { generateSlug } from 'src/shared/helpers/category.helper';
import { connectRelation, removeRelation } from 'src/shared/helpers/prisma.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class CategoryAdminUpdateREQ {
  @IsOptional()
  @IsString()
  @MaxLength(255)
  name?: string;

  @IsOptional()
  @IsString()
  @MaxLength(1000)
  description?: string;

  @IsOptional()
  @IdValidator()
  parentCategoryId?: number;

  @IsOptional()
  @IsNumber()
  fileId?: number;

  @IsBoolean()
  @IsOptional()
  isRecommended?: boolean;

  static toUpdateInput(body: CategoryAdminUpdateREQ, level: number): Prisma.CategoryUpdateInput {
    if (level > MAX_CATEGORY_LEVEL)
      throw new ActionFailedException(ActionFailed.CATEGORY_LEVEL_EXCEED_MAXIMUM, CategoryErrorMessages.MSG01);

    return {
      name: body.name,
      slug: generateSlug(body.name),
      description: body.description,
      level,
      ParentCategory: isNull(body.parentCategoryId) ? removeRelation() : connectRelation(body.parentCategoryId),
      isRecommended: body.isRecommended,
    };
  }
}
</file>

<file path="src/domains/category/admin/response/category-admin-detail.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryAdminDetailRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  noOfProduct: number;
  isRecommended: boolean;
  level: number;
  ordinal: number;
  thumbnail: ImageRESP;
  parentCategoryId: number | null;
  childCategories: CategoryAdminDetailRESP[];

  private constructor(e: CategoryGetPayload, thumbnail?: ImageRESP) {
    this.id = e.id;
    this.name = e.name;
    this.slug = e.slug;
    this.description = e.description;
    this.noOfProduct = e.Courses?.length || 0;
    this.level = e.level;
    this.ordinal = e.ordinal;
    this.isRecommended = e.isRecommended;
    this.thumbnail = thumbnail;
    this.parentCategoryId = e.parentCategoryId;
    this.childCategories = [];
  }

  static fromEntity(e: CategoryGetPayload, thumbnail?: ImageRESP): CategoryAdminDetailRESP {
    return new CategoryAdminDetailRESP(e, thumbnail);
  }

  addChildCategory(child: CategoryAdminDetailRESP) {
    this.childCategories.push(child);
  }
}
</file>

<file path="src/domains/category/admin/response/category-admin-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryAdminListRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  level: number;
  ordinal: number;
  thumbnail: ImageRESP;
  createdAt: string;
  noOfCourse: number;
  parentCategoryId: number | null;
  childCategories: CategoryAdminListRESP[] = [];

  static fromEntity(e: CategoryGetPayload, noOfCourse: number, thumbnail?: ImageRESP): CategoryAdminListRESP {
    return {
      id: e.id,
      name: e.name,
      slug: e.slug,
      description: e.description,
      level: e.level,
      ordinal: e.ordinal,
      thumbnail: thumbnail,
      noOfCourse: noOfCourse || 0,
      createdAt: parseEpoch(e.createdAt),
      parentCategoryId: e.parentCategoryId,
      childCategories: [],
    };
  }

  static addChildCategory(child: CategoryAdminListRESP) {
    const childCategories: CategoryAdminListRESP[] = [];
    childCategories.push(child);
    return childCategories;
  }
}
</file>

<file path="src/domains/category/admin/category-admin.controller.ts">
import {
  Body,
  Controller,
  Delete,
  Get,
  HttpCode,
  HttpStatus,
  Param,
  ParseIntPipe,
  Patch,
  Post,
  Query,
  UseGuards,
} from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { CategoryAdminService } from './category-admin.service';
import { CategoryAdminCreateREQ } from './request/category-admin-create.request';
import { CategoryAdminListREQ } from './request/category-admin-list.request';
import { CategoryCmsReOrdinalREQ } from './request/category-admin-reordinal.request';
import { CategoryAdminUpdateREQ } from './request/category-admin-update.request';

@Controller('admin/categories')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class CategoryAdminController {
  constructor(private readonly categoryService: CategoryAdminService) {}

  @Get()
  async list(@Query() query: CategoryAdminListREQ) {
    return await this.categoryService.list(query);
  }

  @HttpCode(HttpStatus.CREATED)
  @Post()
  async create(@Body() body: CategoryAdminCreateREQ) {
    const category = await this.categoryService.create(body);
    return BaseResponse.of(category.id);
  }

  @Patch(':id')
  async update(@Param('id', ParseIntPipe) id: number, @Body() body: CategoryAdminUpdateREQ) {
    const category = await this.categoryService.update(id, body);
    return BaseResponse.of(category.id);
  }

  @Delete(':id')
  async deleteCategory(@Param('id', ParseIntPipe) id: number) {
    const category = await this.categoryService.delete(id);

    return BaseResponse.of(category.id);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const category = await this.categoryService.detail(id);

    return BaseResponse.of(category);
  }

  @Patch('re-ordinal')
  async rearrangeOrdinal(@Body() body: CategoryCmsReOrdinalREQ) {
    await this.categoryService.rearrangeOrdinal(body);
  }
}
</file>

<file path="src/domains/category/admin/category-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus, Prisma, PrismaClient } from '@prisma/client';

import { isUndefined } from 'lodash';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { CategoryGetPayload } from '../shared/types';
import { CategoryCMSDetailDTO } from './dto/category-cms-detail.dto';
import { CategoryAdminCreateREQ } from './request/category-admin-create.request';
import { CategoryAdminListREQ } from './request/category-admin-list.request';
import { CategoryCmsReOrdinalREQ } from './request/category-admin-reordinal.request';
import { CategoryAdminUpdateREQ } from './request/category-admin-update.request';
import { CategoryAdminDetailRESP } from './response/category-admin-detail.response';
import { CategoryAdminListRESP } from './response/category-admin-list.response';

@Injectable()
export class CategoryAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async findCategoryLevel(categoryParentId?: number) {
    if (!categoryParentId) return 1;
    const parent = await this.transactionHost.tx.category.findUniqueOrThrow({
      where: { id: categoryParentId },
      select: { level: true },
    });
    return parent.level + 1;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkImageToCategory(categoryId: number, fileId: number) {
    //   /* 1. Remove old image */
    const category = await this.transactionHost.tx.category.findUniqueOrThrow({
      where: { id: categoryId },
      select: { Image: { select: { id: true } } },
    });
    if (category.Image) await this.imageService.deleteImage(category.Image.id);

    //   /* 2. Create and link image */
    await this.transactionHost.tx.category.update({
      where: { id: categoryId },
      data: { Image: connectRelation(fileId) },
    });

    /* 3. Enable Image & File */
    await this.imageService.enableImages([fileId]);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(body: CategoryAdminCreateREQ) {
    /* 1. Check if attachment uploaded & create image */
    if (body.fileId) await this.imageService.verifyImages([body.fileId]);

    const level = await this.findCategoryLevel(body.parentCategoryId);
    const ordinal = await this.transactionHost.tx.category.aggregate(
      CategoryAdminCreateREQ.toFindMaxOrdinal(body.parentCategoryId),
    );

    const maxOrdinal = ordinal._max.ordinal || 0;
    /* 2. Create and link image */
    const category = await this.transactionHost.tx.category.create({
      data: CategoryAdminCreateREQ.toCreateInput(body, level, maxOrdinal),
      select: { id: true },
    });

    if (body.fileId) await this.linkImageToCategory(category.id, body.fileId);

    return category;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(id: number, body: CategoryAdminUpdateREQ) {
    /* 1. Check if attachment uploaded & create image */
    // if (body.fileId) await this.imageService.verifyImages([body.fileId]);

    const category = await this.transactionHost.tx.category.findUniqueOrThrow({ where: { id } });
    const parentCategoryId = isUndefined(body.parentCategoryId) ? category.parentCategoryId : body.parentCategoryId;
    const level = await this.findCategoryLevel(parentCategoryId);

    /* 2. Update and link image */
    const updatedCategory = await this.transactionHost.tx.category.update({
      where: { id },
      data: CategoryAdminUpdateREQ.toUpdateInput(body, level),
      select: { id: true },
    });

    // if (body.fileId) await this.linkImageToCategory(category.id, body.fileId, tx);

    return updatedCategory;
  }

  async list(query: CategoryAdminListREQ) {
    const condition = CategoryAdminListREQ.toQueryCondition(query);
    const count = await this.transactionHost.tx.category.count({ where: condition });
    const categories = await this.transactionHost.tx.category.findMany(CategoryAdminListREQ.toFindMany(query));
    const cateResponses = await Promise.all(
      categories.map(async (c: CategoryGetPayload) => {
        const noOfCourses = await this.transactionHost.tx.course.count({
          where: { categoryId: c.id, isPublic: true, status: CourseStatus.APPROVED },
        });

        return CategoryAdminListRESP.fromEntity(c, noOfCourses, await this.imageService.getImageOriginal(c.imageId));
      }),
    );

    cateResponses.forEach((r) => {
      if (r.parentCategoryId) {
        const parent = cateResponses.find((c) => c.id === r.parentCategoryId);
        parent.childCategories.push(r);
      }
    });

    const parentCateResponses = cateResponses.filter((r) => r.parentCategoryId === null);
    return PaginationResponse.ofWithTotal<CategoryAdminListRESP>(parentCateResponses, count);
  }

  async detail(id: number) {
    const category = (await this.transactionHost.tx.category.findUniqueOrThrow(
      CategoryCMSDetailDTO.findUnique(id),
    )) as CategoryGetPayload;
    const childCategories = await this.transactionHost.tx.category.findMany({ where: { parentCategoryId: id } });
    const childCateResponses = await Promise.all(
      childCategories.map(async (c: CategoryGetPayload) =>
        CategoryAdminDetailRESP.fromEntity(c, await this.imageService.getImageOriginal(c.imageId)),
      ),
    );

    const cateResponse = CategoryAdminDetailRESP.fromEntity(category);
    cateResponse.childCategories = childCateResponses;
    return cateResponse;
  }

  async delete(id: number) {
    const category = await this.transactionHost.tx.category.findUniqueOrThrow({ where: { id }, select: { id: true } });
    const childCategories = await this.transactionHost.tx.category.findMany({ where: { parentCategoryId: id } });

    if (childCategories.length > 0)
      throw new ActionFailedException(ActionFailed.CATEGORY_PARENT_DELETE_FAILED, CategoryErrorMessages.MSG04);

    /* Delete parent & children categories */
    const categoryIds = [category.id, ...childCategories.map((c) => c.id)];
    await this.transactionHost.tx.$executeRaw`DELETE FROM categories WHERE id IN (${Prisma.join(categoryIds)})`;
    return category;
  }

  private async validateExistedOrdinal(body: CategoryCmsReOrdinalREQ) {
    const rearrangedCategoryIds = body.categoryOrdinals.map(({ categoryId }) => categoryId);

    for (const category of body.categoryOrdinals) {
      const existedCategory = await this.transactionHost.tx.category.findFirst(
        CategoryCmsReOrdinalREQ.toFindByOrdinal(rearrangedCategoryIds, category.ordinal, body.parentCategoryId),
      );

      if (existedCategory)
        throw new ActionFailedException(
          ActionFailed.CATEGORY_ORDINAL_OVERLAP,
          `Ordinal number ${category.ordinal} already existed with banner ${existedCategory.id}`,
        );
    }
  }

  async rearrangeOrdinal(body: CategoryCmsReOrdinalREQ) {
    CategoryCmsReOrdinalREQ.validateOrdinal(body);
    await this.validateExistedOrdinal(body);

    await this.transactionHost.tx.$transaction(async (tx: PrismaClient) => {
      for (const category of body.categoryOrdinals) {
        await tx.category.update(CategoryCmsReOrdinalREQ.toUpdateOrdinal(category));
      }
    });
  }
}
</file>

<file path="src/domains/category/client/dto/category-client-statistics.dto.ts">
import { CourseStatus, Prisma } from '@prisma/client';
import { CATEGORY_DEFAULT_LEVEL } from 'src/shared/constants/category.constant';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

type CategoryClientStatisticsCountProduct = {
  _count: {
    Products: number;
  };
};

export type CategoryClientStatisticsCountPayload = Prisma.CategoryGetPayload<{
  include: { ChildrenCategories: true };
}> &
  CategoryClientStatisticsCountProduct;

export class CategoryClientStatisticsDTO {
  static toFindMany(): Prisma.CategoryFindManyArgs {
    return {
      where: { level: CATEGORY_DEFAULT_LEVEL },
      select: {
        id: true,
        name: true,
        level: true,
        ChildrenCategories: {
          select: {
            id: true,
            name: true,
            level: true,
            _count: {
              select: { Courses: { where: { status: CourseStatus.APPROVED, ...IS_ACTIVE_NESTED } } },
            },
          },
          where: IS_ACTIVE_NESTED,
        },
      },
    };
  }
}
</file>

<file path="src/domains/category/client/request/category-client-list.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { MAX_CATEGORY_LEVEL } from 'src/shared/constants/category.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { leanObject } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { CategorySortableFields } from '../../shared/enums';

export class CategoryClientListREQ extends PaginationREQ {
  @BooleanValidator()
  @IsOptional()
  isRecommended: boolean;

  @IsOptional()
  @IsEnum(CategorySortableFields)
  sortBy?: CategorySortableFields;

  @IsOptional()
  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  static toQueryCondition(query: CategoryClientListREQ): Prisma.CategoryWhereInput {
    const recommendedCategoryFiltered = orUndefinedWithCondition(query.isRecommended, {
      level: MAX_CATEGORY_LEVEL,
      isRecommended: true,
    });
    return leanObject({ ...recommendedCategoryFiltered });
  }

  static toOrderBy(
    query: CategoryClientListREQ,
  ): Prisma.CategoryOrderByWithRelationInput | Prisma.CategoryOrderByWithRelationInput[] {
    if (!query.sortBy) return [{ level: SortOrder.ASC }, { ordinal: SortOrder.ASC }];
    return { [query.sortBy]: query.sortOrder };
  }

  static toFindMany(query: CategoryClientListREQ): Prisma.CategoryFindManyArgs {
    const orderBy = this.toOrderBy(query);
    const condition = this.toQueryCondition(query);
    return {
      where: condition,
      include: { Courses: true },
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
    };
  }
}
</file>

<file path="src/domains/category/client/request/category-client-select-interested-choice.request.ts">
import { ArrayMinSize, IsNumber } from 'class-validator';

export class CategoryClientSelectInterestedChoiceREQ {
  @IsNumber({}, { each: true })
  @ArrayMinSize(1)
  categoryIds?: number[] = [];
}
</file>

<file path="src/domains/category/client/response/category-client-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { CategoryGetPayload } from '../../shared/types';

export class CategoryClientListRESP {
  id: number;
  name: string;
  slug: string;
  description: string;
  thumbnail: ImageRESP;
  noOfCourses: number;
  createdAt: string;
  parentCategoryId: number | null;
  childCategories: CategoryClientListRESP[];

  private constructor(e: CategoryGetPayload, noOfCourses?: number, thumbnail?: ImageRESP) {
    this.id = e.id;
    this.name = e.name;
    this.slug = e.slug;
    this.description = e.description;
    this.thumbnail = thumbnail;
    this.parentCategoryId = e.parentCategoryId;
    this.noOfCourses = noOfCourses || 0;
    this.createdAt = parseEpoch(e.createdAt);
    this.childCategories = [];
  }

  static fromEntity(e: CategoryGetPayload, noOfCourses?: number, thumbnail?: ImageRESP): CategoryClientListRESP {
    return new CategoryClientListRESP(e, noOfCourses, thumbnail);
  }

  addChildCategory(child: CategoryClientListRESP) {
    this.childCategories.push(child);
  }
}
</file>

<file path="src/domains/category/client/response/category-client-statistics.response.ts">
import { CategoryClientStatisticsCountPayload } from '../dto/category-client-statistics.dto';

export class CategoryClientStatisticsRESP {
  id: number;
  name: string;
  level: number;
  noOfProducts?: number;
  childrenCategories: Partial<CategoryClientStatisticsRESP>[];

  static fromEntity(e: CategoryClientStatisticsCountPayload): CategoryClientStatisticsRESP {
    return {
      id: e.id,
      name: e.name,
      level: e.level,
      childrenCategories: e.ChildrenCategories.map((category: CategoryClientStatisticsCountPayload) => ({
        id: category.id,
        name: category.name,
        level: category.level,
        noOfProducts: category._count.Products,
      })),
    };
  }
}
</file>

<file path="src/domains/category/client/category-client.controller.ts">
import { Body, Controller, Get, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { CategoryClientService } from './category-client.service';
import { CategoryClientListREQ } from './request/category-client-list.request';
import { CategoryClientSelectInterestedChoiceREQ } from './request/category-client-select-interested-choice.request';

@Controller('client/categories')
@UseGuards(AuthJwtGuard)
export class CategoryClientController {
  constructor(private readonly categoryEcmService: CategoryClientService) {}

  @Get()
  @Public()
  async list(@Query() query: CategoryClientListREQ) {
    return await this.categoryEcmService.list(query);
  }

  @Patch('update-ordinal')
  async updateCategoryOrdinal() {
    await this.categoryEcmService.updateCategoryOrdinal();
  }

  @Post('students')
  async chooseInterestedCategories(@Req() req: AuthRequestDTO, @Body() body: CategoryClientSelectInterestedChoiceREQ) {
    await this.categoryEcmService.chooseInterestedCategories(req.user, body);
    return BaseResponse.ok();
  }

  @Get('statistics')
  async statistics() {
    return await this.categoryEcmService.statistics();
  }
}
</file>

<file path="src/domains/category/client/category-client.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus } from '@prisma/client';
import { isEmpty } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { CategoryErrorMessages } from 'src/shared/messages/error-messages';
import { CategoryGetPayload } from '../shared/types';
import { CategoryClientStatisticsDTO } from './dto/category-client-statistics.dto';
import { CategoryClientListREQ } from './request/category-client-list.request';
import { CategoryClientSelectInterestedChoiceREQ } from './request/category-client-select-interested-choice.request';
import { CategoryClientListRESP } from './response/category-client-list.response';
import { CategoryClientStatisticsRESP } from './response/category-client-statistics.response';

@Injectable()
export class CategoryClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  async statistics() {
    const categories = await this.transactionHost.tx.category.findMany(CategoryClientStatisticsDTO.toFindMany());
    return PaginationResponse.of(categories.map(CategoryClientStatisticsRESP.fromEntity));
  }

  async list(query: CategoryClientListREQ) {
    const condition = CategoryClientListREQ.toQueryCondition(query);
    const count = await this.transactionHost.tx.category.count({ where: condition });
    const categories = await this.transactionHost.tx.category.findMany(CategoryClientListREQ.toFindMany(query));
    const cateResponses = await Promise.all(
      categories.map(async (c: CategoryGetPayload) => {
        const noOfCourses = await this.transactionHost.tx.course.count({
          where: { categoryId: c.id, isPublic: true, status: CourseStatus.APPROVED },
        });

        return CategoryClientListRESP.fromEntity(c, noOfCourses, await this.imageService.getImageOriginal(c.imageId));
      }),
    );
    // if just getting category, should return list of sub category
    if (query.isRecommended) return PaginationResponse.ofWithTotal<CategoryClientListRESP>(cateResponses, count);

    cateResponses.forEach((r) => {
      const parent = cateResponses.find((c) => c.id === r.parentCategoryId);
      if (parent) parent.addChildCategory(r);
    });
    const parentCateResponses = cateResponses.filter((r) => r.parentCategoryId === null);
    return PaginationResponse.ofWithTotal<CategoryClientListRESP>(parentCateResponses, count);
  }

  async chooseInterestedCategories(user: AuthUserDTO, body: CategoryClientSelectInterestedChoiceREQ) {
    await this.validateCategories(body);
    await this.transactionHost.tx.userInterestedCategory.createMany({
      data: body.categoryIds.map((categoryId) =>
        addCreationTimestamps({
          userId: user.accountId,
          categoryId: categoryId,
        }),
      ),
      skipDuplicates: true,
    });
  }

  async validateCategories(body: CategoryClientSelectInterestedChoiceREQ) {
    if (!body.categoryIds || isEmpty(body.categoryIds)) return;
    const categories = await this.transactionHost.tx.category.findMany({ where: { id: { in: body.categoryIds } } });
    if (categories.length !== body.categoryIds.length)
      throw new ActionFailedException(ActionFailed.CATEGORY_NOT_FOUND, CategoryErrorMessages.MSG05);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateCategoryOrdinal() {
    const parentCategories = await this.transactionHost.tx.category.findMany({ where: { level: 1 }, select: { id: true } });
    const parentIds = parentCategories.map((cate) => cate.id);

    for (const [index, parentId] of parentIds.entries()) {
      await this.transactionHost.tx.category.update({
        where: { id: parentId },
        data: { ordinal: index + 1 },
      });
      const childrenCategories = await this.transactionHost.tx.category.findMany({
        where: { parentCategoryId: parentId },
        select: { id: true },
      });
      for (const [index, child] of childrenCategories.entries()) {
        await this.transactionHost.tx.category.update({
          where: { id: child.id },
          data: { ordinal: index + 1 },
        });
      }
    }
  }
}
</file>

<file path="src/domains/category/shared/enums.ts">
export enum CategorySortableFields {
  ID = 'id',
  NAME = 'name',
  CREATED_AT = 'createdAt',
}
</file>

<file path="src/domains/category/shared/types.ts">
import { Prisma } from '@prisma/client';

export type CategoryGetPayload = Prisma.CategoryGetPayload<{ include: { Courses: true } }>;
</file>

<file path="src/domains/category/category.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { CategoryAdminController } from './admin/category-admin.controller';
import { CategoryAdminService } from './admin/category-admin.service';
import { CategoryClientController } from './client/category-client.controller';
import { CategoryClientService } from './client/category-client.service';

@Module({
  imports: [CommonModule],
  controllers: [CategoryAdminController, CategoryClientController],
  providers: [CategoryAdminService, CategoryClientService],
})
export class CategoryModule {}
</file>

<file path="src/domains/chat-message/helper/chat-room-create.helper.ts">
import { ChatRoomType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { NUMBER_OF_MESSAGE_DEFAULT } from 'src/shared/constants/chat-message.constant';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

export class ChatRoomCreateHelper {
  static toCreateInput(user: AuthUserDTO, receiverId: number): Prisma.ChatRoomCreateArgs {
    const participants = [
      addCreationTimestamps({ participantId: user.accountId }),
      addCreationTimestamps({ participantId: receiverId }),
    ];

    return {
      data: {
        numberOfMessages: NUMBER_OF_MESSAGE_DEFAULT,
        numberOfParticipants: participants.length,
        chatRoomType: ChatRoomType.PRIVATE,
        ChatParticipants: { createMany: { data: participants } },
      },
      select: {
        id: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }

  static toFindFirst(user: AuthUserDTO, receiverId: number): Prisma.ChatRoomFindFirstArgs {
    return {
      where: {
        chatRoomType: ChatRoomType.PRIVATE,
        ChatParticipants: {
          every: { participantId: { in: [user.accountId, receiverId] } },
        },
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-detail.helper.ts">
import { Prisma } from '@prisma/client';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortAsc } from 'src/shared/helpers/query.helper';
import { ChatRoomDetailREQ } from '../request/chat-room-detail.request';

export class ChatRoomDetailHelper {
  static toFindUnique(roomId: number): Prisma.ChatRoomFindUniqueArgs {
    return {
      where: { id: roomId },
      select: {
        id: true,
        chatRoomType: true,
        numberOfMessages: true,
        numberOfParticipants: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }

  static toFindManyMessages(roomId: number, body: ChatRoomDetailREQ): Prisma.ChatMessageFindManyArgs {
    return {
      where: { chatRoomId: roomId },
      ...QueryPagingHelper.queryPaging(body),
      orderBy: defaultSortAsc,
      select: {
        id: true,
        Sender: { select: { id: true, accountType: true } },
        message: true,
        isRead: true,
        chatRoomId: true,
        updatedAt: true,
        createdAt: true,
        readAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-list-helper.ts">
import { AccountType, ChatRoomType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { SortOrder } from 'src/shared/enums/query.enum';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { ChatRoomListREQ } from '../request/chat-room-list.request';

export class ChatRoomListHelper {
  static toFilterByAccountType(user: AuthUserDTO): Prisma.ChatRoomWhereInput {
    switch (user.accountType) {
      case AccountType.MENTOR:
      case AccountType.STUDENT:
        return {
          ChatParticipants: {
            some: { participantId: user.accountId },
          },
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACCOUNT_FORBIDDEN);
    }
  }

  static toQueryCondition(user: AuthUserDTO, query: ChatRoomListREQ): Prisma.ChatRoomWhereInput {
    const receiverName = orUndefinedWithCondition(!!query.receiverName, {
      Creator: { Buyer: parsePrismaSearch('name', query.receiverName) },
    });

    const chatRoomType = orUndefinedWithCondition(!!query.chatRoomType, { chatRoomType: query.chatRoomType });
    const toFilterByAccountType = this.toFilterByAccountType(user);

    return leanObject({ ...toFilterByAccountType, ...receiverName, ...chatRoomType });
  }

  static findMany(user: AuthUserDTO): Prisma.ChatRoomFindManyArgs {
    return {
      where: this.toFilterByAccountType(user),
      select: { id: true },
    };
  }
  static toFindManyPrivateRoom(user: AuthUserDTO, query: ChatRoomListREQ): Prisma.ChatRoomFindManyArgs {
    const condition = this.toQueryCondition(user, query);

    return {
      where: { ...condition, chatRoomType: ChatRoomType.PRIVATE },
      orderBy: { lastMessageId: SortOrder.DESC },
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        lastMessageId: true,
        numberOfMessages: true,
        numberOfParticipants: true,
        chatRoomType: true,
        ChatParticipants: { select: { participantId: true } },
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/helper/chat-room-read-message.helper.ts">
import { WsException } from '@nestjs/websockets';
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { ChatRoomReadMessageREQ } from '../request/chat-room-read-message.request';

export class ChatRoomReadMessageHelper {
  static toFilterAccountReadMessage(user: AuthUserDTO, body: ChatRoomReadMessageREQ): Prisma.ChatMessageUpdateManyArgs['where'] {
    if (!body.chatRoomId) throw new WsException('Conversation ID is required');

    return {
      chatRoomId: body.chatRoomId,
      Sender: { id: { not: user.accountId } },
    };
  }

  static toUpdateInput(user: AuthUserDTO, body: ChatRoomReadMessageREQ): Prisma.ChatMessageUpdateManyArgs {
    const filterAccount = this.toFilterAccountReadMessage(user, body);
    return {
      where: {
        ...filterAccount,
        isRead: false,
      },
      data: { isRead: true, readAt: nowEpoch() },
    };
  }
}
</file>

<file path="src/domains/chat-message/request/chat-message-create.request.ts">
import { ChatMessageType, Prisma } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class ChatMessageCreateREQ {
  @IsString()
  @IsNotEmpty()
  message: string;

  @IsEnum(ChatMessageType)
  type: ChatMessageType;

  @IdValidator()
  receiverId: number;

  static toCreateInput(user: AuthUserDTO, chatRoomId: number, body: ChatMessageCreateREQ): Prisma.ChatMessageCreateArgs {
    return {
      data: {
        message: body.message,
        Sender: connectRelation(user.accountId),
        type: body.type,
        ChatRoom: connectRelation(chatRoomId),
      },
      select: {
        id: true,
        message: true,
        isRead: true,
        createdAt: true,
        chatRoomId: true,
        Sender: { select: { id: true, name: true } },
      },
    };
  }
}
</file>

<file path="src/domains/chat-message/request/chat-room-create.request.ts">
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class ChatRoomCreateREQ {
  @IdValidator()
  receiverId: number;
}
</file>

<file path="src/domains/chat-message/request/chat-room-detail.request.ts">
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ChatRoomDetailREQ extends PaginationREQ {}
</file>

<file path="src/domains/chat-message/request/chat-room-list.request.ts">
import { ChatRoomType } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ChatRoomListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  receiverName?: string;

  @IsOptional()
  @IsEnum(ChatRoomType)
  chatRoomType?: ChatRoomType;
}
</file>

<file path="src/domains/chat-message/request/chat-room-read-message.request.ts">
import { IsNumber } from 'class-validator';

export class ChatRoomReadMessageREQ {
  @IsNumber()
  chatRoomId: number;
}
</file>

<file path="src/domains/chat-message/response/chat-room-detail.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload, ChatRoomGetPayload, ChatRoomReceiverRESP } from '../shared/types';

export class ChatMessageDetailRESP {
  id: number;
  content: string;
  senderId: number;
  isReceiver: boolean;
  isRead: boolean;
  createdAt: Date;
  readAt: Date;
  chatRoomId: number;

  static fromEntity(e: ChatMessageGetPayload, isReceiver: boolean): ChatMessageDetailRESP {
    return {
      id: e.id,
      content: e.message,
      senderId: e.Sender.id,
      isReceiver: isReceiver,
      createdAt: parseEpoch(e.createdAt),
      readAt: parseEpoch(e.readAt),
      chatRoomId: e.chatRoomId,
      isRead: e.isRead,
    };
  }
}

export class ChatRoomDetailRESP {
  id: number;
  receiver: ChatRoomReceiverRESP;
  noOfMessages: number;
  messages: ChatMessageDetailRESP[];

  static fromEntity(
    chatRoom: ChatRoomGetPayload,
    messages: ChatMessageDetailRESP[],
    receiver: ChatRoomReceiverRESP,
  ): ChatRoomDetailRESP {
    return {
      id: chatRoom.id,
      receiver: receiver,
      noOfMessages: chatRoom.numberOfMessages,
      messages: messages,
    };
  }
}
</file>

<file path="src/domains/chat-message/response/chat-room-list.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload, ChatRoomGetPayload, ChatRoomReceiverRESP } from '../shared/types';

export class ChatRoomListRESP {
  id: number;
  receiver: ChatRoomReceiverRESP;
  isSeen: boolean;
  lastMessage: {
    isReceiver: boolean;
    content: string;
  };
  lastMessageAt: string;
  numOfUnreadMessage: number;

  static fromEntity(
    entity: ChatRoomGetPayload,
    lastMessage: ChatMessageGetPayload,
    numOfUnreadMessage: number,
    receiver: ChatRoomReceiverRESP,
  ): ChatRoomListRESP {
    return {
      id: entity.id,
      numOfUnreadMessage: numOfUnreadMessage,
      lastMessage: {
        isReceiver: lastMessage && lastMessage.senderId === receiver.id,
        content: lastMessage && lastMessage.message,
      },
      lastMessageAt: lastMessage && parseEpoch(lastMessage.createdAt),
      isSeen: numOfUnreadMessage === 0,
      receiver: receiver,
    };
  }
}
</file>

<file path="src/domains/chat-message/response/message-chat-create.response.ts">
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { ChatMessageGetPayload } from '../shared/types';

export class ChatMessageCreateRESP {
  id: number;
  content: string;
  senderId: number;
  isRead: boolean;
  createdAt: Date;
  name: string;
  chatRoomId: number;

  static fromEntity(e: ChatMessageGetPayload): ChatMessageCreateRESP {
    return {
      id: e.id,
      content: e.message,
      senderId: e.Sender?.id,
      name: e.Sender?.name,
      createdAt: parseEpoch(e.createdAt),
      chatRoomId: e.chatRoomId,
      isRead: e.isRead,
    };
  }
}
</file>

<file path="src/domains/chat-message/shared/types.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';

export type ChatMessageGetPayload = Prisma.ChatMessageGetPayload<{ include: { Sender: true; ChatRoom: true } }>;

export type ChatRoomGetPayload = Prisma.ChatRoomGetPayload<{ include: { ChatMessages: true; ChatParticipants: true } }>;

export type ChatRoomReceiverRESP = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;
</file>

<file path="src/domains/chat-message/chat-message.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ChatMessageController } from './chat-message.controller';
import { ChatMessageService } from './chat-message.service';

describe('ChatMessageController', () => {
  let controller: ChatMessageController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ChatMessageController],
      providers: [ChatMessageService],
    }).compile();

    controller = module.get<ChatMessageController>(ChatMessageController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/chat-message/chat-message.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { ChatMessageService } from './chat-message.service';
import { ChatRoomDetailREQ } from './request/chat-room-detail.request';
import { ChatRoomListREQ } from './request/chat-room-list.request';

@Controller('chat-messages')
@UseGuards(AuthJwtGuard)
export class ChatMessageController {
  constructor(private readonly chatMessageService: ChatMessageService) {}

  @Get('rooms')
  async findAll(@Req() req: AuthRequestDTO, @Query() query: ChatRoomListREQ) {
    const { chatRoomDtos, count } = await this.chatMessageService.findAll(req.user, query);

    return PaginationResponse.ofWithTotal(chatRoomDtos, count);
  }

  @Get('rooms/:roomId')
  async detail(@Req() req: AuthRequestDTO, @Param('roomId', ParseIntPipe) roomId: number, @Query() query: ChatRoomDetailREQ) {
    const response = await this.chatMessageService.getAllMessagesByRoomId(req.user, roomId, query);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/chat-message/chat-message.gateway.ts">
import { Logger, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import {
  ConnectedSocket,
  MessageBody,
  OnGatewayConnection,
  OnGatewayDisconnect,
  OnGatewayInit,
  SubscribeMessage,
  WebSocketGateway,
  WebSocketServer,
  WsException,
} from '@nestjs/websockets';
import { Namespace, Socket } from 'socket.io';
import { AuthSocket, SocketAuthMiddleware } from 'src/middlewares/socket-auth.middleware';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { SOCKET_CHAT_MESSAGE_EVENT } from 'src/shared/constants/chat-message.constant';
import { BaseResponse } from 'src/shared/generics/base.response';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { parseRoomChatId } from 'src/shared/parsers/io.parser';
import { AuthJwtPayloadDTO } from '../auth/dto/auth-jwt-payload.dto';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ChatMessageService } from './chat-message.service';
import { ChatRoomListHelper } from './helper/chat-room-list-helper';
import { ChatMessageCreateREQ } from './request/chat-message-create.request';
import { ChatRoomCreateREQ } from './request/chat-room-create.request';
import { ChatRoomReadMessageREQ } from './request/chat-room-read-message.request';

@WebSocketGateway({
  namespace: 'message-chat',
  cors: {
    credentials: true,
    origin: ['http://localhost:3000', 'https://bksharing.social', 'https://www.bksharing.social'],
  },
})
export class ChatMessageGateway implements OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect {
  private readonly logger = new Logger(ChatMessageGateway.name);
  constructor(
    private readonly jwtService: JwtService,
    private readonly transactionHost: TransactionHost,
    private readonly chatMessageService: ChatMessageService,
  ) {}

  @WebSocketServer()
  server: Namespace;

  connectedUsers: Map<string, AuthUserDTO> = new Map();

  afterInit(client: Socket) {
    const middleware = SocketAuthMiddleware(this.jwtService, this.logger);

    client.use(middleware as any); // because types are broken
    this.logger.log('Message Chat Gateway initialized');
  }

  handleDisconnect(client: Socket) {
    client.disconnect();
    this.connectedUsers.delete(client.id);
    this.logger.log(`Client with id ${client.id} disconnected at ${nowEpoch()} `);
  }

  async handleConnection(client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    if (!user) {
      this.logger.log(
        ` ~ MessageChatGateway ~ handleConnection ~  Client with id ${client.id} cannot connect due to error with identification`,
      );
      client.disconnect();
      return;
    }

    this.connectedUsers.set(client.id, user);

    this.logger.log(
      ` ~ MessageChatGateway ~ handleConnection ~  Client with id ${client.id} connected at ${new Date().toDateString()}`,
    );
    await this.onConnectRoom(user, client);
  }

  // ==================== MESSAGE CHAT EVENT ====================
  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.SEND_MESSAGE)
  async onSendMessage(@MessageBody() body: ChatMessageCreateREQ, @ConnectedSocket() client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    // const isMemberConversation = user.accountType === AccountType.COMPANY_ADMIN && !isUndefined(body.chatRoomId);

    const chatRoomId = await this.onJoinRoom(client, { receiverId: body.receiverId });

    const message = await this.chatMessageService.createMessageChat(user, chatRoomId, body);

    this.server.to(parseRoomChatId(message.chatRoomId)).emit(SOCKET_CHAT_MESSAGE_EVENT.NEW_MESSAGE, message);
    return BaseResponse.of(message);
  }

  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.JOIN_ROOM)
  async onJoinRoom(@ConnectedSocket() client: AuthSocket, @MessageBody() body: ChatRoomCreateREQ) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    const { chatRoom, isNewConversation } = await this.chatMessageService.joinConversation(user, body.receiverId);

    await client.join(parseRoomChatId(chatRoom.id));

    //loop hashmap key connectedUsers
    if (isNewConversation) await this.connectReceiverToConversation(chatRoom.id, body.receiverId);

    return chatRoom.id;
  }

  @SubscribeMessage(SOCKET_CHAT_MESSAGE_EVENT.READ_MESSAGE)
  async onReadMessage(@MessageBody() body: ChatRoomReadMessageREQ, @ConnectedSocket() client: AuthSocket) {
    const user = await this.getAccountFromJWTPayload(client.payload);

    await this.chatMessageService.readMessage(user, body);
    this.logger.log(
      ` ~ ChatMessageGateway ~ onReadMessage ~ chatMessageService: User ${user.accountId} read message in room ${body.chatRoomId}`,
    );
  }

  private async onConnectRoom(user: AuthUserDTO, @ConnectedSocket() client: AuthSocket) {
    const rooms = await this.connectConversation(user);
    if (rooms && rooms.length !== 0) {
      for (const room of rooms) {
        await client.join(parseRoomChatId(room.id));
      }
    }

    return rooms;
  }

  private async connectConversation(user: AuthUserDTO) {
    const conservations = await this.transactionHost.tx.chatRoom.findMany(ChatRoomListHelper.findMany(user));

    return conservations;
  }

  private async connectReceiverToConversation(chatRoomId: number, receiverId: number) {
    for (const clientId of this.connectedUsers.keys()) {
      const account = this.connectedUsers.get(clientId);

      if (account.accountId === receiverId) {
        await this.server.sockets.get(clientId).join(parseRoomChatId(chatRoomId));
      }
    }
  }

  private async getAccountFromJWTPayload(payload: AuthJwtPayloadDTO): Promise<AuthUserDTO> {
    if (!payload) throw new WsException(UnauthorizedException);
    const account = await this.transactionHost.tx.account.findUnique({
      where: { id: Number(payload.sub) },
      select: {
        id: true,
        name: true,
        email: true,
        phoneNumber: true,
        accountType: true,
      },
    });

    if (!account) throw new UnauthorizedException('Account not found');
    return AuthUserDTO.fromEntity(account as any);
  }
}
</file>

<file path="src/domains/chat-message/chat-message.module.ts">
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { JWT_ACCESS_TOKEN_EXPIRE_HOURS, JWT_SECRET_KEY } from 'src/app.config';
import { AccountModule } from '../accounts/accounts.module';
import { ChatMessageController } from './chat-message.controller';
import { ChatMessageGateway } from './chat-message.gateway';
import { ChatMessageService } from './chat-message.service';

@Module({
  imports: [
    AccountModule,
    JwtModule.register({
      secret: JWT_SECRET_KEY,
      signOptions: { algorithm: 'HS256', expiresIn: JWT_ACCESS_TOKEN_EXPIRE_HOURS },
      verifyOptions: { algorithms: ['HS256'] },
    }),
  ],
  controllers: [ChatMessageController],
  providers: [ChatMessageService, ChatMessageGateway],
})
export class ChatMessageModule {}
</file>

<file path="src/domains/chat-message/chat-message.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ChatMessageService } from './chat-message.service';

describe('ChatMessageService', () => {
  let service: ChatMessageService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ChatMessageService],
    }).compile();

    service = module.get<ChatMessageService>(ChatMessageService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/chat-message/chat-message.service.ts">
import { Injectable } from '@nestjs/common';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { NUMBER_MESSAGE_INCREMENT_DEFAULT } from 'src/shared/constants/chat-message.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountService } from '../accounts/account.service';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ChatRoomCreateHelper } from './helper/chat-room-create.helper';
import { ChatRoomDetailHelper } from './helper/chat-room-detail.helper';
import { ChatRoomListHelper } from './helper/chat-room-list-helper';
import { ChatRoomReadMessageHelper } from './helper/chat-room-read-message.helper';
import { ChatMessageCreateREQ } from './request/chat-message-create.request';
import { ChatRoomDetailREQ } from './request/chat-room-detail.request';
import { ChatRoomListREQ } from './request/chat-room-list.request';
import { ChatRoomReadMessageREQ } from './request/chat-room-read-message.request';
import { ChatMessageDetailRESP, ChatRoomDetailRESP } from './response/chat-room-detail.response';
import { ChatRoomListRESP } from './response/chat-room-list.response';
import { ChatMessageCreateRESP } from './response/message-chat-create.response';
import { ChatMessageGetPayload, ChatRoomGetPayload } from './shared/types';

@Injectable()
export class ChatMessageService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
  ) {}

  async findAll(user: AuthUserDTO, query: ChatRoomListREQ) {
    const conversations = await this.transactionHost.tx.chatRoom.findMany(ChatRoomListHelper.toFindManyPrivateRoom(user, query));

    const count = await this.transactionHost.tx.chatRoom.count({
      where: ChatRoomListHelper.toQueryCondition(user, query),
    });

    const chatRoomDtos = await Promise.all(
      conversations.map(async (chatRoom: ChatRoomGetPayload) => {
        const lastMessage =
          chatRoom.lastMessageId &&
          ((await this.transactionHost.tx.chatMessage.findFirst({
            where: { id: chatRoom.lastMessageId },
            select: { message: true, createdAt: true, senderId: true },
          })) as ChatMessageGetPayload);

        const numOfUnreadMessage = await this.transactionHost.tx.chatMessage.count({
          where: { chatRoomId: chatRoom.id, isRead: false },
        });

        const receiverParticipant = chatRoom.ChatParticipants.find((participant) => participant.participantId !== user.accountId);
        const receiver = await this.accountService.getMe(receiverParticipant.participantId);
        const result = ChatRoomListRESP.fromEntity(chatRoom, lastMessage, numOfUnreadMessage, {
          id: receiver.account.id,
          name: receiver.account.name,
          thumbnail: receiver.thumbnail,
        });

        return result;
      }),
    );

    return { chatRoomDtos, count: count };
  }

  async joinConversation(user: AuthUserDTO, receiverId: number) {
    const chatRoom = (await this.transactionHost.tx.chatRoom.findFirst(
      ChatRoomCreateHelper.toFindFirst(user, receiverId),
    )) as ChatRoomGetPayload;

    if (chatRoom) {
      return { chatRoom: chatRoom, isNewConversation: false };
    }

    const newConversation = await this.transactionHost.tx.chatRoom.create(ChatRoomCreateHelper.toCreateInput(user, receiverId));

    return { chatRoom: newConversation, isNewConversation: true };
  }

  async createMessageChat(user: AuthUserDTO, chatRoomId: number, body: ChatMessageCreateREQ) {
    const message = await this.transactionHost.tx.chatMessage.create(ChatMessageCreateREQ.toCreateInput(user, chatRoomId, body));

    await this.transactionHost.tx.chatRoom.update({
      where: { id: chatRoomId },
      data: { numberOfMessages: { increment: NUMBER_MESSAGE_INCREMENT_DEFAULT }, lastMessageId: message.id },
      select: { id: true },
    });

    return ChatMessageCreateRESP.fromEntity(message as ChatMessageGetPayload);
  }

  async getAllMessagesByRoomId(user: AuthUserDTO, roomId: number, body: ChatRoomDetailREQ) {
    const isPaticipated = await this.isParticipantBelongToConversation(user.accountId, roomId);
    if (!isPaticipated) {
      throw new ActionFailedException(ActionFailed.CHAT_ROOM_NOT_INCLUDE_USER, 'You are not allowed to view this conversation');
    }

    const chatRoom = (await this.transactionHost.tx.chatRoom.findUniqueOrThrow(
      ChatRoomDetailHelper.toFindUnique(roomId),
    )) as ChatRoomGetPayload;

    const messages = await this.transactionHost.tx.chatMessage.findMany(
      ChatRoomDetailHelper.toFindManyMessages(chatRoom.id, body),
    );

    const receiverParticipant = chatRoom.ChatParticipants.find((participant) => participant.participantId !== user.accountId);
    const receiver = await this.accountService.getMe(receiverParticipant.participantId);

    const messageDTOs = messages.map((e: ChatMessageGetPayload) => {
      return ChatMessageDetailRESP.fromEntity(e, user.accountId !== e.Sender.id);
    });

    return ChatRoomDetailRESP.fromEntity(chatRoom, messageDTOs, {
      id: receiver.account.id,
      name: receiver.account.name,
      thumbnail: receiver.thumbnail,
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async readMessage(user: AuthUserDTO, body: ChatRoomReadMessageREQ) {
    const isParticipated = await this.isParticipantBelongToConversation(user.accountId, body.chatRoomId);
    if (!isParticipated) {
      throw new ActionFailedException(ActionFailed.CHAT_ROOM_NOT_INCLUDE_USER, 'You are not allowed to view this conversation');
    }

    const messages = await this.transactionHost.tx.chatMessage.updateMany(ChatRoomReadMessageHelper.toUpdateInput(user, body));
    console.log(' ~ ChatMessageService ~ readMessage ~ messages:', messages);
  }

  async isParticipantBelongToConversation(accountId: number, roomId: number) {
    const conversation = await this.transactionHost.tx.chatParticipant.findFirst({
      where: { chatRoomId: roomId, participantId: accountId },
      select: { chatRoomId: true },
    });

    return Boolean(conversation);
  }
}
</file>

<file path="src/domains/course/admin/request/course-approve.request.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class CourseApproveREQ {
  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/course/admin/response/course-admin-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseAdminDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  image: ImageRESP;

  static fromEntity(course: CourseGetPayload, sections: CourseSectionDTO[], image: ImageRESP): CourseAdminDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/admin/response/course-admin-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';

export class CourseAdminListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: {
    id: number;
    name: string;
  };
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseAdminListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: {
        id: e.Creator.id,
        name: e.Creator.name,
      },
    };
  }
}
</file>

<file path="src/domains/course/admin/course-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminController', () => {
  let controller: CourseAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseAdminController],
      providers: [CourseAdminService],
    }).compile();

    controller = module.get<CourseAdminController>(CourseAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseAdminService } from './course-admin.service';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminDetailRESP } from './response/course-admin-detail.response';

@Controller('admin/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class CourseAdminController {
  constructor(private readonly courseAdminService: CourseAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseAdminListREQ) {
    const { dtos, count } = await this.courseAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { course, sectionDtos, image } = await this.courseAdminService.detail(id);

    const response = CourseAdminDetailRESP.fromEntity(course, sectionDtos, image);
    return BaseResponse.of(response);
  }

  @Patch(':id/approve')
  async approve(@Param('id', ParseIntPipe) id: number, @Body() body: CourseApproveREQ) {
    const course = await this.courseAdminService.approve(id, body);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/admin/course-admin.module.ts">
import { Module } from '@nestjs/common';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

@Module({
  controllers: [CourseAdminController],
  providers: [CourseAdminService, CourseListFactory],
})
export class CourseAdminModule {}
</file>

<file path="src/domains/course/admin/course-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminService', () => {
  let service: CourseAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseAdminService],
    }).compile();

    service = module.get<CourseAdminService>(CourseAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus, NotificationRelationType, NotificationType } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseErrorMessages } from 'src/shared/messages/error-messages';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminListRESP } from './response/course-admin-list.response';

@Injectable()
export class CourseAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly courseListFactory: CourseListFactory,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  async list(user: AuthUserDTO, query: CourseAdminListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.ADMIN, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
    const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
          _avg: { courseRating: true },
        });

        return CourseAdminListRESP.fromEntity(course, thumbnail, {
          noOfFeedbacks,
          noOfSubscriptions: course._count.Subscriptions,
          rateOfCourse: ratingOfCourse._avg.courseRating,
        });
      }),
    );

    return { dtos, count };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    const image = await this.imageService.getImageOriginal(course.imageId);

    return { course, sectionDtos, image };
  }

  async approve(id: number, body: CourseApproveREQ) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    if (course.status !== CourseStatus.PENDING) {
      throw new ActionFailedException(ActionFailed.COURSE_STATUS_CANNOT_UPDATE, CourseErrorMessages.MSG02);
    }

    const updatedCourse = await this.transactionHost.tx.course.update({
      where: { id: course.id },
      data: { status: body.isApproved ? CourseStatus.APPROVED : CourseStatus.REJECTED },
      select: { id: true, creatorId: true },
    });

    //Notification: Send notification to course owner
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      updatedCourse.creatorId,
      body.isApproved ? NotificationType.COURSE_APPROVED : NotificationType.COURSE_REJECTED,
    );

    runFunctionWithCondition(!!updatedCourse, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedCourse;
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/client/request/course-client-create.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  ArrayMinSize,
  IsArray,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Max,
  MaxLength,
  Min,
} from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseClientCreateREQ {
  @NameValidator()
  name: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @IsNumber()
  @Min(1)
  @Max(10)
  totalDuration: number;

  @Min(0)
  @IsNumber()
  price: number;

  @IdValidator()
  categoryId: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @BooleanValidator()
  isPublic: boolean;

  @IsEnum([CourseStatus.DRAFT, CourseStatus.PENDING])
  status: CourseStatus;

  @IsArray()
  @Type(() => String)
  prerequisites: string[];

  @IsArray()
  @Type(() => String)
  @ArrayNotDuplicated(String)
  objectives: string[];

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences: TargetAudience[];

  @IsArray()
  @IsOptional()
  @Type(() => CourseSectionDTO)
  sections?: CourseSectionDTO[] = [];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;

  static toCreateInput(user: AuthUserDTO, body: CourseClientCreateREQ): Prisma.CourseCreateArgs {
    return {
      data: {
        name: body.name,
        status: body.status,
        description: body.description,
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        totalDuration: body.totalDuration,
        price: body.price,
        startDate: parsePrismaDate(body.startDate),
        endDate: parsePrismaDate(body.endDate),
        Creator: connectRelation(user.accountId),
        Category: connectRelation(body.categoryId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/client/request/course-client-update.request.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class CourseClientUpdateREQ {
  @NameValidator()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description?: string;

  @IsNumber()
  @IsOptional()
  totalDuration?: number;

  @Min(0)
  @IsNumber()
  @IsOptional()
  price?: number;

  @IdValidator()
  @IsOptional()
  categoryId?: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsOptional()
  @IsEnum([CourseStatus.PENDING, CourseStatus.STOPPED, CourseStatus.ARCHIVED, CourseStatus.DRAFT])
  status?: CourseStatus;

  @IsNumber()
  @IsOptional()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  litmitOfStudents?: number;

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  prerequisites?: string[];

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  objectives: string[] = [];

  @IsArray()
  @IsOptional()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;
}
</file>

<file path="src/domains/course/client/request/course-section-client-update.request.ts">
import { PartialType } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ArrayMinSize, IsArray, IsOptional } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionUpdateDTO extends PartialType(CourseSectionDTO) {}

export class CourseSectionAddREQ extends CourseSectionDTO {}

export class CourseSectionRemoveREQ {
  @IsArray()
  @IsOptional()
  @Type(() => Number)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  removeSectionIds: number[] = [];
}
</file>

<file path="src/domains/course/client/response/course-client-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  mentor: CourseMentorDetailRESP;
  image: ImageRESP;

  static fromEntity(
    course: CourseGetPayload,
    sections: CourseSectionDTO[],
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
  ): CourseClientDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      mentor: mentor,
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-client-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  countOfSections: number;
  price: number;
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: CourseMentorDetailRESP;
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseClientListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      price: parseDecimalNumber(e.price),
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      countOfSections: e._count.Sections,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: mentor,
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-section-client.response.ts">
import { FileRESP } from 'src/domains/file/response/file.response';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionClientRESP {
  id: number;
  title: string;
  description: string;
  isPublic: boolean;
  files: FileRESP[];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionClientRESP {
    return {
      id: e.id,
      title: e.title,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/client/course-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

describe('CourseClientController', () => {
  let controller: CourseClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseClientController],
      providers: [CourseClientService],
    }).compile();

    controller = module.get<CourseClientController>(CourseClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthService } from 'src/domains/auth/auth.service';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseClientService } from './course-client.service';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionUpdateDTO } from './request/course-section-client-update.request';

@Controller('client/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR, AccountType.STUDENT)
export class CourseClientController {
  constructor(
    private readonly courseClientService: CourseClientService,
    private readonly authService: AuthService,
  ) {}

  @Get()
  @Public()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const { dtos, count } = await this.courseClientService.list(query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get('students')
  @Roles(AccountType.STUDENT)
  async getAllCoursesLearnedByStudent(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const dtos = await this.courseClientService.listCoursesLearnedByAccountId(req.user, query);

    return BaseResponse.of(dtos);
  }

  @Post()
  @Roles(AccountType.MENTOR)
  async create(@Req() req: AuthRequestDTO, @Body() body: CourseClientCreateREQ) {
    const course = await this.courseClientService.create(req.user, body);

    return BaseResponse.of(course);
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const jwtToken = req.headers['authorization']?.slice(7);
    const accountId = this.authService.getAccountIdFromToken(jwtToken);

    const course = await this.courseClientService.getPublicCourseDetail(id, accountId);

    return BaseResponse.of(course);
  }

  @Patch(':id')
  @Roles(AccountType.MENTOR)
  async update(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number, @Body() body: CourseClientUpdateREQ) {
    const course = await this.courseClientService.update(id, req.user, body);

    return BaseResponse.of(course);
  }

  @Delete(':id')
  @Roles(AccountType.MENTOR)
  async delete(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.courseClientService.delete(id, req.user);

    return BaseResponse.ok();
  }

  @Post(':courseId/sections')
  @Roles(AccountType.MENTOR)
  async createSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: CourseSectionDTO,
  ) {
    const course = await this.courseClientService.createSectionByCourseId(courseId, body, req.user);

    return BaseResponse.of(course);
  }

  @Patch(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async updateSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
    @Body() body: CourseSectionUpdateDTO,
  ) {
    const course = await this.courseClientService.updateSectionByCourseId(courseId, sectionId, body, req.user);

    return BaseResponse.of(course);
  }

  @Delete(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async deleteSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
  ) {
    const course = await this.courseClientService.deleteSectionByCourseId(courseId, sectionId, req.user);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/client/course-client.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from 'src/domains/auth/auth.module';
import { CommonModule } from 'src/services/common.module';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

@Module({
  imports: [CommonModule, AuthModule],
  controllers: [CourseClientController],
  providers: [CourseClientService, CourseListFactory],
  exports: [CourseClientService],
})
export class CourseClientModule {}
</file>

<file path="src/domains/course/client/course-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientService } from './course-client.service';

describe('CourseClientService', () => {
  let service: CourseClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseClientService],
    }).compile();

    service = module.get<CourseClientService>(CourseClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AccountType,
  CourseStatus,
  MentorStatus,
  NotificationRelationType,
  NotificationType,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { COURSE_PUBLIC_STATUS } from 'src/shared/constants/course.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseSectionHelper } from '../shared/helper/course-section.helper';
import { CourseUpdateHelper } from '../shared/helper/course-update-query.helper';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionAddREQ, CourseSectionUpdateDTO } from './request/course-section-client-update.request';
import { CourseClientDetailRESP } from './response/course-client-detail.response';
import { CourseClientListRESP } from './response/course-client-list.response';

@Injectable()
export class CourseClientService {
  private readonly logger: Logger = new Logger(CourseClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
    private readonly courseListFactory: CourseListFactory,
  ) {}

  async list(query: CourseClientListREQ) {
    query.courseStatus = CourseStatus.APPROVED;
    const courses = await this.transactionHost.tx.course.findMany(CourseListQueryHelper.toFindMany(query));
    const count = await this.transactionHost.tx.course.count({
      where: { ...CourseListQueryHelper.toQueryCondition(query), isPublic: true, status: CourseStatus.APPROVED },
    });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          { noOfSubscriptions: course._count.Subscriptions, noOfFeedbacks, rateOfCourse: await this.getRateOfCourse(course.id) },
        );
      }),
    );

    return { dtos, count };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async delete(id: number, user: AuthUserDTO) {
    //Check course belong to user
    let course: CourseGetPayload;
    try {
      course = (await this.transactionHost.tx.course.findUniqueOrThrow({
        where: { id: id, creatorId: user.accountId },
        select: {
          id: true,
          Sections: { select: { id: true, ...IS_ACTIVE_NESTED } },
          MentorSchedules: { select: { id: true, ...IS_ACTIVE_NESTED } },
        },
      })) as CourseGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    //Check if any subscription is active so throw error
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { courseId: id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
      select: { id: true },
    });

    if (!isEmpty(subscriptions)) throw new ActionFailedException(ActionFailed.COURSE_HAS_ACTIVE_SUBSCRIPTION);

    const sectionIds = await this.transactionHost.tx.courseSection.deleteMany({ where: { courseId: id } });
    if (!isEmpty(sectionIds)) {
      await Promise.all([
        //Delete course sections
        course.Sections.map(async (section) => {
          await this.transactionHost.tx.sectionAttachment.deleteMany({ where: { sectionId: section.id } });
        }),
        //Delete course schedules
        course.MentorSchedules.map(async (schedule) => {
          await this.transactionHost.tx.mentorSchedule.delete({ where: { id: schedule.id } });
        }),
      ]);
    }
    //Delete course
    await this.transactionHost.tx.course.delete({ where: { id } });
  }

  async listCoursesLearnedByAccountId(user: AuthUserDTO, query: CourseClientListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfSubscriptions: course._count.Subscriptions,
            noOfFeedbacks,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  // async getAllCoursesByAccount(user: AuthUserDTO, query: CourseClientListREQ) {
  //   const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
  //   const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
  //   const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

  //   const dtos = await Promise.all(
  //     courses.map(async (course: CourseGetPayload) => {
  //       const thumbnail = await this.imageService.getImageOriginal(course.imageId);
  //       return CourseClientListRESP.fromEntity(course, thumbnail);
  //     }),
  //   );

  //   return { dtos, count };
  // }

  async getPublicCourseDetail(id: number, accountId: number) {
    const { course, sectionDtos } = await this.detail(id);
    const isCoursePublic = COURSE_PUBLIC_STATUS.includes(course.status) && course.isPublic;

    if (!isCoursePublic && course.creatorId !== accountId) {
      throw new ActionFailedException(ActionFailed.COURSE_CANNOT_VIEW_DETAIL);
    }

    //TODO: Check if  course not public but student subcribed

    const image = await this.imageService.getImageOriginal(course.imageId);

    const { mentor, thumbnail } = await this.getMentorByAccountId(course.creatorId);

    return CourseClientDetailRESP.fromEntity(course, sectionDtos, image, {
      id: mentor.id,
      accountId: mentor.accountId,
      name: mentor.Account.name,
      thumbnail: thumbnail,
    });
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);

    return { mentor, thumbnail };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    return { course, sectionDtos };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(id: number, user: AuthUserDTO, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update course */
    const updatedCourse = await this.transactionHost.tx.course.update(CourseUpdateHelper.toUpdate(id, body));

    await this.imageService.linkImageToCourse(id, body.imageId);

    /* 3. TODO: Update notification to admin, and student subcribed */

    return updatedCourse;
  }

  async getAllbyCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ) {
    const courses = await this.transactionHost.tx.course.findMany(
      CourseListQueryHelper.toListByCreatorId(creatorId, isOwner, query),
    );

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfFeedbacks,
            noOfSubscriptions: course._count.Subscriptions,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  private async getRateOfCourse(courseId: number) {
    const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
      where: { Subscription: { courseId, ...IS_ACTIVE_NESTED } },
      _avg: { courseRating: true },
    });

    return ratingOfCourse._avg.courseRating;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, body: CourseClientCreateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { accountId: user.accountId },
      select: { id: true, status: true },
    });

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    if (body.categoryId) await this.checkExistedCategory(body.categoryId);

    const course = await this.transactionHost.tx.course.create(CourseClientCreateREQ.toCreateInput(user, body));
    await this.imageService.linkImageToCourse(course.id, body.imageId);

    /* create course sections  */
    //TODO: Handle files in each
    for (const section of body.sections) {
      await this.createSection(course.id, section);
    }

    //Notification: send Notification to admin
    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      admin.id,
      NotificationType.COURSE_CREATED,
    );

    runFunctionWithCondition(!!course, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return course;
  }

  // ==================== METHOD ====================
  private async createSection(courseId: number, section: CourseSectionDTO) {
    if (!courseId) return;

    if (!isEmpty(section.files)) {
      const fileIds = section.files.map((item) => item.fileId);
      await this.checkFiles(fileIds);
    }

    const ordinal = await this.transactionHost.tx.courseSection.aggregate(CourseSectionHelper.toFindMaxOrdinal(courseId));
    const maxOrdinal = ordinal._max.ordinal || 0;

    const courseSection = await this.transactionHost.tx.courseSection.create({
      data: CourseSectionHelper.toCreateInput(courseId, section, maxOrdinal),
      select: { id: true },
    });

    return courseSection;
  }

  private async checkExistedCategory(categoryId: number) {
    const category = await this.transactionHost.tx.category.findFirst({
      where: { id: categoryId },
      select: { id: true, parentCategoryId: true },
    });

    if (!category) throw new ActionFailedException(ActionFailed.CATEGORY_NOT_FOUND);

    return category;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateStatus(id: number, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow(CourseDetailQueryHelper.toFindUnique(id));

    await this.transactionHost.tx.course.update({
      where: { id },
      data: { status: body.status },
    });

    return course.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async createSectionByCourseId(courseId: number, body: CourseSectionAddREQ, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.createSection(courseId, body);

    return { courseId: course.id, sectionId: section.id };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateSectionByCourseId(courseId: number, sectionId: number, body: CourseSectionUpdateDTO, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.transactionHost.tx.courseSection.update({
      where: { id: sectionId, courseId },
      data: CourseSectionHelper.toUpdateInput(body),
      select: { id: true },
    });

    const fileIds = body.files.map((item) => item.fileId);
    await this.updateSectionAttachments(sectionId, fileIds);

    return { courseId: course.id, sectionId: section.id };
  }

  async updateSectionAttachments(sectionId: number, fileIds: number[]) {
    if (isEmpty(fileIds)) return;

    const attachments = await this.transactionHost.tx.sectionAttachment.findMany({
      where: { sectionId },
      select: { fileId: true },
    });

    const existedFileIds = attachments.map((item) => item.fileId);
    const notSectionFileIds = fileIds.filter((id) => !existedFileIds.includes(id));
    if (!isEmpty(notSectionFileIds)) {
      await this.checkFiles(notSectionFileIds);
      await this.transactionHost.tx.sectionAttachment.createMany({
        data: notSectionFileIds.map((fileId) => addCreationTimestamps({ sectionId, fileId })),
      });
    }

    for (const file of existedFileIds) {
      if (!fileIds.includes(file)) {
        const numberOfRecords = await this.transactionHost.tx.$executeRaw`DELETE FROM section_attachments WHERE file_id=${file}`;
        runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.delete(file));
      }
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async deleteSectionByCourseId(courseId: number, sectionId: number, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);
    const sectionIds = course.Sections.map((section) => section.id);

    if (isEmpty(sectionIds) || !sectionIds.includes(sectionId))
      throw new ActionFailedException(ActionFailed.COURSE_SECTION_NOT_FOUND_IN_COURSE);

    const section = await this.transactionHost.tx.courseSection.findFirst({
      where: { id: sectionId, courseId },
      select: { id: true, SectionAttachments: { select: { fileId: true } } },
    });

    /* 2. delete section attachments */
    const fileIds = section.SectionAttachments.map((item) => item.fileId);

    if (!isEmpty(fileIds)) {
      const numberOfRecords = await this.transactionHost.tx
        .$executeRaw`DELETE FROM section_attachments WHERE section_id=${sectionId}`;

      runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.checkAttachmentUploadedOrThrow(fileIds));
    }

    /* 3. delete course sections */
    await this.transactionHost.tx.courseSection.delete({
      where: { id: sectionId, courseId: courseId },
    });

    return { courseId: course.id, sectionId: section.id };
  }

  // async updateTotalDuration(courseId: number) {
  //   const totalDuration = await this.transactionHost.tx.courseSection.aggregate({
  //     where: { courseId, ...IS_ACTIVE_NESTED },
  //     _sum: { duration: true },
  //   });

  //   await this.transactionHost.tx.course.update({
  //     where: { id: courseId },
  //     data: { totalDuration: totalDuration._sum.duration },
  //   });
  // }

  @Transactional(TRANSACTION_TIMEOUT)
  async checkFiles(fileIds: number[]) {
    await this.fileService.checkAttachmentUploadedOrThrow(fileIds);
    // await this.fileService.checkFileLinked(fileIds);

    /* Create and link file */
    await this.fileService.enableUploaded(fileIds);
  }

  async checkCourseCreator(accountId: number, creatorId: number) {
    if (accountId !== creatorId) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/dto/course-section.dto.ts">
import { Type } from 'class-transformer';
import { ArrayMaxSize, IsArray, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { FileRESP } from 'src/domains/file/response/file.response';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { orNull } from 'src/shared/parsers/io.parser';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionAttachmentDTO {
  @IdValidator()
  fileId: number;

  @IsOptional()
  @BooleanValidator()
  isPublic: boolean = false;
}

export class CourseSectionDTO {
  @IdValidator()
  @IsOptional()
  id?: number;

  @NameValidator()
  title: string;

  @IsNumber()
  @IsOptional()
  ordinal?: number;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @BooleanValidator()
  isPublic: boolean = false;

  @IsArray()
  @Type(() => CourseSectionAttachmentDTO)
  @IsOptional()
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  files?: CourseSectionAttachmentDTO[] = [];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionDTO {
    return {
      id: e.id,
      title: e.title,
      ordinal: e.ordinal,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-admin-list.request.ts">
import { PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseAdminListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseAdminListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: condition,
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        status: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-client-list.request.ts">
import { AccountStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseClientListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseClientListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount(user: AuthUserDTO, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: { ...condition, Creator: { status: { not: AccountStatus.SUSPENSIVE } } },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/course-list.factory.ts">
import { Injectable } from '@nestjs/common';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { CourseBaseListREQ } from '../shared/course-base-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseAdminListREQ } from './list/course-admin-list.request';
import { CourseClientListREQ } from './list/course-client-list.request';

@Injectable()
export class CourseListFactory {
  getClass<T extends CourseBaseListREQ>(classType: CourseListDTOType, data: T): CourseBaseListREQ {
    switch (classType) {
      case CourseListDTOType.CLIENT:
        return new CourseClientListREQ(data);
      case CourseListDTOType.ADMIN:
        return new CourseAdminListREQ(data);
      default:
        throw new ActionFailedException(ActionFailed.CLASS_TYPE_NOT_FOUND);
    }
  }
}
</file>

<file path="src/domains/course/shared/helper/course-detail-query.helper.ts">
import { Prisma } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class CourseDetailQueryHelper {
  static toFindUnique(id: number): Prisma.CourseFindUniqueOrThrowArgs {
    // const isCourseOwner = user.accountType === AccountType.MENTOR;

    // const creator = orUndefinedWithCondition(isCourseOwner, {
    //   creatorId: user.accountId,
    // });

    return {
      where: { id },
      select: {
        id: true,
        name: true,
        status: true,
        description: true,
        totalDuration: true,
        price: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        litmitOfStudents: true,
        creatorId: true,
        categoryId: true,
        createdAt: true,
        imageId: true,
        Category: {
          select: { id: true, name: true },
        },
        Sections: {
          where: { ...IS_ACTIVE_NESTED },
          orderBy: { ordinal: 'asc' },
          select: { id: true, title: true, description: true, ordinal: true, isPublic: true },
        },
        Creator: { select: { id: true, name: true } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-list-query.helper.ts">
import { AccountStatus, AccountType, CourseStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientListREQ } from '../../factory/list/course-client-list.request';
import { CourseBaseListREQ } from '../course-base-list.request';
import { CourseSortableFields } from '../enums';

export class CourseListQueryHelper {
  static toFilterByAccountType = (user: AuthUserDTO): Prisma.CourseWhereInput => {
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.STUDENT:
        return {
          status: CourseStatus.APPROVED,
          Subscriptions: { some: { Account: { id: user.accountId, accountType: AccountType.STUDENT }, ...IS_ACTIVE_NESTED } },
        };
      case AccountType.MENTOR:
        return {
          OR: [
            { Creator: { id: user.accountId, accountType: AccountType.MENTOR } },
            { isPublic: true, status: CourseStatus.APPROVED },
          ],
        };
      default:
        return { isPublic: true, status: CourseStatus.APPROVED };
    }
  };

  static toQueryCondition = (query: CourseBaseListREQ): Prisma.CourseWhereInput => {
    const creatorName = orUndefinedWithCondition(!!query.creatorName, { Creator: parsePrismaSearch('name', query.creatorName) });
    const courseName = orUndefinedWithCondition(!!query.courseName, parsePrismaSearch('name', query.courseName));
    const targetAudiences = orUndefinedWithCondition(!!query.targetAudiences, {
      targetAudiences: { hasEvery: query.targetAudiences },
    });
    const categoryIds = orUndefinedWithCondition(!!query.categoryIds, {
      Category: { id: { in: query.categoryIds } },
    });

    return leanObject({
      status: query.courseStatus,
      ...courseName,
      ...creatorName,
      ...targetAudiences,
      ...categoryIds,
    });
  };

  static toOrderBy = (query: CourseBaseListREQ): Prisma.CourseOrderByWithRelationInput => {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case CourseSortableFields.CREATOR_NAME:
        return { Creator: { name: query.sortOrder } };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  };

  static toListByCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const condition = isOwner ? this.toQueryCondition(query) : { status: CourseStatus.APPROVED };

    return {
      where: { Creator: { id: creatorId }, ...condition },
      orderBy: defaultSortDesc,
      select: {
        id: true,
        name: true,
        status: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,

        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }

  static toFindMany(query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const orderBy = CourseListQueryHelper.toOrderBy(query);
    const condition = CourseListQueryHelper.toQueryCondition(query);

    return {
      where: {
        ...condition,
        isPublic: true,
        status: CourseStatus.APPROVED,
        Creator: {
          status: { not: AccountStatus.SUSPENSIVE },
        },
      },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        imageId: true,
        createdAt: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true, avatarId: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-section.helper.ts">
import { Prisma } from '@prisma/client';
import { isEmpty } from 'lodash';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseSectionUpdateDTO } from '../../client/request/course-section-client-update.request';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionHelper {
  static toCreateInput(courseId: number, body: CourseSectionDTO, maxOrdinal: number): Prisma.CourseSectionCreateInput {
    //TODO: Add fileData
    const fileData = orUndefinedWithCondition(!isEmpty(body.files), {
      SectionAttachments: {
        createMany: {
          data: body.files.map((item) => addCreationTimestamps({ fileId: item.fileId, isPublic: item.isPublic })),
        },
      },
    });

    return {
      title: body.title,
      ordinal: maxOrdinal + 1,
      description: body.description,
      isPublic: body.isPublic,
      Course: connectRelation(courseId),
      ...fileData,
    };
  }

  static toUpdateInput(body: CourseSectionUpdateDTO): Prisma.CourseSectionUpdateInput {
    return {
      title: body.title,
      description: body.description,
      isPublic: body.isPublic,
    };
  }

  static toFindMaxOrdinal(courseId: number): Prisma.CourseSectionAggregateArgs {
    return {
      where: { courseId },
      _max: { ordinal: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-update-query.helper.ts">
import { Prisma } from '@prisma/client';
import { connectRelation, removeRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientUpdateREQ } from '../../client/request/course-client-update.request';

export class CourseUpdateHelper {
  static toUpdate(id: number, body: CourseClientUpdateREQ): Prisma.CourseUpdateArgs {
    return {
      where: { id },
      data: {
        name: body.name,
        description: body.description,
        price: body.price,
        isPublic: body.isPublic,
        startDate: parsePrismaDate(body.startDate),
        status: body.status,
        endDate: parsePrismaDate(body.endDate),
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        litmitOfStudents: body.litmitOfStudents,
        Category: connectRelation(body.categoryId),
        ...orUndefinedWithCondition(!!body.imageId, { Image: removeRelation() }),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/course-base-list.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { QueryArray } from 'src/shared/request-validator/query-array.validator';
import { CourseSortableFields } from './enums';

export abstract class CourseBaseListREQ extends PaginationREQ {
  @IsOptional()
  @NameValidator()
  courseName?: string;

  @IsOptional()
  @IsEnum(CourseStatus)
  courseStatus?: CourseStatus;

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(4)
  @IsOptional()
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @IsOptional()
  @ArrayNotDuplicated(Number)
  @QueryArray({ fieldType: 'number', minSize: COMMON_CONSTANT.ARRAY_MIN_SIZE })
  categoryIds?: number[];

  @NameValidator()
  @IsOptional()
  creatorName?: string;

  @IsOptional()
  @IsEnum(CourseSortableFields)
  sortBy?: CourseSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  abstract toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs;
}
</file>

<file path="src/domains/course/shared/enums.ts">
export enum CourseSortableFields {
  CREATOR_NAME = 'creatorName',
  COURSE_NAME = 'name',
  COURSE_STATUS = 'status',
  COURSE_TYPE = 'courseType',
}

export enum CourseListDTOType {
  CLIENT = 'client',
  ADMIN = 'admin',
}
</file>

<file path="src/domains/course/shared/types.ts">
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
export enum TargetAudienceLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  ADVANCED = 'ADVANCED',
  EXPERT = 'EXPERT',
}

export type CourseSectionUpdateDTO = {
  id: number;
} & CourseSectionDTO;

export type CourseMentorDetailRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
</file>

<file path="src/domains/course/course.module.ts">
import { Module } from '@nestjs/common';
import { CourseAdminModule } from './admin/course-admin.module';
import { CourseClientModule } from './client/course-client.module';

@Module({
  imports: [CourseClientModule, CourseAdminModule],
  exports: [CourseClientModule],
})
export class CourseModule {}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardAdminController } from './dashboard-admin.controller';
import { DashboardAdminService } from './dashboard-admin.service';

describe('DashboardAdminController', () => {
  let controller: DashboardAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DashboardAdminController],
      providers: [DashboardAdminService],
    }).compile();

    controller = module.get<DashboardAdminController>(DashboardAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.controller.ts">
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { DashboardAdminService } from './dashboard-admin.service';

@Controller('admin/dashboard')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class DashboardAdminController {
  constructor(private readonly dashboardAdminService: DashboardAdminService) {}

  @Get('overview')
  async getOverviewStatistic(@Query() query: StatisticOverviewListREQ) {
    const res = await this.dashboardAdminService.getOverviewStatistic(query);

    return BaseResponse.of(res);
  }

  @Get('payments')
  async getPaymentStatistic(@Query() query: StatisticPaymentListREQ) {
    const res = await this.dashboardAdminService.getPaymentStatistic(query);

    return BaseResponse.of(res);
  }

  @Get('subscriptions')
  async getSubscriptionStatistic(@Query() query: StatisticSubscriptionListREQ) {
    const res = await this.dashboardAdminService.listSubscription(query);

    return BaseResponse.of(res);
  }
}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { DashboardAdminController } from './dashboard-admin.controller';
import { DashboardAdminService } from './dashboard-admin.service';

@Module({
  imports: [AccountModule, MentorClientModule],
  controllers: [DashboardAdminController],
  providers: [DashboardAdminService],
})
export class DashboardAdminModule {}
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardAdminService } from './dashboard-admin.service';

describe('DashboardAdminService', () => {
  let service: DashboardAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DashboardAdminService],
    }).compile();

    service = module.get<DashboardAdminService>(DashboardAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/admin/dashboard-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { StudentGetPayload } from 'src/domains/student/shared/types';
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { getDiffDaysOfDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { getMillisecondsFromCurrentDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticOverviewAdminListHelper } from '../helper/statistic-overview-admin-list.helper';
import { StatisticPaymentListHelper } from '../helper/statistic-payment-list.helper';
import { StatisticSubscriptionListHelper } from '../helper/statistic-subscription-list.helper';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticOverviewListRESP } from '../response/statistic-overview-list.response';
import { StatisticPaymentListRESP } from '../response/statistic-payment-list.response';
import { StatisticSubscriptionListRESP } from '../shared/types';

@Injectable()
export class DashboardAdminService {
  private readonly logger = new Logger(DashboardAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
    private readonly mentorClientService: MentorClientService,
  ) {}

  async getOverviewStatistic(query: StatisticOverviewListREQ): Promise<StatisticOverviewListRESP> {
    const mentors = await this.transactionHost.tx.mentor.findMany(StatisticOverviewAdminListHelper.toFindManyMentor(query));
    const students = await this.transactionHost.tx.student.findMany(StatisticOverviewAdminListHelper.toFindManyStudent(query));
    const courses = await this.transactionHost.tx.course.findMany(StatisticOverviewAdminListHelper.toFindManyCourse(query));
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      StatisticOverviewAdminListHelper.toFindManySubscription(query),
    );
    const reports = await this.transactionHost.tx.report.findMany(StatisticOverviewAdminListHelper.toFindManyReport(query));
    const revenue = await this.transactionHost.tx.payment.findMany(StatisticOverviewAdminListHelper.toFindManyPayment(query));

    return {
      mentorOverview: StatisticOverviewAdminListHelper.getMentorOverview(mentors),
      courseOverview: StatisticOverviewAdminListHelper.getCourseOverview(courses),
      studentOverview: StatisticOverviewAdminListHelper.getStudentOverview(students as StudentGetPayload[]),
      subscriptionOverview: StatisticOverviewAdminListHelper.getSubscriptionOverview(subscriptions),
      reportOverview: StatisticOverviewAdminListHelper.getReportOverview(reports),
      revenueOverview: StatisticOverviewAdminListHelper.getPaymentOverview(revenue),
    };
  }

  async getPaymentStatistic(query: StatisticPaymentListREQ): Promise<StatisticPaymentListRESP[]> {
    const diffDays = getDiffDaysOfDateRange(query.dateRange);
    const numbers = Array.from({ length: diffDays + 1 }, (_, i) => i);
    const result = [];
    // Iterate over the numbers using for...of
    for (const number of numbers) {
      const beginDate = getMillisecondsFromCurrentDate({ days: number, fromBeginning: true });
      const endDate = getMillisecondsFromCurrentDate({ days: number, fromEnding: true });

      const paymentAggre = await this.transactionHost.tx.payment.aggregate(
        StatisticPaymentListHelper.toAggregate(query, beginDate, endDate),
      );
      const noOfPayments = await this.transactionHost.tx.payment.count({
        where: StatisticPaymentListHelper.toQueryPaymentCondition(query, beginDate, endDate),
      });

      const value: StatisticPaymentListRESP = { totalAmount: parseDecimalNumber(paymentAggre._sum.price), noOfPayments };
      const date = getMillisecondsFromCurrentDate({ days: number });
      result.push({ [String(date)]: value });
    }

    return result;
  }

  async listSubscription(query: StatisticSubscriptionListREQ): Promise<StatisticSubscriptionListRESP[]> {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(StatisticSubscriptionListHelper.toFindMany(query));

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );
  }
}
</file>

<file path="src/domains/dashboard/client/dashboard-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardClientController } from './dashboard-client.controller';
import { DashboardClientService } from './dashboard-client.service';

describe('DashboardClientController', () => {
  let controller: DashboardClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [DashboardClientController],
      providers: [DashboardClientService],
    }).compile();

    controller = module.get<DashboardClientController>(DashboardClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/client/dashboard-client.controller.ts">
import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticTopCourseListREQ } from '../request/statistic-top-course-list.request';
import { DashboardClientService } from './dashboard-client.service';

@Controller('client/dashboard')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR)
export class DashboardClientController {
  constructor(private readonly dashboardClientService: DashboardClientService) {}

  @Get('overview')
  async getOverviewStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticOverviewListREQ) {
    const res = await this.dashboardClientService.getOverviewStatistic(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('payments')
  async getPaymentStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticPaymentListREQ) {
    const res = await this.dashboardClientService.getPaymentStatistic(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('subscriptions')
  async getSubscriptionStatistic(@Req() req: AuthRequestDTO, @Query() query: StatisticSubscriptionListREQ) {
    const res = await this.dashboardClientService.listSubscription(req.user, query);

    return BaseResponse.of(res);
  }

  @Get('top-courses')
  async getTopCourses(@Req() req: AuthRequestDTO, @Query() query: StatisticTopCourseListREQ) {
    const res = await this.dashboardClientService.getTopCourses(req.user, query);

    console.log(' ~ DashboardClientController ~ getTopCourses ~ res:', res);

    return BaseResponse.of(res);
  }
}
</file>

<file path="src/domains/dashboard/client/dashboard-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { DashboardClientController } from './dashboard-client.controller';
import { DashboardClientService } from './dashboard-client.service';

@Module({
  imports: [AccountModule],
  controllers: [DashboardClientController],
  providers: [DashboardClientService],
})
export class DashboardClientModule {}
</file>

<file path="src/domains/dashboard/client/dashboard-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { DashboardClientService } from './dashboard-client.service';

describe('DashboardClientService', () => {
  let service: DashboardClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [DashboardClientService],
    }).compile();

    service = module.get<DashboardClientService>(DashboardClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/dashboard/client/dashboard-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { SubscriptionStatus } from '@prisma/client';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { getDiffDaysOfDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { getMillisecondsFromCurrentDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticOverviewClientListHelper } from '../helper/statistic-overview-client-list.helper';
import { StatisticPaymentListHelper } from '../helper/statistic-payment-list.helper';
import { StatisticSubscriptionListHelper } from '../helper/statistic-subscription-list.helper';
import { StatisticCourseListHelper } from '../request/statistic-course-list.request';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticTopCourseListREQ } from '../request/statistic-top-course-list.request';
import { StatisticOverviewClientListRESP } from '../response/statistic-overview-list.response';
import { StatisticPaymentListRESP } from '../response/statistic-payment-list.response';
import { StatisticSubscriptionListRESP, TopCourseType } from '../shared/types';

@Injectable()
export class DashboardClientService {
  private readonly logger = new Logger(DashboardClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
  ) {}

  async getOverviewStatistic(user: AuthUserDTO, query: StatisticOverviewListREQ): Promise<StatisticOverviewClientListRESP> {
    const courses = await this.transactionHost.tx.course.findMany(
      StatisticOverviewClientListHelper.toFindManyCourse(user.accountId, query),
    );
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      StatisticOverviewClientListHelper.toFindManySubscription(user.accountId, query),
    );
    const revenue = await this.transactionHost.tx.payment.findMany(
      StatisticOverviewClientListHelper.toFindManyPayment(user.accountId, query),
    );

    return {
      courseOverview: StatisticOverviewClientListHelper.getCourseOverview(courses),
      subscriptionOverview: StatisticOverviewClientListHelper.getSubscriptionOverview(subscriptions),
      revenueOverview: StatisticOverviewClientListHelper.getPaymentOverview(revenue),
    };
  }

  async getPaymentStatistic(user: AuthUserDTO, query: StatisticPaymentListREQ): Promise<StatisticPaymentListRESP[]> {
    const diffDays = getDiffDaysOfDateRange(query.dateRange);
    const numbers = Array.from({ length: diffDays + 1 }, (_, i) => i);
    const result = [];
    // Iterate over the numbers using for...of
    for (const number of numbers) {
      const beginDate = getMillisecondsFromCurrentDate({ days: number, fromBeginning: true });
      const endDate = getMillisecondsFromCurrentDate({ days: number, fromEnding: true });

      const paymentAggre = await this.transactionHost.tx.payment.aggregate(
        StatisticPaymentListHelper.toAggregateByAccountId(user.accountId, query, beginDate, endDate),
      );
      const noOfPayments = await this.transactionHost.tx.payment.count({
        where: {
          ...StatisticPaymentListHelper.toQueryPaymentCondition(query, beginDate, endDate),
          Subscription: { Course: { creatorId: user.accountId } },
        },
      });

      const value: StatisticPaymentListRESP = { totalAmount: parseDecimalNumber(paymentAggre._sum.price), noOfPayments };
      const date = getMillisecondsFromCurrentDate({ days: number });
      result.push({ [String(date)]: value });
    }

    return result;
  }

  async listSubscription(user: AuthUserDTO, query: StatisticSubscriptionListREQ): Promise<StatisticSubscriptionListRESP[]> {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      ...StatisticSubscriptionListHelper.toFindMany(query),
      where: { Course: { creatorId: user.accountId } },
    });

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
        );
      }),
    );
  }

  async getTopCourses(user: AuthUserDTO, query: StatisticTopCourseListREQ) {
    if (query.topCourseType === TopCourseType.TOP_RATE) {
      const courses = await this.transactionHost.tx.course.findMany(
        StatisticCourseListHelper.toGetTopCoursesByRate(user.accountId),
      );

      this.logger.log(' ~ DashboardClientService ~ getTopCourses ~ subscriptions:', courses);

      return courses
        .map((course) => {
          const courseRating =
            course.Subscriptions.map((sub) => sub.Feedback.courseRating).reduce((a, b) => a + b, 0) / course._count.Subscriptions;

          return {
            id: course.id,
            name: course.name,
            rate: courseRating,
          };
        })
        .sort((a, b) => b.rate - a.rate)
        .slice(0, 6);
    }

    const courses = await this.transactionHost.tx.course.findMany({
      where: { creatorId: user.accountId },
      select: {
        id: true,
        name: true,
        _count: {
          select: { Subscriptions: { where: { status: SubscriptionStatus.ENDED, ...IS_ACTIVE_NESTED } } },
        },
      },
    });

    this.logger.log(' ~ DashboardClientService ~ getTopCourses ~ subscriptions:', courses);

    return courses
      .map((course) => {
        return {
          id: course.id,
          name: course.name,
          noOfSubscription: course._count.Subscriptions,
        };
      })
      .sort((a, b) => b.noOfSubscription - a.noOfSubscription)
      .slice(0, 6);
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-overview-admin-list.helper.ts">
import {
  AccountStatus,
  Course,
  CourseStatus,
  Mentor,
  MentorStatus,
  Payment,
  Prisma,
  Report,
  ReportStatus,
  Subscription,
  SubscriptionStatus,
} from '@prisma/client';
import { StudentGetPayload } from 'src/domains/student/shared/types';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { filterByDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import {
  StatisticCourseOverviewRESP,
  StatisticMentorOverviewRESP,
  StatisticReportOverviewRESP,
  StatisticRevenueOverviewRESP,
  StatisticStudentOverviewRESP,
  StatisticSubscriptionOverviewRESP,
} from '../response/statistic-overview-list.response';

export class StatisticOverviewAdminListHelper {
  static toCountConditionQuery(query: StatisticOverviewListREQ) {
    const filterDateRange = filterByDateRange(query.dateRange);

    return { ...filterDateRange };
  }

  static toFindManyMentor(query: StatisticOverviewListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Account: { status: AccountStatus.ACTIVE, ...IS_ACTIVE_NESTED } },
      select: { status: true },
    };
  }

  // static toFindManyStudent(query: StatisticOverviewListREQ): Prisma.StudentFindManyArgs {
  //   const condition = this.toCountConditionQuery(query);

  //   return {
  //     where: { ...condition, Account: { status: AccountStatus.ACTIVE, ...IS_ACTIVE_NESTED } },
  //     select: {}
  //   };
  // }

  static toFindManyCourse(query: StatisticOverviewListREQ): Prisma.CourseFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManySubscription(query: StatisticOverviewListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManyReport(query: StatisticOverviewListREQ): Prisma.ReportFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true },
    };
  }

  static toFindManyPayment(query: StatisticOverviewListREQ): Prisma.PaymentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { status: true, price: true, refundedPrice: true },
    };
  }

  static toFindManyStudent(query: StatisticOverviewListREQ): Prisma.StudentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition },
      select: { Account: { select: { status: true } } },
    };
  }

  static getMentorOverview(mentors: Mentor[]): StatisticMentorOverviewRESP {
    const mentorOverview: StatisticMentorOverviewRESP = {
      approvedMentor: 0,
      pendingMentor: 0,
    };

    mentors.forEach((mentor) => {
      if (mentor.status === MentorStatus.ACCEPTED) {
        mentorOverview.approvedMentor++;
      } else if (mentor.status === MentorStatus.PENDING) {
        mentorOverview.pendingMentor++;
      }
      //  else if (mentor.status ===  MentorStatus.) {
      //   mentorOverview.interviewScheduledMentor++;
      // }
    });

    return mentorOverview;
  }

  static getCourseOverview(courses: Course[]): StatisticCourseOverviewRESP {
    const courseOverview: StatisticCourseOverviewRESP = {
      approvedCourse: 0,
      pendingCourse: 0,
      suspendedCourse: 0,
    };

    courses.forEach((course) => {
      if (course.status === CourseStatus.APPROVED) {
        courseOverview.approvedCourse++;
      } else if (course.status === CourseStatus.PENDING) {
        courseOverview.pendingCourse++;
      } else if (course.status === CourseStatus.SUSPENDED) {
        courseOverview.suspendedCourse++;
      }
    });

    return courseOverview;
  }

  static getSubscriptionOverview(subscriptions: Subscription[]): StatisticSubscriptionOverviewRESP {
    const subscriptionOverview: StatisticSubscriptionOverviewRESP = {
      activeSubscription: 0,
      pendingSubscription: 0,
      expiredSubscription: 0,
      cancelledSubscription: 0,
    };

    subscriptions.forEach((subscription) => {
      if (subscription.status === SubscriptionStatus.ACTIVE) {
        subscriptionOverview.activeSubscription++;
      } else if (subscription.status === SubscriptionStatus.PENDING) {
        subscriptionOverview.pendingSubscription++;
      } else if (subscription.status === SubscriptionStatus.EXPIRED) {
        subscriptionOverview.expiredSubscription++;
      } else if (subscription.status === SubscriptionStatus.CANCELED) {
        subscriptionOverview.cancelledSubscription++;
      }
    });

    return subscriptionOverview;
  }

  static getReportOverview(reports: Report[]): StatisticReportOverviewRESP {
    const reportOverview: StatisticReportOverviewRESP = {
      pendingReport: 0,
      resolvedReport: 0,
    };

    reports.forEach((report) => {
      if (report.status === ReportStatus.PENDING) {
        reportOverview.pendingReport++;
      } else if (report.status === ReportStatus.RESOLVED) {
        reportOverview.resolvedReport++;
      }
    });

    return reportOverview;
  }

  static getPaymentOverview(payments: Payment[]): StatisticRevenueOverviewRESP {
    const paymentOverview: StatisticRevenueOverviewRESP = {
      totalRevenue: 0,
      refundAmount: 0,
    };

    return payments.reduce((acc, payment) => {
      const revenue = parseDecimalNumber(payment.price) - parseDecimalNumber(payment.refundedPrice ?? 0);
      const refundAmount = parseDecimalNumber(payment.refundedPrice);

      return { totalRevenue: acc.totalRevenue + revenue, refundAmount: acc.refundAmount + refundAmount };
    }, paymentOverview);
  }

  static getStudentOverview(students: StudentGetPayload[]): StatisticStudentOverviewRESP {
    const studentOverview: StatisticStudentOverviewRESP = {
      activeStudent: 0,
      suspendedStudent: 0,
    };

    students.forEach((student) => {
      if (student.Account.status === AccountStatus.ACTIVE) {
        studentOverview.activeStudent++;
      } else if (student.Account.status === AccountStatus.SUSPENSIVE) {
        studentOverview.suspendedStudent++;
      }
    });

    return studentOverview;
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-overview-client-list.helper.ts">
import { Course, CourseStatus, Payment, Prisma, Subscription, SubscriptionStatus } from '@prisma/client';
import { filterByDateRange } from 'src/shared/helpers/date-range.helper';
import { parseDecimalNumber } from 'src/shared/parsers/common.parser';
import { StatisticOverviewListREQ } from '../request/statistic-overview-list.request';
import {
  StatisticCourseOverviewRESP,
  StatisticRevenueOverviewRESP,
  StatisticSubscriptionOverviewRESP,
} from '../response/statistic-overview-list.response';

export class StatisticOverviewClientListHelper {
  static toCountConditionQuery(query: StatisticOverviewListREQ) {
    const filterDateRange = filterByDateRange(query.dateRange);

    return { ...filterDateRange };
  }

  static toFindManyCourse(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.CourseFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, creatorId: mentorAccountId },
      select: { status: true },
    };
  }

  static toFindManySubscription(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Course: { creatorId: mentorAccountId } },
      select: { status: true },
    };
  }

  static toFindManyPayment(mentorAccountId: number, query: StatisticOverviewListREQ): Prisma.PaymentFindManyArgs {
    const condition = this.toCountConditionQuery(query);

    return {
      where: { ...condition, Subscription: { Course: { creatorId: mentorAccountId } } },
      select: { status: true, price: true, refundedPrice: true },
    };
  }

  static getCourseOverview(courses: Course[]): StatisticCourseOverviewRESP {
    const courseOverview: StatisticCourseOverviewRESP = {
      approvedCourse: 0,
      pendingCourse: 0,
      suspendedCourse: 0,
    };

    courses.forEach((course) => {
      if (course.status === CourseStatus.APPROVED) {
        courseOverview.approvedCourse++;
      } else if (course.status === CourseStatus.PENDING) {
        courseOverview.pendingCourse++;
      } else if (course.status === CourseStatus.SUSPENDED) {
        courseOverview.suspendedCourse++;
      }
    });

    return courseOverview;
  }

  static getSubscriptionOverview(subscriptions: Subscription[]): StatisticSubscriptionOverviewRESP {
    const subscriptionOverview: StatisticSubscriptionOverviewRESP = {
      activeSubscription: 0,
      pendingSubscription: 0,
      expiredSubscription: 0,
      cancelledSubscription: 0,
    };

    subscriptions.forEach((subscription) => {
      if (subscription.status === SubscriptionStatus.ACTIVE) {
        subscriptionOverview.activeSubscription++;
      } else if (subscription.status === SubscriptionStatus.PENDING) {
        subscriptionOverview.pendingSubscription++;
      } else if (subscription.status === SubscriptionStatus.EXPIRED) {
        subscriptionOverview.expiredSubscription++;
      } else if (subscription.status === SubscriptionStatus.CANCELED) {
        subscriptionOverview.cancelledSubscription++;
      }
    });

    return subscriptionOverview;
  }

  static getPaymentOverview(payments: Payment[]): StatisticRevenueOverviewRESP {
    const paymentOverview: StatisticRevenueOverviewRESP = {
      totalRevenue: 0,
      refundAmount: 0,
    };

    return payments.reduce((acc, payment) => {
      const revenue = parseDecimalNumber(payment.price) - parseDecimalNumber(payment.refundedPrice ?? 0);
      const refundAmount = parseDecimalNumber(payment.refundedPrice);

      return { totalRevenue: acc.totalRevenue + revenue, refundAmount: acc.refundAmount + refundAmount };
    }, paymentOverview);
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-payment-list.helper.ts">
import { PaymentStatus, Prisma } from '@prisma/client';
import { StatisticPaymentListREQ } from '../request/statistic-payment-list.request';

export class StatisticPaymentListHelper {
  static toQueryPaymentCondition(query: StatisticPaymentListREQ, beginDate: number, endDate: number): Prisma.PaymentWhereInput {
    const paymentStatus = !!query.status ? query.status : PaymentStatus.DONE;

    return {
      status: paymentStatus,
      AND: [{ createdAt: { gte: beginDate } }, { createdAt: { lte: endDate } }],
    };
  }

  static toAggregate(query: StatisticPaymentListREQ, beginDate: number, endDate: number): Prisma.PaymentAggregateArgs {
    const condition = this.toQueryPaymentCondition(query, beginDate, endDate);

    return {
      where: condition,
      _sum: { price: true },
    };
  }

  static toAggregateByAccountId(
    accountId: number,
    query: StatisticPaymentListREQ,
    beginDate: number,
    endDate: number,
  ): Prisma.PaymentAggregateArgs {
    const condition = this.toQueryPaymentCondition(query, beginDate, endDate);

    return {
      where: { ...condition, Subscription: { Course: { creatorId: accountId } } },
      _sum: { price: true },
    };
  }
}
</file>

<file path="src/domains/dashboard/helper/statistic-subscription-list.helper.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { SubscriptionGetPlayload, SubscriptionMentorListRESP } from 'src/domains/subscription/shared/types';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { StatisticSubscriptionListREQ } from '../request/statistic-subscription-list.request';
import { StatisticSubscriptionListRESP } from '../shared/types';

export class StatisticSubscriptionListHelper {
  static toFindMany(query: StatisticSubscriptionListREQ): Prisma.SubscriptionFindManyArgs {
    return {
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static fromEntity(
    e: SubscriptionGetPlayload,
    studentInfo: AccountRESP,
    mentorInfo?: SubscriptionMentorListRESP,
  ): StatisticSubscriptionListRESP {
    return {
      id: e.id,
      status: e.status,
      originalPrice: parseDecimalNumber(e.originalPrice),
      courseStartAt: parseEpoch(e.courseAccessStartAt),
      courseEndAt: parseEpoch(e.courseAccessEndAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      course: { id: e.Course.id, name: e.Course.name },
      payment: orNullWithCondition(!!e.Payment, {
        id: e.Payment?.id,
        status: e.Payment?.status,
        price: parseDecimalNumber(e.Payment?.price),
      }),
    };
  }
}
</file>

<file path="src/domains/dashboard/request/statistic-base-list.request.ts">
import { IsEnum } from 'class-validator';
import { DateRangeFilter } from 'src/shared/enums/common.enum';

export class StatisticBaseListREQ {
  @IsEnum(DateRangeFilter)
  dateRange: DateRangeFilter = DateRangeFilter.ALL;
}
</file>

<file path="src/domains/dashboard/request/statistic-course-list.request.ts">
import { SubscriptionStatus } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class StatisticCourseListHelper {
  static toGetTopCoursesByRate(accountId: number) {
    return {
      where: {
        creatorId: accountId,
        Subscriptions: { some: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED } },
      },
      select: {
        id: true,
        name: true,
        Subscriptions: {
          where: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED },
          select: { id: true, Feedback: { select: { courseRating: true } } },
        },
        _count: {
          select: {
            Subscriptions: { where: { status: SubscriptionStatus.ENDED, Feedback: { isNot: null }, ...IS_ACTIVE_NESTED } },
          },
        },
      },
    };
  }
}
</file>

<file path="src/domains/dashboard/request/statistic-overview-list.request.ts">
import { StatisticBaseListREQ } from './statistic-base-list.request';

export class StatisticOverviewListREQ extends StatisticBaseListREQ {}
</file>

<file path="src/domains/dashboard/request/statistic-payment-list.request.ts">
import { PaymentStatus } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { StatisticPaymentStatus } from 'src/shared/constants/dashboard.constant';
import { StatisticBaseListREQ } from './statistic-base-list.request';

export class StatisticPaymentListREQ extends StatisticBaseListREQ {
  @IsEnum(StatisticPaymentStatus)
  @IsOptional()
  status?: PaymentStatus;
}
</file>

<file path="src/domains/dashboard/request/statistic-subscription-list.request.ts">
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class StatisticSubscriptionListREQ extends PaginationREQ {}
</file>

<file path="src/domains/dashboard/request/statistic-top-course-list.request.ts">
import { IsEnum } from 'class-validator';
import { TopCourseType } from '../shared/types';
import { StatisticOverviewListREQ } from './statistic-overview-list.request';

export class StatisticTopCourseListREQ extends StatisticOverviewListREQ {
  @IsEnum(TopCourseType)
  topCourseType: TopCourseType;
}
</file>

<file path="src/domains/dashboard/response/statistic-overview-list.response.ts">
export class StatisticMentorOverviewRESP {
  approvedMentor: number;
  pendingMentor: number;
}

export class StatisticCourseOverviewRESP {
  approvedCourse: number;
  pendingCourse: number;
  suspendedCourse: number;
}

export class StatisticReportOverviewRESP {
  pendingReport: number;
  resolvedReport: number;
}

export class StatisticSubscriptionOverviewRESP {
  activeSubscription: number;
  pendingSubscription: number;
  expiredSubscription: number;
  cancelledSubscription: number;
}

export class StatisticRevenueOverviewRESP {
  totalRevenue: number;
  refundAmount: number;
}

export class StatisticStudentOverviewRESP {
  activeStudent: number;
  suspendedStudent: number;
}

export class StatisticOverviewListRESP {
  mentorOverview: StatisticMentorOverviewRESP;
  courseOverview: StatisticCourseOverviewRESP;
  reportOverview: StatisticReportOverviewRESP;
  subscriptionOverview: StatisticSubscriptionOverviewRESP;
  revenueOverview: StatisticRevenueOverviewRESP;
  studentOverview: StatisticStudentOverviewRESP;
}

export class StatisticOverviewClientListRESP {
  courseOverview: StatisticCourseOverviewRESP;
  subscriptionOverview: StatisticSubscriptionOverviewRESP;
  revenueOverview: StatisticRevenueOverviewRESP;
}
</file>

<file path="src/domains/dashboard/response/statistic-payment-list.response.ts">
export class StatisticPaymentListRESP {
  totalAmount: number;
  noOfPayments: number;
}
</file>

<file path="src/domains/dashboard/shared/types.ts">
import { SubscriptionListRESP } from 'src/domains/subscription/dto/response/subscription-list.response';

export type StatisticSubscriptionListRESP = Omit<
  SubscriptionListRESP,
  'audiCall' | 'feedback' | 'report' | 'canceledAt' | 'approvedAt' | 'rejectedAt'
>;

export type CourseTopRates = {
  courseId: number;
  courseName: string;
  avgRate?: number;
  noOfSubscription?: number;
};

export enum TopCourseType {
  TOP_RATE = 'TOP_RATE',
  TOP_NUMBER_OF_SUBSCRIPTION = 'TOP_NUMBER_OF_SUBSCRIPTION',
}
</file>

<file path="src/domains/dashboard/dashboard.controller.ts">
import { Controller } from '@nestjs/common';
import { DashboardService } from './dashboard.service';

@Controller('dashboard')
export class DashboardController {
  constructor(private readonly dashboardService: DashboardService) {}
}
</file>

<file path="src/domains/dashboard/dashboard.module.ts">
import { Module } from '@nestjs/common';
import { DashboardAdminModule } from './admin/dashboard-admin.module';
import { DashboardClientModule } from './client/dashboard-client.module';
import { DashboardController } from './dashboard.controller';
import { DashboardService } from './dashboard.service';

@Module({
  controllers: [DashboardController],
  providers: [DashboardService],
  imports: [DashboardAdminModule, DashboardClientModule],
})
export class DashboardModule {}
</file>

<file path="src/domains/dashboard/dashboard.service.ts">
import { Injectable } from '@nestjs/common';

@Injectable()
export class DashboardService {}
</file>

<file path="src/domains/feedback/admin/feedback-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackAdminController } from './feedback-admin.controller';
import { FeedbackAdminService } from './feedback-admin.service';

describe('FeedbackAdminController', () => {
  let controller: FeedbackAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FeedbackAdminController],
      providers: [FeedbackAdminService],
    }).compile();

    controller = module.get<FeedbackAdminController>(FeedbackAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/admin/feedback-admin.controller.ts">
import { Controller, Get, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackAdminService } from './feedback-admin.service';

@Controller('admin/feedbacks')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class FeedbackAdminController {
  constructor(private readonly feedbackAdminService: FeedbackAdminService) {}

  @Get('relations')
  async listFeedbackByRelationId(@Query() query: FeedbackListREQ) {
    const data = await this.feedbackAdminService.listByRelation(query);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }
}
</file>

<file path="src/domains/feedback/admin/feedback-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { FeedbackAdminController } from './feedback-admin.controller';
import { FeedbackAdminService } from './feedback-admin.service';

@Module({
  imports: [AccountModule],
  controllers: [FeedbackAdminController],
  providers: [FeedbackAdminService],
})
export class FeedbackAdminModule {}
</file>

<file path="src/domains/feedback/admin/feedback-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackAdminService } from './feedback-admin.service';

describe('FeedbackAdminService', () => {
  let service: FeedbackAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FeedbackAdminService],
    }).compile();

    service = module.get<FeedbackAdminService>(FeedbackAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/admin/feedback-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { FeedbackListHelper } from '../helper/feedback-list.helper';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackGetPayload } from '../shared/type';

@Injectable()
export class FeedbackAdminService {
  private readonly logger: Logger = new Logger(FeedbackAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountSevice: AccountService,
  ) {}

  async listByRelation(query: FeedbackListREQ) {
    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.toFindMany(query));
    const count = await this.transactionHost.tx.feedback.count({ where: FeedbackListHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  async listAllFeedback(query) {}
}
</file>

<file path="src/domains/feedback/client/feedback-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackClientController } from './feedback-client.controller';
import { FeedbackClientService } from './feedback-client.service';

describe('FeedbackClientController', () => {
  let controller: FeedbackClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FeedbackClientController],
      providers: [FeedbackClientService],
    }).compile();

    controller = module.get<FeedbackClientController>(FeedbackClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/client/feedback-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Post, Put, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { FeedbackCreateREQ } from '../request/feedback-create.request';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';
import { FeedbackClientService } from './feedback-client.service';

@Controller('client/feedbacks')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class FeedbackClientController {
  constructor(private readonly feedbackClientService: FeedbackClientService) {}

  @Get()
  @Public()
  async listFeedback(@Query() query: FeedbackListREQ) {
    const data = await this.feedbackClientService.list(query);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }

  @Post()
  @Roles(AccountType.STUDENT)
  async createFeedback(@Req() req: AuthRequestDTO, @Body() body: FeedbackCreateREQ) {
    const feedback = await this.feedbackClientService.create(req.user.accountId, body);

    return BaseResponse.of(feedback);
  }

  @Put(':id')
  @Roles(AccountType.STUDENT)
  async updateFeedback(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number, @Body() body: FeedbackUpdateREQ) {
    const feedback = await this.feedbackClientService.update(req.user.accountId, id, body);

    return BaseResponse.of(feedback);
  }

  @Delete(':id')
  @Roles(AccountType.STUDENT)
  async delete(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.feedbackClientService.delete(req.user.accountId, id);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/domains/feedback/client/feedback-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { FeedbackClientController } from './feedback-client.controller';
import { FeedbackClientService } from './feedback-client.service';

@Module({
  imports: [AccountModule],
  controllers: [FeedbackClientController],
  providers: [FeedbackClientService],
  exports: [FeedbackClientService],
})
export class FeedbackClientModule {}
</file>

<file path="src/domains/feedback/client/feedback-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FeedbackClientService } from './feedback-client.service';

describe('FeedbackClientService', () => {
  let service: FeedbackClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FeedbackClientService],
    }).compile();

    service = module.get<FeedbackClientService>(FeedbackClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/feedback/client/feedback-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { FeedbackCreateHelper } from '../helper/feedback-create.helper';
import { FeedbackListHelper } from '../helper/feedback-list.helper';
import { FeedbackUpdateHelper } from '../helper/feedback-update.helper';
import { FeedbackCreateREQ } from '../request/feedback-create.request';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';
import { FeedbackGetPayload } from '../shared/type';

@Injectable()
export class FeedbackClientService {
  private readonly logger: Logger = new Logger(FeedbackClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountSevice: AccountService,
  ) {}

  async list(query: FeedbackListREQ) {
    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.toFindMany(query));
    const count = await this.transactionHost.tx.feedback.count({ where: FeedbackListHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  async listFeedbackByMentorId(mentorId: number) {
    const mentor = await this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { id: mentorId },
      select: { accountId: true },
    });

    const feedbacks = await this.transactionHost.tx.feedback.findMany(FeedbackListHelper.findManyByAccountId(mentor.accountId));
    const count = await this.transactionHost.tx.feedback.count({
      where: { Subscription: { Course: { Creator: { id: mentor.accountId } } } },
    });

    const dtos = await Promise.all(
      feedbacks.map(async (feedback: FeedbackGetPayload) => {
        const reviewer = await this.accountSevice.getMe(feedback.reviewerId);

        return FeedbackListHelper.fromEntity(feedback, {
          id: reviewer.account.id,
          name: reviewer.account.name,
          thumbnail: reviewer.thumbnail,
        });
      }),
    );

    return { dtos, count };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(reviewerId: number, body: FeedbackCreateREQ) {
    const feedback = await this.findBySubscriptionId(body.subscriptionId);
    if (feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_ALREADY_EXISTS);

    const subscription = await this.transactionHost.tx.subscription.findUnique({
      where: { id: body.subscriptionId },
      select: { accountId: true },
    });

    if (!subscription && subscription.accountId !== reviewerId)
      throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_ENOUGH_PERMISSION);

    // Ensure the student is subscribed to the course or mentor
    return this.transactionHost.tx.feedback.create(FeedbackCreateHelper.toCreate(reviewerId, body));
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(reviewerId: number, feedbackId: number, body: FeedbackUpdateREQ) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, reviewerId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);

    if (feedback.reviewerId !== reviewerId) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);

    return this.transactionHost.tx.feedback.update(FeedbackUpdateHelper.toUpdate(feedback.id, body));
  }

  async findBySubscriptionId(subscriptionId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { subscriptionId },
      select: { id: true, reviewerId: true },
    });

    return feedback;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async delete(reviewerId: number, feedbackId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, reviewerId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);

    if (feedback.reviewerId !== reviewerId) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);

    return this.transactionHost.tx.feedback.delete({ where: { id: feedbackId } });
  }

  async requestReviewModeration(feedbackId: number) {
    const feedback = await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, subscriptionId: true },
    });

    if (!feedback) throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_FOUND);
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-create.helper.ts">
import { Prisma } from '@prisma/client';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { FeedbackCreateREQ } from '../request/feedback-create.request';

export class FeedbackCreateHelper {
  static toCreate(reviewerId: number, body: FeedbackCreateREQ): Prisma.FeedbackCreateArgs {
    return {
      data: {
        courseRating: body.courseRating,
        mentorRating: body.mentorRating,
        courseReview: body.courseReview,
        mentorReview: body.mentorReview,
        Reviewer: connectRelation(reviewerId),
        Subscription: connectRelation(body.subscriptionId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-list.helper.ts">
import { Prisma } from '@prisma/client';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { FeedbackListREQ } from '../request/feedback-list.request';
import { FeedbackListRESP } from '../response/feedback-list.response';
import { FeedbackGetPayload, FeedbackRelation, ReviewerAccount } from '../shared/type';

export class FeedbackListHelper {
  static toQueryCondition(query: FeedbackListREQ): Prisma.FeedbackFindManyArgs['where'] {
    const relation =
      query.relationType === FeedbackRelation.COURSE
        ? {
            Subscription: {
              courseId: query.relationId,
            },
          }
        : {
            Subscription: {
              Course: { Creator: { Mentors: { some: { id: query.relationId } } } },
            },
          };

    return { ...relation };
  }

  static toFindMany(query: FeedbackListREQ): Prisma.FeedbackFindManyArgs {
    const condition = FeedbackListHelper.toQueryCondition(query);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        reviewerId: true,
        courseRating: true,
        mentorRating: true,
        courseReview: true,
        mentorReview: true,
        subscriptionId: true,
        Report: { select: { id: true, type: true, description: true, status: true, resolution: true } },
        updatedAt: true,
      },
    };
  }

  static findManyByAccountId(accountId: number): Prisma.FeedbackFindManyArgs {
    return {
      where: {
        Subscription: { Course: { Creator: { id: accountId } } },
      },

      select: {
        id: true,
        reviewerId: true,
        courseRating: true,
        mentorRating: true,
        courseReview: true,
        mentorReview: true,
        subscriptionId: true,
        updatedAt: true,
      },
    };
  }

  static fromEntity(e: FeedbackGetPayload, account: ReviewerAccount): FeedbackListRESP {
    return {
      id: e.id,
      subscriptionId: e.subscriptionId,
      courseRating: e.courseRating,
      mentorRating: e.mentorRating,
      courseReview: e.courseReview,
      mentorReview: e.mentorReview,
      reviewer: account,
      updatedAt: parseEpoch(e.updatedAt),
      report: orNullWithCondition(!!e.Report, {
        id: e.Report?.id,
        type: e.Report?.type,
        description: e.Report?.description,
        status: e.Report?.status,
        resolution: e.Report?.resolution,
      }),
    };
  }
}
</file>

<file path="src/domains/feedback/helper/feedback-update.helper.ts">
import { Prisma } from '@prisma/client';
import { FeedbackUpdateREQ } from '../request/feedback-update.request';

export class FeedbackUpdateHelper {
  static toUpdate(feedbackId: number, body: FeedbackUpdateREQ): Prisma.FeedbackUpdateArgs {
    return {
      where: { id: feedbackId },
      data: {
        courseRating: body.courseRating,
        mentorRating: body.mentorRating,
        courseReview: body.courseReview,
        mentorReview: body.mentorReview,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/feedback/request/feedback-create.request.ts">
import { IsNumber, IsOptional, IsString, Max, Min } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class FeedbackCreateREQ {
  @Min(1)
  @Max(5)
  @IsNumber()
  mentorRating: number;

  @IsNumber()
  @Min(1)
  @Max(5)
  courseRating: number;

  @IdValidator()
  subscriptionId: number;

  @IsString()
  @IsOptional()
  courseReview?: string;

  @IsString()
  @IsOptional()
  mentorReview?: string;
}
</file>

<file path="src/domains/feedback/request/feedback-list.request.ts">
import { Transform } from 'class-transformer';
import { IsEnum } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { FeedbackRelation } from '../shared/type';

export class FeedbackListREQ extends PaginationREQ {
  @IdValidator()
  @Transform(({ value }) => value && parseInt(value))
  relationId: number;

  @IsEnum(FeedbackRelation)
  relationType: FeedbackRelation;
}
</file>

<file path="src/domains/feedback/request/feedback-update.request.ts">
import { PartialType, PickType } from '@nestjs/swagger';
import { FeedbackCreateREQ } from './feedback-create.request';

export class FeedbackUpdateREQ extends PartialType(
  PickType(FeedbackCreateREQ, ['courseRating', 'mentorRating', 'courseReview', 'mentorReview']),
) {}
</file>

<file path="src/domains/feedback/response/feedback-list.response.ts">
import { FeedbackReportRESP, ReviewerAccount } from '../shared/type';

export class FeedbackListRESP {
  id: number;
  courseRating: number;
  mentorRating: number;
  courseReview: string;
  mentorReview: string;
  subscriptionId: number;
  updatedAt: string;
  reviewer: ReviewerAccount;
  report?: FeedbackReportRESP;
}
</file>

<file path="src/domains/feedback/shared/type.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { ReportDetailRESP } from 'src/domains/report/response/report-detail.response';

export type ReviewerAccount = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;

export type FeedbackGetPayload = Prisma.FeedbackGetPayload<{
  include: { Subscription: true; Reviewer: true; Report: true };
}>;

export enum FeedbackRelation {
  COURSE = 'COURSE',
  MENTOR = 'MENTOR',
}

export type FeedbackReportRESP = Pick<ReportDetailRESP, 'id' | 'type' | 'description' | 'status' | 'resolution'>;
</file>

<file path="src/domains/feedback/feedback.module.ts">
import { Module } from '@nestjs/common';
import { FeedbackAdminModule } from './admin/feedback-admin.module';
import { FeedbackClientModule } from './client/feedback-client.module';

@Module({
  imports: [FeedbackClientModule, FeedbackAdminModule],
})
export class FeedbackModule {}
</file>

<file path="src/domains/file/dto/file-link.dto.ts">
import { Prisma } from '@prisma/client';

export class FileLinkDTO {
  static fileSelect(): Prisma.FileSelect {
    return {
      ImageVersions: { select: { id: true } },
      Categories: { select: { id: true } },
      CourseImages: { select: { id: true } },
      SectionAttachments: { select: { fileId: true } },
    };
  }

  static isLinked(
    e: Prisma.FileGetPayload<{
      include: { ImageVersions: true; Categories: true; AccountAvatars: true; CourseImages: true; SectionAttachments: true };
    }>,
  ) {
    return (
      e.ImageVersions?.length > 0 ||
      e.Categories?.length > 0 ||
      e.AccountAvatars?.length > 0 ||
      e.CourseImages?.length > 0 ||
      e.SectionAttachments?.length > 0
    );
  }
}
</file>

<file path="src/domains/file/request/file-create.request.ts">
import { Prisma } from '@prisma/client';
import { IsNumber, IsOptional } from 'class-validator';
import { UploadApiResponse } from 'cloudinary';
import { SharpOptions } from 'sharp';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ISharpInputOptions } from 'src/services/storage/shared/interfaces/sharp.interface';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class FileCreateREQ implements ISharpInputOptions {
  @IsNumber()
  @IsOptional()
  width?: number;

  @IsNumber()
  @IsOptional()
  height?: number;

  @IsOptional()
  options?: SharpOptions;

  static toSharpOptions(body: FileCreateREQ): ISharpInputOptions {
    return {
      width: body.width,
      height: body.height,
      options: body.options,
    };
  }

  static fromCLDApiResponse(user: AuthUserDTO, body: UploadApiResponse): Prisma.FileCreateInput {
    return {
      publicId: body.public_id,
      size: body.bytes,
      url: body.secure_url,
      version: body.version,
      resourceType: body.resource_type,
      signature: body.signature,
      uploadedAt: new Date(body.created_at).getMilliseconds(),
      Registrant: connectRelation(user?.accountId),
    };
  }
}
</file>

<file path="src/domains/file/request/file-upload-signed-url.request.ts">
import { Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { ResourceType } from 'cloudinary';
import { CLD_FOLDER } from 'src/shared/constants/storage.constant';
import { NameValidator } from 'src/shared/request-validator/account.validator';

export class FileUploadSignedUrlREQ {
  @NameValidator()
  fileName: string;

  @IsString()
  resourceType: ResourceType;

  @IsEnum(CLD_FOLDER)
  folder: CLD_FOLDER;

  @IsString()
  @IsOptional()
  imageType?: string;

  @IsOptional()
  eager?: string;

  static fromSignedUrl(body: FileUploadSignedUrlREQ, result: any): Prisma.FileCreateInput {
    return {
      filename: body.fileName,
      publicId: result.publicId,
      url: result.url,
      resourceType: body.resourceType,
      signature: result.signature,
      uploadedAt: new Date().getTime(),
    };
  }
}
</file>

<file path="src/domains/file/response/file-create.response.ts">
import { Prisma } from '@prisma/client';

export class FileCreateRESP {
  fileId: number;
  url: string;

  static fromEntity(e: Prisma.FileGetPayload<unknown>, url: string): FileCreateRESP {
    return { fileId: e.id, url };
  }
}
</file>

<file path="src/domains/file/response/file.response.ts">
import { Prisma } from '@prisma/client';
import { StorageDTO } from 'src/services/storage/dto/storage.dto';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNull } from 'src/shared/parsers/io.parser';

export class FileRESP {
  fileId: number;
  fileName: string;
  fileSize: number | null;
  url: string;
  createdAt: number;
  registrant: { id: number; email: string };

  static querySelect(): Prisma.FileSelect {
    return {
      id: true,
      publicId: true,
      size: true,
      createdAt: true,
      Registrant: { select: { id: true, email: true } },
    };
  }

  static fromEntity(e: Prisma.FileGetPayload<{ include: { Registrant: true } }>, storage: StorageDTO): FileRESP {
    return {
      fileId: e.id,
      fileName: e.filename,
      fileSize: orNull(storage?.size),
      url: orNull(storage?.url),
      createdAt: parseEpoch(e.createdAt),
      registrant: { id: e.Registrant?.id, email: e.Registrant?.email },
    };
  }
}
</file>

<file path="src/domains/file/file.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FileController } from './file.controller';
import { FileService } from './file.service';

describe('FileController', () => {
  let controller: FileController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [FileController],
      providers: [FileService],
    }).compile();

    controller = module.get<FileController>(FileController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/file/file.controller.ts">
import { Body, Controller, Post, Req, UploadedFile, UseGuards, UseInterceptors } from '@nestjs/common';
import { FileInterceptor } from '@nestjs/platform-express';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { Public } from '../auth/auth-public.decorator';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { FileService } from './file.service';
import { FileUploadSignedUrlREQ } from './request/file-upload-signed-url.request';

@Controller('files')
@UseGuards(AuthJwtGuard)
export class FileController {
  constructor(private readonly fileService: FileService) {}

  @Post()
  @Public()
  @UseInterceptors(FileInterceptor('file'))
  async upload(@Req() req: AuthRequestDTO, @UploadedFile() file: Express.Multer.File) {
    const asset = await this.fileService.uploadFile(req.user, file, req.body);

    return BaseResponse.of(asset);
  }

  @Public()
  @Post('signed-url')
  async createSignedUrl(@Body() body: FileUploadSignedUrlREQ) {
    const response = await this.fileService.createSignedFile(body);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/file/file.module.ts">
import { Global, Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { FileController } from './file.controller';
import { FileService } from './file.service';

@Global()
@Module({
  imports: [CommonModule],
  controllers: [FileController],
  providers: [FileService],
  exports: [FileService],
})
export class FileModule {}
</file>

<file path="src/domains/file/file.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { FileService } from './file.service';

describe('FileService', () => {
  let service: FileService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [FileService],
    }).compile();

    service = module.get<FileService>(FileService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/file/file.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import { PrismaClientKnownRequestError } from '@prisma/client/runtime/library';
import { isEmpty, isNil } from 'lodash';
import { NODE_ENV } from 'src/app.config';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { StorageService } from 'src/services/storage/storage.service';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { CLD_UPLOAD_IMAGE_OPTIONS, IMAGE_TYPE } from 'src/shared/constants/storage.constant';
import { AssetFileNotExisted } from 'src/shared/exceptions/asset-file-not-existed.exception';
import { WriteFailedException } from 'src/shared/exceptions/write-fail-exception';
import { WriteRelationNotFoundException } from 'src/shared/exceptions/write-relation-not-found.exception';
import { Nil } from 'src/shared/generics/type.helper';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FileLinkDTO } from './dto/file-link.dto';
import { FileCreateREQ } from './request/file-create.request';
import { FileUploadSignedUrlREQ } from './request/file-upload-signed-url.request';
import { FileRESP } from './response/file.response';

@Injectable()
export class FileService {
  private readonly logger = new Logger(FileService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly storageService: StorageService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async uploadFile(user: AuthUserDTO, file: Express.Multer.File, body: FileCreateREQ) {
    try {
      const result = await this.storageService.uploadFile(file, CLD_UPLOAD_IMAGE_OPTIONS, FileCreateREQ.toSharpOptions(body));

      const asset = await this.transactionHost.tx.file.create({
        data: FileCreateREQ.fromCLDApiResponse(user, result as any),
        select: { id: true, url: true },
      });

      return asset;
    } catch (error) {
      this.logger.error(error);
      throw new Error('Failed to upload file');
    }
  }

  @Transactional()
  async createSignedFile(body: FileUploadSignedUrlREQ) {
    const imageType = body.imageType ?? IMAGE_TYPE;
    const publicId = `${body.folder}/${body.fileName}_${new Date().getTime().toString().substring(6)}`;
    const result = await this.storageService.createSignedUploadUrl(publicId, imageType, {
      folder: body.folder,
      eager: body.eager,
    });

    const file = await this.transactionHost.tx.file.create({
      data: FileUploadSignedUrlREQ.fromSignedUrl(body, result as any),
      select: { id: true, url: true },
    });

    const uploadedUrl = `${result.url}?api_key=${result.api_key}&public_id=${publicId}&timestamp=${result.timestamp}&signature=${result.signature}`;

    const resposne = { fileId: file.id, uploadedUrl };

    return resposne;
  }

  async checkFileUploaded(fileId: Nil<number>) {
    if (isNil(fileId)) return;
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id: fileId },
      select: { id: true, publicId: true },
    });
    return this.storageService.checkFileExist(file.publicId);
  }

  async detail(id: Nil<number>) {
    if (isNil(id)) return null;
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id },
      select: FileRESP.querySelect(),
    });
    return FileRESP.fromEntity(file as any, await this.storageService.getStorageFile(file.publicId));
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async enableUploaded(fileIds: number[]) {
    await this.transactionHost.tx.file.updateMany({ where: { id: { in: fileIds } }, data: { isUploaded: true } });
  }

  /* Delete file */
  async delete(id: number) {
    const file = await this.transactionHost.tx.file.findUniqueOrThrow({ where: { id }, select: { publicId: true } });
    await this.transactionHost.tx.$executeRaw`DELETE FROM files WHERE id = ${id}`;
    await this.storageService.deleteFile(file.publicId);
  }

  /* Delete multi files */
  @Transactional(TRANSACTION_TIMEOUT)
  async deleteMany(fileIds: number[]) {
    if (fileIds.length === 0) return;
    const files = await this.transactionHost.tx.file.findMany({
      where: { id: { in: fileIds } },
      select: { id: true, publicId: true },
    });

    await this.storageService.deleteManyFiles(files.map((f) => f.publicId));
    await this.transactionHost.tx.$executeRaw`DELETE FROM files WHERE id IN (${Prisma.join(fileIds)})`;
  }

  async checkFileLinked(fileIds: number[]) {
    const linkedFiles = await this.transactionHost.tx.file.findMany({
      where: { id: { in: fileIds } },
      select: FileLinkDTO.fileSelect(),
    });
    if (linkedFiles.filter((f) => FileLinkDTO.isLinked(f)).length !== 0)
      throw new WriteFailedException('update', 'These specified files had been linked already');
  }

  async checkAttachmentUploadedOrThrow(fileIds: number[]) {
    if (!fileIds || isEmpty(fileIds)) return;
    try {
      const fileUploadStatus = await this.checkManyFileUploaded(fileIds);
      //TODO: Fix rate limit
      const isAttachment = fileIds.length !== 0;
      if (isAttachment && !fileUploadStatus.isAllUploaded && NODE_ENV === 'production')
        throw new AssetFileNotExisted(fileUploadStatus.notUploadedFileIds);
    } catch (e) {
      if (e instanceof PrismaClientKnownRequestError)
        throw new WriteRelationNotFoundException('create', 'File', `File(s) not found id = ${fileIds.join(', ')}`);
      throw e;
    }
  }

  async checkManyFileUploaded(fileIds: number[]): Promise<{ isAllUploaded: boolean; notUploadedFileIds: number[] }> {
    type FileStatus = { isUploaded: boolean; id: number };
    const promises = fileIds.map(
      (id) =>
        new Promise<FileStatus>(async (res, rej) => {
          try {
            const isUploaded = await this.checkFileUploaded(id);
            res({ isUploaded, id });
          } catch (e) {
            // File not exist in database
            rej(e);
          }
        }),
    );

    const fileStatuses = await Promise.all(promises);
    const notUploadedFiles = fileStatuses.filter((f) => !f.isUploaded);
    return { isAllUploaded: notUploadedFiles.length <= 0, notUploadedFileIds: notUploadedFiles.map((f) => f.id) };
  }
}
</file>

<file path="src/domains/image/response/image-version.response.ts">
import { ImageVersionType, Prisma } from '@prisma/client';
import { StorageDTO } from 'src/services/storage/dto/storage.dto';

export class ImageVersionRESP {
  id: number;
  url: string;
  fileId: number;
  fileSize: number | null;
  width: number;
  height: number;
  type: ImageVersionType;

  static getResolution(type: ImageVersionType): { width: number; height: number } {
    switch (type) {
      case 'THUMBNAIL':
        return { width: 200, height: 200 };
      case 'MEDIUM':
        return { width: 1280, height: 720 };
      case 'LARGE':
        return { width: 1920, height: 1080 };
    }
  }

  static fromEntity(e: Prisma.ImageVersionGetPayload<{ include: { File: true } }>, storage: StorageDTO): ImageVersionRESP {
    const resolution = ImageVersionRESP.getResolution(e.type);
    return {
      id: e.id,
      url: storage.url,
      fileId: e.File.id,
      fileSize: storage.size,
      width: resolution.width,
      height: resolution.height,
      type: e.type,
    };
  }

  static mock(imageUrl: string): ImageVersionRESP[] {
    const banner = ImageVersionRESP.getResolution(ImageVersionType.LARGE);
    const thumbnail = ImageVersionRESP.getResolution(ImageVersionType.THUMBNAIL);
    return [
      {
        id: 1,
        url: imageUrl,
        fileId: 1,
        fileSize: 1000,
        width: banner.width,
        height: banner.height,
        type: ImageVersionType.LARGE,
      },
      {
        id: 2,
        url: imageUrl,
        fileId: 2,
        fileSize: 2000,
        width: thumbnail.width,
        height: thumbnail.height,
        type: ImageVersionType.THUMBNAIL,
      },
    ];
  }
}
</file>

<file path="src/domains/image/response/image.response.ts">
import { Prisma } from '@prisma/client';

import { StorageDTO } from 'src/services/storage/dto/storage.dto';
import { ImageVersionRESP } from './image-version.response';

export class ImageRESP {
  fileName: string;
  fileId: number;
  fileSize: number | null;
  originalUrl: string;
  versions: ImageVersionRESP[];

  static fromEntity(e: Prisma.FileGetPayload<unknown>, storage: StorageDTO, versions: ImageVersionRESP[]): ImageRESP {
    return {
      fileId: e.id,
      fileName: e.filename,
      fileSize: storage.size,
      originalUrl: storage.url,
      versions,
    };
  }
}
</file>

<file path="src/domains/image/image.controller.ts">
import { Controller } from '@nestjs/common';
import { ImageService } from './image.service';

@Controller('/images')
export class ImageController {
  constructor(private readonly imageService: ImageService) {}

  // @Get()
  // async list(@Query() query: CategoryListREQ) {
  //   return await this.categoryService.list(query);
  // }

  // @Get(':id')
  // async detail(@Param('id', ParseIntPipe) id: number) {
  //   return this.categoryService.detail(id);
  // }
}
</file>

<file path="src/domains/image/image.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaModule } from 'src/services/prisma/prisma.module';
import { FileModule } from '../file/file.module';
import { ImageController } from './image.controller';
import { ImageService } from './image.service';

@Module({
  imports: [FileModule, PrismaModule],
  controllers: [ImageController],
  providers: [ImageService],
  exports: [ImageService],
})
@Global()
export class ImageModule {}
</file>

<file path="src/domains/image/image.service.ts">
import { Injectable } from '@nestjs/common';

import { Prisma } from '@prisma/client';
import { isNil, isNull } from 'lodash';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { StorageService } from 'src/services/storage/storage.service';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { Nil } from 'src/shared/generics/type.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { FileService } from '../file/file.service';
import { ImageVersionRESP } from './response/image-version.response';
import { ImageRESP } from './response/image.response';

@Injectable()
export class ImageService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly fileService: FileService,
    private readonly storageService: StorageService,
  ) {}

  /* Quy trnh upload nh
    1. To entity (validate xong tt c)
    1. To nh (gm kim tra attachment  upload & file  link)
    2. To cc phin bn nh ti u
    3. Link nh vi entity
    4. Enable nh
  */

  async verifyImages(fileIds: number[]) {
    await this.fileService.checkAttachmentUploadedOrThrow(fileIds);
    // await this.fileService.checkFileLinked(fileIds);
  }

  // @Transactional(TRANSACTION_TIMEOUT)
  // async createImages(fileIds: number[]) {
  //   /* 1. Create image */
  //   const createdImageIds = [];
  //   for (const fileId of fileIds) {
  //     const image = await this.transactionHost.tx.file.create({
  //       data: ImageCreateDTO.toCreateInput(fileId),
  //       select: { id: true },
  //     });
  //     createdImageIds.push(image.id);
  //   }

  //   /* 2. Create optimized image versions */
  //   return createdImageIds;
  // }

  async getImage(imageId: Nil<number>) {
    if (isNil(imageId)) return null;
    const image = await this.transactionHost.tx.file.findUnique({
      where: { id: imageId },
      include: { ImageVersions: { include: { File: true } } },
    });
    // const versions = await Promise.all(
    //   image.ImageVersions.map(async (v) => ImageVersionRESP.fromEntity(v, await this.storageService.getStorageFile(v.File.key))),
    // );
    const storage = await this.storageService.getStorageFile(image.publicId);
    const versions = ImageVersionRESP.mock(storage.url); // Mock
    return ImageRESP.fromEntity(image, storage, versions);
  }

  async getImageOriginal(imageId: Nil<number>): Promise<ImageRESP | null> {
    if (isNil(imageId)) return null;
    const image = await this.transactionHost.tx.file.findUnique({
      where: { id: imageId },
      include: { ImageVersions: { include: { File: true } } },
    });
    const storage = await this.storageService.getStorageFile(image.publicId);
    //TODO: Handle null storage
    return isNull(storage) ? null : ImageRESP.fromEntity(image, storage, []);
  }

  async enableImages(imageIds: number[]) {
    const images = await this.transactionHost.tx.file.findMany({
      where: { id: { in: imageIds } },
      select: { id: true, ImageVersions: { select: { id: true, fileId: true } } },
    });
    if (images.length !== imageIds.length)
      throw new ActionFailedException(
        ActionFailed.IMAGE_ENABLE_QUANTITY_NOT_MATCH,
        `Image quantity not match ${imageIds.length}/${images.length}`,
      );
    const fileIds = [];
    images.forEach((image) => {
      fileIds.push(image.id, ...image.ImageVersions.map((v) => v.fileId));
    });
    await this.fileService.enableUploaded(fileIds);
  }

  async deleteImage(imageId: number) {
    const image = await this.transactionHost.tx.file.findUniqueOrThrow({
      where: { id: imageId },
      include: { ImageVersions: true },
    });
    const fileIds = [image.id, ...image.ImageVersions.map((v) => v.fileId)];

    await this.transactionHost.tx.$executeRaw`DELETE FROM image_versions WHERE file_id IN (${Prisma.join(fileIds)})`;
    await this.fileService.deleteMany(fileIds);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async linkImageToAccount(accountId: number, fileId: number) {
    console.log(' ~ ImageService ~ linkImageToAccount ~ accountId:', accountId);
    if (!fileId) return;
    /* 1. Check if attachment uploaded & create image */
    // await this.verifyImages([fileId]);

    /* 2. Remove old image */
    const account = await this.transactionHost.tx.account.findUniqueOrThrow({
      where: { id: accountId },
      select: { Avatar: { select: { id: true } } },
    });

    if (account.Avatar) await this.deleteImage(account.Avatar.id);

    /* 3. Create and link image */
    await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { Avatar: connectRelation(fileId) },
    });

    /* 4. Enable Image & File */
    await this.enableImages([fileId]);
    return fileId;
  }

  async linkImageToCourse(courseId: number, fileId: number) {
    if (!courseId) throw new ActionFailedException(ActionFailed.COURSE_NOT_FOUND);
    if (!fileId) return;

    await this.verifyImages([fileId]);

    await this.transactionHost.tx.course.update({
      where: { id: courseId },
      data: { Image: connectRelation(fileId) },
    });

    /* 4. Enable Image & File */
    await this.enableImages([fileId]);
    return fileId;
  }
}
</file>

<file path="src/domains/mentor/admin/dto/mentor-admin-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorAdminDetailDTO {
  static toFindUnique(mentorId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        accpetedAt: true,
        createdAt: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            phoneNumber: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/dto/mentor-client-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorClientDetailDTO {
  static toFindByAccountId(accountId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { accountId: accountId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindFirst(mentorId: number): Prisma.MentorFindFirstOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        isCurrent: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-approve.request.ts">
import { MentorStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class MentorAdminApproveREQ {
  @BooleanValidator()
  isApproved: boolean;

  static toApprove(id: number, body: MentorAdminApproveREQ, user: AuthUserDTO): Prisma.MentorUpdateArgs {
    return {
      where: { id },
      data: {
        status: body.isApproved ? MentorStatus.ACCEPTED : MentorStatus.REJECTED,
        Acceptant: connectRelation(user.accountId),
        accpetedAt: nowEpoch(),
      },
      select: { id: true, accountId: true },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-interview.request.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { IsString } from 'class-validator';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';

export class MentorAdminInterviewREQ {
  @IsString()
  title: string;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  static toAudioRoomCreateREQ(mentorId: number, body: MentorAdminInterviewREQ): AudioCallAdminCreateREQ {
    return {
      title: body.title,
      type: AudioRoomType.INTERVIEW,
      startsAt: body.startsAt,
      status: RoomStatus.SCHEDULED,
      members: [
        {
          accountId: mentorId,
          role: 'USER',
        },
      ],
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-list.request.ts">
import { AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorAdminListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorAdminListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorAdminListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorAdminListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        status: true,
        accpetedAt: true,
        accountId: true,
        fileId: true,
        Account: { select: { name: true, email: true, phoneNumber: true, avatarId: true } },
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-client-list.request.ts">
import { AccountStatus, AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorClientListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorClientListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorClientListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorClientListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: { ...condition, Account: { status: { not: AccountStatus.SUSPENSIVE } } },
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        accountId: true,
        Account: { select: { name: true, avatarId: true, bio: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-detail.response.ts">
import { AchievementType } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          organization: e.organization,
          description: e.description,
          position: e.position,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: e.organization,
          description: e.description,
          major: e.major,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: e.name,
          organization: e.organization,
          description: e.description,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorAdminDetailRESP {
  id: number;
  accountId: number;
  status: string;
  gender: string;
  dob: string;
  accpetedAt: string;
  createdAt: string;
  name: string;
  email: string;
  phoneNumber: string;
  cv: FileRESP;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    cv: FileRESP,
    thumbnail?: ImageRESP,
  ): MentorAdminDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      status: e.status,
      gender: e.Account.gender,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      accpetedAt: parseEpoch(e.accpetedAt),
      createdAt: parseEpoch(e.createdAt),
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      cv: cv,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-interview.response.ts">
import { AudioRoomParticipantDTO } from 'src/domains/audio-call/admin/dto/participant-dto';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { parseEpoch } from 'src/shared/parsers/common.parser';

export class MentorAdminInterviewRESP {
  creatorId: number;
  cid: string;
  startsAt: string;
  members: AudioRoomParticipantDTO[];

  static fromEntity(e: AudioRoomGetPayload, cid: string): MentorAdminInterviewRESP {
    return {
      creatorId: e.creatorId,
      cid: cid,
      startsAt: parseEpoch(e.startsAt),
      members: e.Participants.map((m) => ({
        accountId: m.accountId,
        role: m.role,
      })),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-list.response.ts">
import { MentorStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { MentorGetPayload } from '../../shared/types';

export class MentorAdminListRESP {
  id: number;
  accountId: number;
  name: string;
  email: string;
  phoneNumber: string;
  registeredAt: string;
  status: MentorStatus;
  avatar?: ImageRESP;
  cv?: FileRESP;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumnail?: ImageRESP,
    cv?: FileRESP,
  ): MentorAdminListRESP {
    return {
      id: e.id,
      status: e.status,
      accountId: e.accountId,
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      registeredAt: parseEpoch(e.createdAt),
      avatar: thumnail,
      cv: cv,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-detail.response.ts">
import { AchievementType, MentorStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  id: number;
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  isCurrent: boolean;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          position: e.position,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          major: e.major,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          id: e.id,
          name: e.name,
          organization: e.organization,
          description: e.description,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorClientDetailRESP {
  id: number;
  accountId: number;
  bio?: string;
  name: string;
  gender: string;
  dob: string;
  status: MentorStatus;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    thumbnail?: ImageRESP,
  ): MentorClientDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      gender: e.Account.gender,
      status: e.status,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      bio: e.Account.bio,
      name: e.Account.name,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorGetPayload } from '../../shared/types';

export class MentorClientListRESP {
  id: number;
  accountId: number;
  name: string;
  thumbnail?: ImageRESP;
  bio?: string;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumbnail?: ImageRESP,
  ): MentorClientListRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      name: e.Account.name,
      bio: e.Account.bio,
      thumbnail,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminController', () => {
  let controller: MentorAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorAdminController],
      providers: [MentorAdminService],
    }).compile();

    controller = module.get<MentorAdminController>(MentorAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorAdminService } from './mentor-admin.service';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminDetailRESP } from './response/mentor-admin-detail.response';
import { MentorAdminInterviewRESP } from './response/mentor-admin-interview.response';

@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
@Controller('admin/mentors')
export class MentorAdminController {
  constructor(private readonly mentorAdminService: MentorAdminService) {}

  @Get()
  async list(@Query() query: MentorAdminListREQ) {
    const response = await this.mentorAdminService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorAdminService.detail(mentorId);

    return BaseResponse.of(
      MentorAdminDetailRESP.fromEntity(response.mentor, response.achievements, response.cv, response.thumbnail),
    );
  }

  @Post(':id/audio-call')
  async interviewMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminInterviewREQ,
  ) {
    const call = await this.mentorAdminService.interviewMentor(req.user, mentorId, body);

    return BaseResponse.of(MentorAdminInterviewRESP.fromEntity(call, call.cid));
  }

  @Patch(':id/approvement')
  async approveMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminApproveREQ,
  ) {
    const call = await this.mentorAdminService.updateResultInterview(req.user, mentorId, body);

    return BaseResponse.of(call.id);
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from 'src/domains/audio-call/admin/audio-call-admin.module';
import { CommonModule } from 'src/services/common.module';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

@Module({
  imports: [CommonModule, AudioCallAdminModule],
  controllers: [MentorAdminController],
  providers: [MentorAdminService],
})
export class MentorAdminModule {}
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminService', () => {
  let service: MentorAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorAdminService],
    }).compile();

    service = module.get<MentorAdminService>(MentorAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus, NotificationRelationType, NotificationType, RoomStatus } from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminService } from 'src/domains/audio-call/admin/audio-call-admin.service';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorGetPayload } from '../shared/types';
import { MentorAdminDetailDTO } from './dto/mentor-admin-detail.dto';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminListRESP } from './response/mentor-admin-list.response';

@Injectable()
export class MentorAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly audioCallAdminService: AudioCallAdminService,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  /* API: List mentor */
  async list(query: MentorAdminListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorAdminListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorAdminListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const cv = await this.fileService.detail(mentor.fileId);

        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorAdminListRESP.fromEntity(
          mentor,
          { noOfSubscriptions, rateOfMentor: rateOfMentor._avg.mentorRating },
          thumbnail,
          cv,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorAdminDetailDTO.toFindUnique(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorAdminDetailDTO.toFindManyAchievements(mentorId),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const cv = await this.fileService.detail(mentor.fileId);
    const data = { mentor, achievements, thumbnail, cv };

    return data;
  }

  /* API: Create interview with mentor */
  async interviewMentor(user: AuthUserDTO, mentorId: number, body: MentorAdminInterviewREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, accountId: true, status: true },
    });

    if (mentor.status == MentorStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.MENTOR_INTERVIEW_ACCEPTED);
    }

    const call = (await this.audioCallAdminService.createAudioCall(
      user,
      MentorAdminInterviewREQ.toAudioRoomCreateREQ(mentor.accountId, body),
    )) as AudioRoomGetPayload;

    //generate cid
    const cid = `${new Date().getTime()}-${call.id}-${randomUUID()}`;
    await this.transactionHost.tx.audioRoom.update({
      where: { id: call.id },
      data: { cid: cid },
      select: { id: true },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: call.id, type: NotificationRelationType.AUDIO_CALL },
      mentor.accountId,
      NotificationType.AUDIO_CALL_CREATED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return { cid: cid, ...call };
  }

  /* API: Approve or Reject Mentor after interview */
  @Transactional(TRANSACTION_TIMEOUT)
  async updateResultInterview(user: AuthUserDTO, id: number, body: MentorAdminApproveREQ) {
    //1. update mentor status
    const mentor = await this.transactionHost.tx.mentor.update(MentorAdminApproveREQ.toApprove(id, body, user));

    const onGoingInterview = await this.transactionHost.tx.audioRoom.findFirst({
      where: { status: RoomStatus.ONGOING, creatorId: user.accountId, Participants: { some: { accountId: mentor.accountId } } },
      select: { id: true },
    });

    if (onGoingInterview) {
      throw new ActionFailedException(ActionFailed.MENTOR_CANNOT_UPDATE_RESULT, MentorErrorMessages.MSG01);
    }

    //2. Deletes all scheduled interviews
    await this.transactionHost.tx.audioRoom.deleteMany({
      where: { status: RoomStatus.SCHEDULED, Participants: { some: { accountId: mentor.accountId } } },
    });

    await this.transactionHost.tx.audioRoomParticipant.updateMany({
      where: { accountId: mentor.accountId, AudioRoom: { creatorId: user.accountId } },
      data: { isInCall: false, isActive: false },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: mentor.id, type: NotificationRelationType.MENTOR },
      mentor.accountId,
      body.isApproved ? NotificationType.MENTOR_APPROVED : NotificationType.MENTOR_REJECTED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return mentor;
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-create.request.ts">
import { AuthMentorAchievementREQ } from 'src/domains/auth/request/auth-mentor-register.request';

export class MentorClientAchievementCreateREQ extends AuthMentorAchievementREQ {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-update.request.ts">
import { AchievementType } from '@prisma/client';
import { IsEnum, IsOptional, IsString, MaxLength, ValidateIf } from 'class-validator';
import { isUndefined } from 'lodash';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class MentorClientAchievementUpdateREQ {
  @IdValidator()
  id: number;

  @NameValidator()
  @ValidateIf((o) => o.achievementType === AchievementType.CERTIFICATION)
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  organization?: string; // Can be company or institution or certification body

  @BooleanValidator()
  @IsOptional()
  isCurrent?: boolean;

  @IsEnum(AchievementType)
  @IsOptional()
  achievementType?: AchievementType;

  @IsString()
  @MaxLength(255)
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EXPERIENCE)
  position: string; // For experience

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EDUCATION)
  major?: string; // For education

  @OnlyDate()
  startDate?: string;

  @OnlyDate()
  @DateMonthYearCompare({ startField: 'startDate' })
  @ValidateIf((o) => !isUndefined(o.isCurrent) && o.isCurrent == false)
  endDate?: string;

  static ToUpdateByAchievementType(body: MentorClientAchievementUpdateREQ) {
    switch (body.achievementType) {
      case AchievementType.EXPERIENCE:
        return {
          organization: body.organization,
          description: body.description,
          position: body.position,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: body.organization,
          description: body.description,
          major: body.major,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: body.name,
          organization: body.organization,
          description: body.description,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-course-list.request.ts">
import { PickType } from '@nestjs/swagger';
import { CourseClientListREQ } from 'src/domains/course/factory/list/course-client-list.request';

export class MentorClientCourseListREQ extends PickType(CourseClientListREQ, ['courseStatus']) {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-create.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleCreateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toCreate(id: number, body: MentorClientScheduleCreateREQ): Prisma.MentorScheduleCreateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        Mentor: connectRelation(id),
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-list.request.ts">
import { Prisma } from '@prisma/client';

export class MentorScheduleClientListREQ {
  static toFindMany(mentorId: number): Prisma.MentorScheduleFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        dayOfWeek: true,
        startTime: true,
        endTime: true,
        Course: { select: { id: true, name: true, description: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-update.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleUpdateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toUpdate(scheduleId: number, body: MentorClientScheduleUpdateREQ): Prisma.MentorScheduleUpdateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      where: { id: scheduleId },
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-update.request.ts">
import { AccountUpdateDTO } from 'src/domains/accounts/dto/account-update.dto';

export class MentorClientUpdateREQ extends AccountUpdateDTO {}
</file>

<file path="src/domains/mentor/client/response /mentor-schedule-list.response.ts">
import { Course } from '@prisma/client';
import { MentorScheduleCourseDetail, MentorScheduleGetPayload } from '../../shared/types';

export class MentorScheduleListRESP {
  dayOfWeek: string;
  timeRanges: { id: number; startTime: string; endTime: string; course: MentorScheduleCourseDetail }[] = [];

  static fromEntity(entities: MentorScheduleGetPayload[]): MentorScheduleListRESP[] {
    const response: MentorScheduleListRESP[] = [];

    entities.forEach((entity) => {
      const existed = response.find((item) => item.dayOfWeek === entity.dayOfWeek);
      const data = {
        id: entity.id,
        startTime: entity.startTime,
        endTime: entity.endTime,
        course: this.fromEntityWithCourse(entity.Course as Course),
      };

      if (existed) {
        existed.timeRanges.push(data);
      } else {
        response.push({ dayOfWeek: entity.dayOfWeek, timeRanges: [data] });
      }
    });

    return response;
  }

  static fromEntityWithCourse(course: Course): MentorScheduleCourseDetail {
    if (!course) return null;

    return {
      id: course.id,
      name: course.name,
      description: course.description,
    };
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientController', () => {
  let controller: MentorClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorClientController],
      providers: [MentorClientService],
    }).compile();

    controller = module.get<MentorClientController>(MentorClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Put, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { FeedbackClientService } from 'src/domains/feedback/client/feedback-client.service';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Controller('client/mentors')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR)
export class MentorClientController {
  constructor(
    private readonly mentorClientService: MentorClientService,
    private readonly mentorSchduleService: MentorScheduleService,
    private readonly feedbackClientService: FeedbackClientService,
  ) {}

  @Get()
  @Public()
  async list(@Query() query: MentorClientListREQ) {
    const response = await this.mentorClientService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get('profile')
  async profile(@Req() req: AuthRequestDTO) {
    const response = await this.mentorClientService.getMentorByAccountId(req.user.accountId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Post('schedules')
  async createSchedule(@Req() req: AuthRequestDTO, @Body() body: MentorClientScheduleCreateREQ) {
    await this.mentorSchduleService.createScheduleByAccountId(req.user, body);

    return BaseResponse.ok();
  }

  @Get('schedules') async getSchedule(@Req() req: AuthRequestDTO) {
    const response = await this.mentorSchduleService.getSchedulesByAccountId(req.user.accountId);

    return BaseResponse.of(response);
  }

  @Public()
  @Get(':id/schedules')
  async getScheduleByMentorId(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorSchduleService.getSchedulesByMentorId(mentorId);

    return BaseResponse.of(response);
  }

  @Get(':mentorId/feedbacks')
  async listFeedbackByMentorId(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const data = await this.feedbackClientService.listFeedbackByMentorId(mentorId);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }

  @Put('schedules/:id') async updateSchedule(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) scheduleId: number,
    @Body() body: MentorClientScheduleUpdateREQ,
  ) {
    await this.mentorSchduleService.updateMentorSchedule(req.user, scheduleId, body);

    return BaseResponse.ok();
  }

  @Delete('schedules/:id') async deleteSchedule(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) scheduleId: number) {
    await this.mentorSchduleService.deleteScheduleById(req.user.accountId, scheduleId);

    return BaseResponse.ok();
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorClientService.detail(mentorId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Roles(AccountType.MENTOR, AccountType.STUDENT)
  @Get(':id/courses')
  async getCoursesByMentorId(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Query() query: MentorClientCourseListREQ,
  ) {
    const response = await this.mentorClientService.getCoursesByMentorId(mentorId, req.user, query);

    return BaseResponse.of(response);
  }

  @Patch(':id')
  async update(@Param('id', ParseIntPipe) mentorId: number, @Req() req: AuthRequestDTO, @Body() body: MentorClientUpdateREQ) {
    const response = await this.mentorClientService.update(mentorId, req.user, body);

    return BaseResponse.of(response.id);
  }

  @Post(':id/achievements')
  async addProfileAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementCreateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.addProfileAchievement(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Patch(':id/achievements')
  async updateAchievements(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementUpdateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.updateAchievements(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Delete(':id/achievements/:achievementId')
  async deleteAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Param('achievementId', ParseIntPipe) achievementId: number,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.deleteAchievement(mentorId, achievementId, req.user);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { CourseClientModule } from 'src/domains/course/client/course-client.module';
import { FeedbackClientModule } from 'src/domains/feedback/client/feedback-client.module';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';

@Module({
  imports: [AccountModule, CourseClientModule, FeedbackClientModule],
  controllers: [MentorClientController],
  providers: [MentorClientService, MentorScheduleService],
  exports: [MentorClientService],
})
export class MentorClientModule {}
</file>

<file path="src/domains/mentor/client/mentor-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientService', () => {
  let service: MentorClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorClientService],
    }).compile();

    service = module.get<MentorClientService>(MentorClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus } from '@prisma/client';
import { AccountService } from 'src/domains/accounts/account.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { CourseClientService } from 'src/domains/course/client/course-client.service';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientListRESP } from 'src/domains/mentor/admin/response/mentor-client-list.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountErrorMessages, MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Injectable()
export class MentorClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
    private readonly imageService: ImageService,
    private readonly courseClientService: CourseClientService,
  ) {}

  /* API: List All Mentor */
  async list(query: MentorClientListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorClientListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorClientListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorClientListRESP.fromEntity(
          mentor,
          {
            noOfSubscriptions,
            rateOfMentor: rateOfMentor._avg.mentorRating,
          },
          thumbnail,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  /* API: Update Mentor */
  async update(mentorId: number, user: AuthUserDTO, body: MentorClientUpdateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    await this.accountService.updateAccount(user, body);

    return mentor;
  }

  /* API: Update achievements by mentor id */
  async updateAchievements(mentorId: number, body: MentorClientAchievementUpdateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.MENTOR_NOT_FOUND, MentorErrorMessages.MSG04);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(body.id)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement && currentAchievement.id !== body.id) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.update({
      where: { id: body.id },
      data: MentorClientAchievementUpdateREQ.ToUpdateByAchievementType(body),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Add achievements by mentor id */
  async addProfileAchievement(mentorId: number, body: MentorClientAchievementCreateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findUnique({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.create({
      data: MentorClientAchievementCreateREQ.ToCreateByAchievementType(body, mentorId),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Delete achievements by mentor id */
  async deleteAchievement(mentorId: number, achievementId: number, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_FOUND, AccountErrorMessages.MSG01);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(achievementId)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    await this.transactionHost.tx.profileAchievement.delete({ where: { id: achievementId } });

    return { mentorId: mentor.id, achievementId };
  }

  /* API: Mentor detail by mentor id */
  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindFirst(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getCoursesByMentorId(mentorId: number, user: AuthUserDTO, query: MentorClientCourseListREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, status: true, accountId: true },
    });

    console.log(' ~ MentorClientService ~ getCoursesByMentorId ~ mentor:', mentor);

    const isOwner = mentor.accountId === user.accountId;

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    return await this.courseClientService.getAllbyCreatorId(mentor.accountId, isOwner, query as any);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-schedule.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { CourseStatus, MentorSchedule } from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { checkHourMinStartOverlap } from 'src/shared/helpers/common.helper';
import { MentorScheduleGetPayload } from '../shared/types';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorScheduleClientListREQ } from './request/mentor-client-schedule-list.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';

import { SUBSCRIPTION_ACTIVE_STATUS } from 'src/shared/constants/subscription.constant';
import { MentorScheduleListRESP } from './response /mentor-schedule-list.response';

@Injectable()
export class MentorScheduleService {
  private readonly logger = new Logger(MentorScheduleService.name);
  constructor(private readonly transactionHost: TransactionHost) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createScheduleByAccountId(user: AuthUserDTO, body: MentorClientScheduleCreateREQ): Promise<any> {
    const existedMentor = await this.findMentorByAccountId(user.accountId);

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true, status: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
          else if (course.status !== CourseStatus.APPROVED) throw new ActionFailedException(ActionFailed.COURSE_NOT_AVAILABLE);
        });
    }

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    await this.checkOverlapSchedule(existedMentor.id, body);

    const schedule = await this.transactionHost.tx.mentorSchedule.create(
      MentorClientScheduleCreateREQ.toCreate(existedMentor.id, body),
    );

    return schedule;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateMentorSchedule(
    user: AuthUserDTO,
    scheduleId: number,
    body: MentorClientScheduleUpdateREQ,
  ): Promise<MentorSchedule> {
    const existedSchedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: scheduleId, Mentor: { accountId: user.accountId } },
      select: { mentorId: true },
    });

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
        });
    }

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: user.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS }, mentorScheduleId: scheduleId },
      select: { id: true },
    });

    if (subscriptions.length > 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    const existedSchedulesExcludeCurrId = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: existedSchedule.mentorId, dayOfWeek: body.dayOfWeek, id: { not: scheduleId } },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedulesExcludeCurrId)) {
      const isOverlap = existedSchedulesExcludeCurrId.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }

    // Step 3: Update schedule
    const schedule = await this.transactionHost.tx.mentorSchedule.update(
      MentorClientScheduleUpdateREQ.toUpdate(scheduleId, body),
    );

    return schedule;
  }

  async getSchedulesByAccountId(accountId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.findMentorByAccountId(accountId);

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async getSchedulesByMentorId(mentorId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { id: mentorId },
      select: { id: true },
    });

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async deleteScheduleById(accountId: number, scheduleId: number): Promise<void> {
    const mentor = await this.findMentorByAccountId(accountId);

    const numberOfDeleted = await this.transactionHost.tx
      .$executeRaw`DELETE FROM "mentor_schedules" WHERE id = ${scheduleId} AND "mentor_id" = ${mentor.id}`;

    if (numberOfDeleted <= 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_NOT_FOUND);
  }

  private checkOneHourFromStartTime(startTime: string, endTime: string): boolean {
    const hour1 = Number(startTime.split(':')[0] ?? 0) + Number(startTime.split(':')[1] ?? 0) / 60;
    const hour2 = Number(endTime.split(':')[0] ?? 0) + Number(endTime.split(':')[1] ?? 0) / 60;

    return hour2 - hour1 >= 1;
  }

  private async findMentorByAccountId(accountId: number) {
    return this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { accountId },
      select: { id: true },
    });
  }

  private async checkOverlapSchedule(mentorId: number, body: MentorClientScheduleCreateREQ) {
    const existedSchedules = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: mentorId, dayOfWeek: body.dayOfWeek },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedules)) {
      const isOverlap = existedSchedules.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }
  }
}
</file>

<file path="src/domains/mentor/shared/enums.ts">
export enum MentorAdminListSortableFields {
  NAME = 'name',
  EMAIL = 'email',
  PHONE_NUMBER = 'phoneNumber',
  CREATED_AT = 'createdAt',
}
</file>

<file path="src/domains/mentor/shared/types.ts">
import { Prisma } from '@prisma/client';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';

export type MentorGetPayload = Prisma.MentorGetPayload<{
  include: {
    Account: true;
  };
}>;

export type MentorScheduleGetPayload = Prisma.MentorScheduleGetPayload<{
  include: {
    Course: true;
    Mentor: true;
  };
}>;

export type ProfileAchievementGetPayload = Prisma.ProfileAchievementGetPayload<unknown>;

export type MentorScheduleCourseDetail = Pick<CourseClientDetailRESP, 'id' | 'name' | 'description'>;
</file>

<file path="src/domains/mentor/mentor.module.ts">
import { Module } from '@nestjs/common';
import { MentorAdminModule } from './admin/mentor-admin.module';
import { MentorClientModule } from './client/mentor-client.module';

@Module({
  imports: [MentorClientModule, MentorAdminModule],
})
export class MentorModule {}
</file>

<file path="src/domains/notification/helper/notification-common.helper.ts">
import { NotificationRelationType, NotificationScope, NotificationType } from '@prisma/client';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { NotificationAppHandlerPayload } from '../shared/types';

type RelationData = {
  id: number;
  type: NotificationRelationType;
};

export class NotificationHelper {
  static makeAppNotificationPayload(
    relation: RelationData,
    targetAccountId: number,
    notificationType: NotificationType,
    scopes: NotificationScope[] = [NotificationScope.INDIVIDUAL],
  ): NotificationAppHandlerPayload {
    const message = getNotificationMessage(notificationType);

    return {
      notificationREQ: {
        relationId: relation.id,
        relationType: relation.type,
        type: notificationType,
        scopes: scopes,
        targetAccountId,
      },
      data: {
        title: message.title,
        topic: notificationType,
        body: message.content,
      },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-create.request.ts">
import { NotificationRelationType, NotificationScope, NotificationType, Prisma } from '@prisma/client';
import { IsArray, IsEnum, IsNumber, IsOptional } from 'class-validator';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class NotificationCreateREQ {
  @IsEnum(NotificationType)
  type: NotificationType;

  @IsEnum(NotificationRelationType)
  relationType: NotificationRelationType;

  @IdValidator()
  relationId: number;

  @IsEnum(NotificationScope)
  @IsArray()
  @IsOptional()
  scopes?: NotificationScope[];

  @IsNumber()
  @IsOptional()
  targetAccountId?: number;

  static toCreateNotification(body: NotificationCreateREQ): Prisma.NotificationCreateArgs {
    return {
      data: {
        type: body.type,
        scopes: body.scopes,
        relationType: body.relationType,
        relationId: body.relationId,
        title: getNotificationMessage(body.type).title,
        content: getNotificationMessage(body.type).content,
        TargetAccount: connectRelation(body.targetAccountId),
      },
      select: { id: true, targetAccountId: true },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-list.request.ts">
import { NotificationScope, Prisma } from '@prisma/client';
import { IsOptional } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class NotificationListREQ extends PaginationREQ {
  @BooleanValidator()
  @IsOptional()
  isRead?: boolean;

  static toQueryCondition(user: AuthUserDTO, query: NotificationListREQ): Prisma.NotificationWhereInput {
    return {
      isRead: query.isRead,
      OR: [
        { scopes: { has: NotificationScope.INDIVIDUAL }, targetAccountId: user.accountId },
        { scopes: { has: NotificationScope.ALL } },
      ],
    };
  }
  static toFindMany(user: AuthUserDTO, query: NotificationListREQ): Prisma.NotificationFindManyArgs {
    const condition = NotificationListREQ.toQueryCondition(user, query);

    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: defaultSortDesc,
      include: { TargetAccount: true },
    };
  }
}
</file>

<file path="src/domains/notification/request/notification-read.request.ts">
import { Prisma } from '@prisma/client';
import { IsBoolean } from 'class-validator';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';

export class NotificationReadREQ {
  @IsBoolean()
  isRead: boolean; // true is marked as read, false is marked as unread

  static toReadNotification(id: number, body: NotificationReadREQ): Prisma.NotificationUpdateArgs {
    return {
      where: { id: id },
      data: { isRead: body.isRead, readAt: orUndefinedWithCondition(body.isRead, nowEpoch()) },
      select: { id: true, isRead: true },
    };
  }
}
</file>

<file path="src/domains/notification/response/notification.response.ts">
import { Course, NotificationRelationType, NotificationType, Payment, Subscription } from '@prisma/client';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { NotificationGetPayload } from '../shared/types';

//=======================Course=======================
export class NotificationCourseDetailRESP {
  id: number;
  name: string;
  price: number;
  startDate: string;
  endDate: string;

  static fromEntity(entity: Course): NotificationCourseDetailRESP {
    return {
      id: entity.id,
      name: entity.name,
      price: parseDecimalNumber(entity.price),
      startDate: parsePrismaDateToEpoch(entity.startDate),
      endDate: parsePrismaDateToEpoch(entity.endDate),
    };
  }
}

export type NotificationPaymentSubscriptionRESP = Pick<NotificationSubscriptionDetailRESP, 'id' | 'createdAt' | 'course'>;

//=======================Payment=======================
export class NotificationPaymentDetailRESP {
  id: number;
  price: number;
  status: string;
  createdAt: string;
  subscription: NotificationSubscriptionDetailRESP;

  static fromEntity(entity: Payment, subscription: NotificationPaymentSubscriptionRESP): NotificationPaymentDetailRESP {
    return {
      id: entity.id,
      status: entity.status,
      subscription,
      price: parseDecimalNumber(entity.price),
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}

//=======================Mentor=======================
export class NotificationMentorDetailRESP {
  id: number;
  name: string;
  email: string;
  thumbnail?: ImageRESP;

  static fromEntity(entity: MentorGetPayload, thumbnail?: ImageRESP): NotificationMentorDetailRESP {
    return {
      id: entity.id,
      name: entity.Account.name,
      email: entity.Account.email,
      thumbnail,
    };
  }
}

//=======================Audio Room=======================
export class NotificationAudioRoomDetailRESP {
  id: number;
  title: string;
  startsAt: string;
  status: string;
  cid: string;

  static fromEntity(entity: AudioRoomGetPayload): NotificationAudioRoomDetailRESP {
    return {
      id: entity.id,
      title: entity.title,
      startsAt: parseEpoch(entity.startsAt),
      status: entity.status,
      cid: entity.cid,
    };
  }
}

//=======================Subscription=======================
export class NotificationSubscriptionDetailRESP {
  id: number;
  createdAt: string;
  course: NotificationCourseDetailRESP;
  payment?: NotificationPaymentDetailRESP;

  static fromEntity(
    entity: Subscription,
    course: NotificationCourseDetailRESP,
    payment: NotificationPaymentDetailRESP | null,
  ): NotificationSubscriptionDetailRESP {
    return {
      id: entity.id,
      course,
      payment,
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}

//=======================FEEDBACK=======================
export class NotificationFeedbackDetailRESP {
  id: number;
  courseReview: string;
  courseRating: number;
  mentorReview: string;
  mentorRating: number;

  static fromEntity(entity: any): NotificationFeedbackDetailRESP {
    return {
      id: entity.id,
      courseReview: entity.courseReview,
      courseRating: entity.courseRating,
      mentorReview: entity.mentorReview,
      mentorRating: entity.mentorRating,
    };
  }
}

//=======================REPORT=======================
export class NotificationReportDetailRESP {
  id: number;
  status: string;
  resolution: string;
  subscription?: NotificationSubscriptionDetailRESP;
  feedback?: NotificationFeedbackDetailRESP;

  static fromEntity(
    entity: any,
    subscription: NotificationSubscriptionDetailRESP,
    feedback: NotificationFeedbackDetailRESP,
  ): NotificationReportDetailRESP {
    return {
      id: entity.id,
      status: entity.status,
      resolution: entity.resolution,
      subscription,
      feedback,
    };
  }
}

export type NotificationRelationRESP =
  | NotificationCourseDetailRESP
  | NotificationPaymentDetailRESP
  | NotificationSubscriptionDetailRESP
  | NotificationMentorDetailRESP
  | NotificationAudioRoomDetailRESP
  | NotificationFeedbackDetailRESP
  | NotificationReportDetailRESP;

export class NotificationRESP {
  id: number;
  title: string;
  content: string;
  isRead: boolean;
  type: NotificationType;
  relationType: NotificationRelationType;
  createdAt: string;
  readAt?: string;
  course?: NotificationCourseDetailRESP;
  payment?: NotificationPaymentDetailRESP;
  subscription?: NotificationSubscriptionDetailRESP;
  mentor?: NotificationMentorDetailRESP;
  audioRoom?: NotificationAudioRoomDetailRESP;
  feedback?: NotificationFeedbackDetailRESP;
  report?: NotificationReportDetailRESP;

  static fromEntity(e: NotificationGetPayload, relation: NotificationRelationRESP): NotificationRESP {
    const mappingRelation = this.mapRelationTypeToDetail(e.relationType, relation);
    return {
      id: e.id,
      title: e.title,
      content: e.content,
      isRead: e.isRead,
      type: e.type,
      relationType: e.relationType,
      readAt: parseEpoch(e.readAt),
      createdAt: parseEpoch(e.createdAt),
      ...mappingRelation,
    };
  }

  static mapRelationTypeToDetail(relationType: NotificationRelationType, relation: NotificationRelationRESP) {
    let mappingRelation: any;
    switch (relationType) {
      case NotificationRelationType.COURSE:
        mappingRelation = { course: relation as NotificationCourseDetailRESP };
        break;
      case NotificationRelationType.PAYMENT:
        mappingRelation = { payment: relation as NotificationPaymentDetailRESP };
        break;
      case NotificationRelationType.SUBSCRIPTION:
        mappingRelation = { subscription: relation as NotificationSubscriptionDetailRESP };
        break;
      case NotificationRelationType.MENTOR:
        mappingRelation = { mentor: relation as NotificationMentorDetailRESP };
        break;
      case NotificationRelationType.AUDIO_CALL:
        mappingRelation = { audioRoom: relation as NotificationAudioRoomDetailRESP };
        break;
      case NotificationRelationType.FEEDBACK:
        mappingRelation = { feedback: relation as NotificationFeedbackDetailRESP };
        break;
      case NotificationRelationType.REPORT:
        mappingRelation = { report: relation as NotificationReportDetailRESP };
        break;
      default:
        throw new ActionFailedException(ActionFailed.NOTIFICATION_INVALID_RELATION_TYPE);
    }

    return {
      course: null,
      payment: null,
      subscription: null,
      mentor: null,
      audioRoom: null,
      report: null,
      feedback: null,
      ...mappingRelation,
    };
  }
}
</file>

<file path="src/domains/notification/shared/interfaces.ts">
export interface BaseNotificationPayload {
  type?: string;
  userId?: string;
}

export interface FcmNotificationPayload extends BaseNotificationPayload {
  title: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
}

export interface FCMSendOptions {
  token?: string;
  topic?: string;
  condition?: string;
  data?: { [key: string]: string }; // Custom data
}

export interface SESEmailPayload extends BaseNotificationPayload {
  to: string;
  subject?: string;
  template?: string;
  context?: any;
}

export interface SmsPayload extends BaseNotificationPayload {
  to: string;
  message: string;
}

// export interface NotificationPayload<TNotification, TData> {
//   notificationREQ: TNotification;
//   data: TData;
//   deviceTokenCondition?: Prisma.DeviceTokenWhereInput;
// }
</file>

<file path="src/domains/notification/shared/transation.enum.ts">
export enum Propagation {
  /**
   * (default) Reuse the existing transaction or create a new one if none exists.
   */
  Required = 'REQUIRED',
  /**
   * Create a new transaction even if one already exists. The new transaction is committed independently of the existing one.
   */
  RequiresNew = 'REQUIRES_NEW',
}
</file>

<file path="src/domains/notification/shared/types.ts">
import { Prisma } from '@prisma/client';
import { EmailPayload, EmailTemplate } from 'src/services/email/shared/types';
import { NotificationCreateREQ } from '../request/notification-create.request';

export type NotificationGetPayload = Prisma.NotificationGetPayload<{
  include: {
    TargetAccount: true;
  };
}>;

export interface BaseNotificationPayload {
  type?: string;
  userId?: string;
}

export interface FCMNotificationPayload extends BaseNotificationPayload {
  title: string;
  topic: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
}

export interface NotificationEmailPayload {
  data: EmailPayload;
  template?: EmailTemplate;
}

export enum NotificationChannel {
  EMAIL = 'notification.email',
  SMS = 'notification.sms',
  APP = 'notification.app',
}

export interface NotificationPayload<TNotification, TData> {
  notificationREQ: TNotification;
  data: TData;
  eviceTokenCondition?: Prisma.DeviceTokenWhereInput;
}

export type NotificationAppHandlerPayload = NotificationPayload<NotificationCreateREQ, FCMNotificationPayload>;
</file>

<file path="src/domains/notification/notification.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Query, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { NotificationService } from './notification.service';
import { NotificationListREQ } from './request/notification-list.request';
import { NotificationReadREQ } from './request/notification-read.request';

@UseGuards(AuthJwtGuard)
@Controller('notifications')
export class NotificationController {
  constructor(private readonly notificationService: NotificationService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: NotificationListREQ) {
    return await this.notificationService.list(req.user, query);
  }

  @Patch(':id')
  async readNotification(@Param('id', ParseIntPipe) id: number, @Body() body: NotificationReadREQ) {
    const notification = await this.notificationService.readNotification(id, body);

    return BaseResponse.of(notification);
  }
}
</file>

<file path="src/domains/notification/notification.gateway.ts">
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { EmailService } from 'src/services/email/email.service';
import { FCMService } from 'src/services/fcm/fcm.service';
import { payloadFcmAdapter } from 'src/services/fcm/shared/helpers';
import { NotificationService } from './notification.service';
import {
  NotificationAppHandlerPayload,
  NotificationChannel,
  NotificationEmailPayload,
  NotificationGetPayload,
} from './shared/types';

@Injectable()
export class NotificationGateway {
  private readonly logger = new Logger(NotificationGateway.name);
  constructor(
    private readonly fcmService: FCMService,
    private readonly emailService: EmailService,
    // private readonly smsService: SmsService,
    private readonly notificationService: NotificationService,
  ) {}

  @OnEvent(NotificationChannel.EMAIL)
  async handleEmailNotification(payload: NotificationEmailPayload) {
    await this.emailService.sendMail(payload.data, payload.template);
  }

  @OnEvent(NotificationChannel.APP)
  async handleAppNotification(payload: NotificationAppHandlerPayload) {
    this.logger.log(' ~ NotificationGateway ~ handleAppNotification ~ payload:', payload);

    const notification = (await this.notificationService.createNotification(payload.notificationREQ)) as NotificationGetPayload;
    const detail = await this.notificationService.detail(notification.id);
    this.logger.log(' ~ NotificationGateway ~ handleAppNotification ~ detail:', detail);

    const data = payloadFcmAdapter(payload.data.title, payload.data.topic, detail);
    const condition = payload.data.condition ?? { accountId: notification.targetAccountId };
    await this.fcmService.sendNotificationToAllDevices(notification.targetAccountId, condition, data);
  }

  // @OnEvent(NotificationChannel.SMS)
  // handleSmsNotification(payload: SmsPayload) {
  //   this.smsService.sendSMS(payload);
  // }
}
</file>

<file path="src/domains/notification/notification.module.ts">
import { Global, Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { FcmModule } from 'src/services/fcm/fcm.module';
import { NotificationController } from './notification.controller';
import { NotificationGateway } from './notification.gateway';
import { NotificationService } from './notification.service';
@Module({
  imports: [CommonModule, FcmModule],
  controllers: [NotificationController],
  providers: [NotificationService, NotificationGateway],
  exports: [NotificationService, NotificationGateway],
})
@Global()
export class NotificationModule {}
</file>

<file path="src/domains/notification/notification.service.ts">
import { Injectable } from '@nestjs/common';
import { Course, NotificationRelationType, Payment } from '@prisma/client';
import { PrismaService } from 'src/services/prisma/prisma.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomGetPayload } from '../audio-call/shared/types';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FeedbackGetPayload } from '../feedback/shared/type';
import { ImageService } from '../image/image.service';
import { MentorGetPayload } from '../mentor/shared/types';
import { ReportGetPayload } from '../report/shared/type';
import { SubscriptionGetPlayload } from '../subscription/shared/types';
import { NotificationCreateREQ } from './request/notification-create.request';
import { NotificationListREQ } from './request/notification-list.request';
import { NotificationReadREQ } from './request/notification-read.request';
import {
  NotificationAudioRoomDetailRESP,
  NotificationCourseDetailRESP,
  NotificationFeedbackDetailRESP,
  NotificationMentorDetailRESP,
  NotificationPaymentDetailRESP,
  NotificationReportDetailRESP,
  NotificationRESP,
  NotificationSubscriptionDetailRESP,
} from './response/notification.response';
import { Propagation } from './shared/transation.enum';
import { NotificationGetPayload } from './shared/types';

@Injectable()
export class NotificationService {
  constructor(
    private readonly prismaService: PrismaService,
    private readonly imageService: ImageService,
    private readonly transactionHost: TransactionHost,
  ) {}

  async list(user: AuthUserDTO, query: NotificationListREQ) {
    const notifications = await this.prismaService.notification.findMany(NotificationListREQ.toFindMany(user, query));
    const count = await this.prismaService.notification.count({
      where: NotificationListREQ.toQueryCondition(user, query),
    });

    const response = await Promise.all(
      notifications.map(async (notification: NotificationGetPayload) => {
        const relation = await this.findDetailRelation(notification.relationId, notification.relationType);
        return NotificationRESP.fromEntity(notification, relation);
      }),
    );

    return PaginationResponse.ofWithTotal(response, count);
  }

  @Transactional(Propagation.RequiresNew, TRANSACTION_TIMEOUT)
  async createNotification(body: NotificationCreateREQ) {
    const notification = await this.transactionHost.tx.notification.create(NotificationCreateREQ.toCreateNotification(body));

    return notification;
  }

  async readNotification(id: number, body: NotificationReadREQ) {
    const notification = await this.transactionHost.tx.notification.update(NotificationReadREQ.toReadNotification(id, body));
    return notification;
  }

  async detail(notificationId: number) {
    const notification = (await this.transactionHost.tx.notification.findFirst({
      where: { id: notificationId },
      select: {
        id: true,
        type: true,
        relationType: true,
        relationId: true,
        title: true,
        content: true,
        scopes: true,
        targetAccountId: true,
        createdAt: true,
      },
    })) as NotificationGetPayload;

    const relation = await this.findDetailRelation(notification.relationId, notification.relationType);

    return NotificationRESP.fromEntity(notification, relation);
  }

  private async findDetailRelation(relationId: number, relationType: NotificationRelationType): Promise<any> {
    switch (relationType) {
      case NotificationRelationType.COURSE:
        return this.findCourseDetail(relationId);
      case NotificationRelationType.PAYMENT:
        return this.findPaymentDetail(relationId);
      case NotificationRelationType.SUBSCRIPTION:
        return this.findSubscriptionDetail(relationId);
      case NotificationRelationType.MENTOR:
        return this.findMentorDetail(relationId);
      case NotificationRelationType.AUDIO_CALL:
        return this.findAudioCallDetail(relationId);
      case NotificationRelationType.FEEDBACK:
        return this.findFeedbackDetail(relationId);
      case NotificationRelationType.REPORT:
        return this.findReportDetail(relationId);
    }
  }

  private async findReportDetail(reportId: number) {
    const report = (await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: {
        id: true,
        status: true,
        resolution: true,
        Subscription: { select: { id: true } },
        Feedback: { select: { id: true } },
      },
    })) as ReportGetPayload;

    if (!report) return null;

    const subscription = report.Subscription ? await this.findSubscriptionDetail(report.Subscription.id) : null;
    const feedback = report.Feedback ? await this.findFeedbackDetail(report.Feedback.id) : null;

    return NotificationReportDetailRESP.fromEntity(report, subscription, feedback);
  }

  private async findFeedbackDetail(feedbackId: number) {
    const feedback = (await this.transactionHost.tx.feedback.findFirst({
      where: { id: feedbackId },
      select: { id: true, courseRating: true, mentorRating: true, courseReview: true, mentorReview: true, reviewerId: true },
    })) as FeedbackGetPayload;

    if (!feedback) return null;

    return NotificationFeedbackDetailRESP.fromEntity(feedback);
  }

  private async findCourseDetail(courseId: number) {
    const course = (await this.transactionHost.tx.course.findFirst({
      where: { id: courseId },
      select: { id: true, name: true, startDate: true, endDate: true, price: true },
    })) as Course;

    if (!course) return null;

    return NotificationCourseDetailRESP.fromEntity(course);
  }

  private async findAudioCallDetail(audioCallId: number) {
    const audioCall = (await this.transactionHost.tx.audioRoom.findFirst({
      where: { id: audioCallId },
      select: { id: true, title: true, startsAt: true, status: true, cid: true },
    })) as AudioRoomGetPayload;

    if (!audioCall) return null;

    return NotificationAudioRoomDetailRESP.fromEntity(audioCall);
  }

  private async findMentorDetail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId },
      select: {
        id: true,
        status: true,
        Account: { select: { id: true, name: true, email: true, phoneNumber: true, avatarId: true } },
      },
    })) as MentorGetPayload;

    if (!mentor) return null;

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);

    return NotificationMentorDetailRESP.fromEntity(mentor, thumbnail);
  }

  private async findPaymentDetail(paymentId: number) {
    const payment = (await this.transactionHost.tx.payment.findFirst({
      where: { id: paymentId },
      select: { id: true, price: true, status: true, subscriptionId: true, createdAt: true },
    })) as Payment;

    if (!payment) return null;

    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: payment.subscriptionId },
      select: { id: true, courseId: true, status: true, createdAt: true },
    })) as SubscriptionGetPlayload;
    const course = await this.findCourseDetail(subscription.courseId);

    return NotificationPaymentDetailRESP.fromEntity(payment, {
      id: subscription.id,
      createdAt: parseEpoch(subscription.createdAt),
      course,
    });
  }

  private async findSubscriptionDetail(subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: subscriptionId },
      select: { id: true, courseId: true, status: true, Payment: { select: { id: true } }, createdAt: true },
    })) as SubscriptionGetPlayload;

    if (!subscription) return null;

    const course = await this.findCourseDetail(subscription.courseId);
    const payment = subscription.Payment ? await this.findPaymentDetail(subscription.Payment?.id) : null;

    return NotificationSubscriptionDetailRESP.fromEntity(subscription, course, payment);
  }
}
</file>

<file path="src/domains/payment/client/payment-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientController', () => {
  let controller: PaymentClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PaymentClientController],
      providers: [PaymentClientService],
    }).compile();

    controller = module.get<PaymentClientController>(PaymentClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.controller.ts">
import { Body, Controller, Post, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaymentCreateREQ } from '../dto/payment-create.request';
import { PaymentClientService } from './payment-client.service';

@Controller('client/payments')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class PaymentClientController {
  constructor(private readonly paymentClientService: PaymentClientService) {}

  @Post()
  async createPayment(@Req() req: AuthRequestDTO, @Body() body: PaymentCreateREQ): Promise<any> {
    const ipAddr = req.headers['x-forwarded-for'] || req.socket.remoteAddress;

    const payment = await this.paymentClientService.create(body, ipAddr as string);

    return BaseResponse.of(payment);
  }

  @Post('verify')
  async verify(@Body() body: ReturnQueryFromVNPay & { paymentId: number }): Promise<any> {
    const { paymentId, ...returnUrl } = body;
    const result = await this.paymentClientService.verify(paymentId, returnUrl);

    return BaseResponse.of(result);
  }
}
</file>

<file path="src/domains/payment/client/payment-client.module.ts">
import { Module } from '@nestjs/common';
import { VNP_HASHSECRET, VNP_TMNCODE } from 'src/app.config';
import { VnpayModule } from 'src/services/payment-gateway/vn-pay/vnpay.module';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

@Module({
  imports: [
    VnpayModule.register({
      tmnCode: VNP_TMNCODE,
      secureSecret: VNP_HASHSECRET,
    }),
  ],
  controllers: [PaymentClientController],
  providers: [PaymentClientService],
  exports: [PaymentClientService],
})
export class PaymentClientModule {}
</file>

<file path="src/domains/payment/client/payment-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientService', () => {
  let service: PaymentClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PaymentClientService],
    }).compile();

    service = module.get<PaymentClientService>(PaymentClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomType,
  NotificationRelationType,
  NotificationType,
  ParticipantAudioRoomRole,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { SubscriptionMakePaymentHelper } from 'src/domains/subscription/helper/subscription-make-payment.helper';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { VnpayService } from 'src/services/payment-gateway/vn-pay/vnpay.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { ReturnPaymentStatus } from 'src/shared/constants/payment.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { EXPIRED_SUBSCRIPTION_AFTER_APPROVED } from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { Result } from 'src/shared/generics/type.helper';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { PaymentContinueREQ } from '../dto/payment-continue.request';
import { PaymentCreateREQ } from '../dto/payment-create.request';

@Injectable()
export class PaymentClientService {
  private logger = new Logger(PaymentClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly vnpayService: VnpayService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async create(body: PaymentCreateREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.create({
      data: {
        status: PaymentStatus.IN_PROGRESS,
        price: parseDecimalNumber(body.amount),
        Subscription: connectRelation(body.subscriptionId),
      },
      select: {
        id: true,
        status: true,
      },
    });

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async continue(body: PaymentContinueREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { subscriptionId: body.subscriptionId },
      select: { id: true, status: true },
    });

    if (payment.status !== PaymentStatus.IN_PROGRESS) {
      throw new ActionFailedException(ActionFailed.PAYMENT_NOT_AVAILABLE);
    }

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async verify(paymentId: number, query: ReturnQueryFromVNPay): Promise<Result<ReturnQueryFromVNPay, Error>> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { id: paymentId },
      select: { subscriptionId: true },
    });

    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: payment.subscriptionId },
      select: {
        id: true,
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        accountId: true,
        Course: { select: { id: true, creatorId: true } },
      },
    });

    const now = nowEpoch();

    if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    if (now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
      this.logger.log(
        ' ~ PaymentClientService ~ verify ~ EXPIRED_SUBSCRIPTION_AFTER_APPROVED: ',
        EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
      );

      this.logger.warn(
        ` ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
    }

    const result = await this.vnpayService.verifyReturnUrl(paymentId, query);

    if (result.success == false) {
      this.logger.error(' ~ PaymentClientService ~ verify ~ fail result:', result);
      this.logger.warn(' ~ PaymentClientService ~ verify ~ fail query from third party');
      // await this.transactionHost.tx.payment.update({
      //   where: { id: paymentId },
      //   data: {
      //     status: PaymentStatus.CANCELED,
      //     Subscription: { update: { status: SubscriptionStatus.CANCELED } },
      //   },
      // });

      return result;
    }

    switch (result.data.vnp_ResponseCode) {
      case ReturnPaymentStatus.SUCCESSFUL_STATUS:
        const { payment } = await this.updatePaymentStatus(paymentId, PaymentStatus.DONE, SubscriptionStatus.ACTIVE);

        const payload = NotificationHelper.makeAppNotificationPayload(
          { id: payment.id, type: NotificationRelationType.PAYMENT },
          subscription.Course.creatorId,
          NotificationType.PAYMENT_SUCCESS,
        );

        runFunctionWithCondition(!!subscription, () => {
          this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
        });

        break;
      // case ReturnPaymentStatus.EXPIRED_STATUS:
      // await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
      // break;
      default:
        break;
    }

    return result;
  }

  async updatePaymentStatus(paymentId: number, status: PaymentStatus, subscriptionStatus: SubscriptionStatus) {
    const payment = await this.transactionHost.tx.payment.update({
      where: { id: paymentId },
      data: { status },
      select: {
        id: true,
        Subscription: {
          select: { id: true, accountId: true, courseAccessStartAt: true, Course: { select: { name: true, creatorId: true } } },
        },
      },
    });

    let cid: string;
    let callId: number;
    if (subscriptionStatus === SubscriptionStatus.ACTIVE) {
      callId = await this.createAudioCall(payment.Subscription as SubscriptionGetPlayload);
      cid = await this.generateCid(callId);
    }

    (await this.transactionHost.tx.subscription.update(
      SubscriptionMakePaymentHelper.toActivate(payment.Subscription.id, subscriptionStatus, callId),
    )) as SubscriptionGetPlayload;

    return { payment, cid };
  }

  private async createAudioCall(subscription: SubscriptionGetPlayload): Promise<number> {
    const audioCallCreateData: AudioCallAdminCreateREQ = {
      title: `${subscription.Course.name}`,
      status: RoomStatus.SCHEDULED,
      type: AudioRoomType.AUDIOROOM,
      members: [{ accountId: subscription.accountId, role: ParticipantAudioRoomRole.USER }],
      startsAt: SubscriptionMakePaymentHelper.parseAudioCallStartsAt(Number(subscription.courseAccessStartAt)),
    };

    const call = await this.transactionHost.tx.audioRoom.create(
      AudioCallAdminCreateREQ.toCreateMemberInput(subscription.Course.creatorId, audioCallCreateData),
    );

    return call.id;
  }

  // Function to generate CID
  private async generateCid(callId: number): Promise<string> {
    const cid = `${new Date().getTime()}-${callId}-${randomUUID()}`;

    await this.transactionHost.tx.audioRoom.update({
      where: { id: callId },
      data: { cid: cid },
      select: { id: true },
    });
    return cid;
  }
}
</file>

<file path="src/domains/payment/dto/payment-continue.request.ts">
import { PaymentCreateREQ } from './payment-create.request';

export class PaymentContinueREQ extends PaymentCreateREQ {}
</file>

<file path="src/domains/payment/dto/payment-create.request.ts">
import { IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { VNPAY_RETURN_URL } from 'src/app.config';
import { BankCode } from 'src/services/payment-gateway/vn-pay/shared/vnpay.enum';
import { VNPayBuildUrlRequest } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class PaymentCreateREQ {
  @IdValidator()
  subscriptionId: number;

  @IsNumber()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  amount: number;

  @IsEnum(BankCode)
  @IsOptional()
  bankCode?: BankCode;

  @IsString()
  @MaxLength(255)
  description: string;

  static toVnpayRequest(body: PaymentCreateREQ, ipAddr: string): VNPayBuildUrlRequest {
    return {
      vnp_Amount: body.amount,
      vnp_BankCode: body.bankCode,
      vnp_OrderInfo: body.description,
      vnp_IpAddr: ipAddr,
      vnp_ReturnUrl: VNPAY_RETURN_URL,
      vnp_TxnRef: `${body.subscriptionId}-${nowEpoch()}`,
    };
  }
}
</file>

<file path="src/domains/payment/payment.module.ts">
import { Module } from '@nestjs/common';
import { PaymentClientModule } from './client/payment-client.module';

@Module({
  imports: [PaymentClientModule],
})
export class PaymentModule {}
</file>

<file path="src/domains/report/helper/report-create.helper.ts">
import { Prisma, ReportStatus, ReportType } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { ReportCreateInterface } from '../shared/interface';

export class ReportCreateHelper {
  static toConnectRelationByReportType(type: ReportType, relationId: number) {
    switch (type) {
      case ReportType.MENTOR_ISSUES:
      case ReportType.COURSE_UNQUALIFIED:
        return { Subscription: connectRelation(relationId) };
      case ReportType.FEEDBACK_INAPPROPRIATE:
        return { Feedback: connectRelation(relationId) };
    }
  }

  static toCreate<T extends ReportCreateInterface>(user: AuthUserDTO, body: T): Prisma.ReportCreateArgs {
    const relationId = body['subscriptionId'] || body['feedbackId'];

    return {
      data: {
        type: body.type,
        description: body.description,
        status: ReportStatus.PENDING,
        Reporter: connectRelation(user.accountId),
        ...this.toConnectRelationByReportType(body.type, relationId),
      },
    };
  }
}
</file>

<file path="src/domains/report/helper/report-detail.helper.ts">
import { Feedback, Prisma } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { ReportDetailRESP, ReportFeedbackDetailRESP, ReportSubscriptionDetailRESP } from '../response/report-detail.response';
import { ReporterAccountRESP, ReportGetPayload, ReportRelationDetailRESP } from '../shared/type';

export class ReportDetailHelper {
  static toFindUnique(reportId: number): Prisma.ReportFindUniqueOrThrowArgs {
    return {
      where: { id: reportId },
      select: {
        id: true,
        type: true,
        description: true,
        status: true,
        resolution: true,
        createdAt: true,
        reporterId: true,
        subscriptionId: true,
        Feedback: {
          select: {
            id: true,
            reviewerId: true,
            courseRating: true,
            courseReview: true,
            mentorRating: true,
            mentorReview: true,
            subscriptionId: true,
            createdAt: true,
          },
        },
      },
    };
  }

  static fromReportFeedback(feedback: Feedback, reviewer: ReporterAccountRESP): ReportFeedbackDetailRESP {
    if (!feedback) return null;

    return {
      id: feedback.id,
      courseRating: feedback.courseRating,
      mentorRating: feedback.mentorRating,
      courseReview: feedback.courseReview,
      mentorReview: feedback.mentorReview,
      updatedAt: parseEpoch(feedback.updatedAt),
      reviewer: reviewer,
      subscriptionId: feedback.subscriptionId,
    };
  }

  static fromReportSubscription(subcription: ReportSubscriptionDetailRESP): ReportSubscriptionDetailRESP {
    if (!subcription) return null;

    return subcription;
  }

  static fromReportEntity(entity: ReportGetPayload, reportRelation: ReportRelationDetailRESP): ReportDetailRESP {
    return {
      id: entity.id,
      type: entity.type,
      description: entity.description,
      status: entity.status,
      resolution: entity.resolution,
      createdAt: parseEpoch(entity.createdAt),
      subscription: orNullWithCondition(!!reportRelation.subscription, reportRelation.subscription),
      feedback: orNullWithCondition(!!reportRelation.feedback, reportRelation.feedback),
    };
  }
}
</file>

<file path="src/domains/report/helper/report-list.helper.ts">
import { AccountType, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { parseEpoch, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { ReportListREQ } from '../request/report-list.request';
import { ReportListRESP } from '../response/report-list.response';
import { ReportGetPayload } from '../shared/type';

export class ReportListHelper {
  static toFilterByAccountType(user: AuthUserDTO): Prisma.ReportWhereInput {
    switch (user.accountType) {
      case AccountType.STUDENT: {
        return { Reporter: { id: user.accountId } };
      }
      case AccountType.ADMIN: {
        return {};
      }
    }
  }

  static toQueryCondition(user: AuthUserDTO, query: ReportListREQ): Prisma.ReportWhereInput {
    const filterByAccountType = this.toFilterByAccountType(user);
    const queryName = orUndefinedWithCondition(!!query.reporterName, {
      Reporter: parsePrismaSearch('name', query.reporterName),
    });

    return {
      AND: [filterByAccountType, queryName].filter((x) => !!x),
      status: orUndefinedWithCondition(!!query.status, query.status),
      type: orUndefinedWithCondition(!!query.type, query.type),
    };
  }

  static toFindMany(user: AuthUserDTO, query: ReportListREQ): Prisma.ReportFindManyArgs {
    const queryCondition = this.toQueryCondition(user, query);
    console.log(' ~ ReportListHelper ~ toFindMany ~ queryCondition:', queryCondition);

    return {
      where: { ...queryCondition },
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        type: true,
        description: true,
        status: true,
        resolution: true,
        createdAt: true,
        Reporter: { select: { id: true, name: true } },
      },
    };
  }

  static fromEntity(entity: ReportGetPayload): ReportListRESP {
    return {
      id: entity.id,
      type: entity.type,
      description: entity.description,
      status: entity.status,
      resolution: entity.resolution,
      reporter: { id: entity.Reporter.id, name: entity.Reporter.name },
      createdAt: parseEpoch(entity.createdAt),
    };
  }
}
</file>

<file path="src/domains/report/helper/report-resolve.helper.ts">
import { AccountSuspensionType, AudioRoomActivityHistory, CourseSuspensionType, WageStatus } from '@prisma/client';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseEpoch } from 'src/shared/parsers/common.parser';

export class ReportResolveHelper {
  public static calculateAccountSuspensionDays(noOfReports: number): AccountSuspensionType {
    if (noOfReports < 0) throw new ActionFailedException(ActionFailed.REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO);

    switch (true) {
      case noOfReports >= 0 && noOfReports < 5:
        return AccountSuspensionType.ACCOUNT_NOT_SUSPENDED;
      case noOfReports >= 5 && noOfReports <= 7:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_3_DAYS;
      case noOfReports > 7 && noOfReports < 11:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_7_DAYS;
      default:
        return AccountSuspensionType.ACCOUNT_SUSPENDED_PERMANENTLY;
    }
  }

  public static calculateCourseSuspensionDays(noOfReports: number): CourseSuspensionType {
    console.log(' ~ ReportResolveHelper ~ calculateCourseSuspensionDays ~ noOfReports:', noOfReports);
    if (noOfReports < 0) throw new ActionFailedException(ActionFailed.REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO);

    switch (true) {
      case noOfReports >= 0 && noOfReports <= 1:
        return CourseSuspensionType.COURSE_NOT_SUSPENDED;
      case noOfReports > 1 && noOfReports <= 3:
        return CourseSuspensionType.COURSE_SUSPENDED_3_DAYS;
      case noOfReports > 3 && noOfReports <= 5:
        return CourseSuspensionType.COURSE_SUSPENDED_7_DAYS;
      default:
        return CourseSuspensionType.COURSE_SUSPENDED_PERMANENTLY;
    }
  }

  public static getTotalTimeInAudioRoom(audioRoomHistories: AudioRoomActivityHistory[]): number {
    const totalTimeInSeconds = audioRoomHistories.reduce((total, history) => {
      if (history.joinedAt && history.leftAt) {
        const duration = Math.abs(parseEpoch(history.joinedAt) - parseEpoch(history.leftAt));
        return total + duration;
      }

      return total;
    }, 0);

    return totalTimeInSeconds;
  }

  public static calculatePaymentCut(totalTimeInMils: number, courseTotalDuration: number): WageStatus {
    const totalDurationInMils = courseTotalDuration * 60 * 60 * 1000;
    const percentage = (totalTimeInMils / totalDurationInMils) * 100;
    console.log(' ~ ReportResolveHelper ~ calculatePaymentCut ~ percentage:', percentage);

    switch (true) {
      case percentage < 40 && percentage >= 0:
        return WageStatus.NOT_PAID;
      case percentage >= 40 && percentage < 70:
        return WageStatus.PARTIAL_30_PERCENT;
      case percentage >= 70 && percentage < 80:
        return WageStatus.PARTIAL_70_PERCENT;
      default:
        return WageStatus.FULL_WAGE;
    }
  }
}
</file>

<file path="src/domains/report/request/report-client-feedback-create.request.ts">
import { ReportType } from '@prisma/client';
import { IsEnum, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { ReportCreateInterface } from '../shared/interface';

export class ReportClientFeedbackCreateREQ implements ReportCreateInterface {
  @IdValidator()
  feedbackId: number;

  @IsEnum(ReportType)
  type: ReportType;

  @MaxLength(1000)
  description: string;
}
</file>

<file path="src/domains/report/request/report-client-subscription-create.request.ts">
import { ReportType } from '@prisma/client';
import { IsEnum, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { ReportCreateInterface } from '../shared/interface';

export class ReportClientSubscriptionCreateREQ implements ReportCreateInterface {
  @IdValidator()
  subscriptionId: number;

  @IsEnum(ReportType)
  type: ReportType;

  @MaxLength(1000)
  description: string;
}
</file>

<file path="src/domains/report/request/report-list.request.ts">
import { ReportStatus, ReportType } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';

export class ReportListREQ extends PaginationREQ {
  @IsEnum(ReportStatus)
  @IsOptional()
  status?: ReportStatus;

  @IsEnum(ReportType)
  @IsOptional()
  type?: ReportType;

  @IsOptional()
  @IsString()
  reporterName?: string;
}
</file>

<file path="src/domains/report/request/report-resolve-base.request.ts">
import { ReportStatus } from '@prisma/client';
import { IsEnum, IsNotEmpty, IsString, MaxLength } from 'class-validator';

export class ReportResolveBaseREQ {
  @IsEnum(ReportStatus)
  status: ReportStatus;

  @IsString()
  @MaxLength(1000)
  @IsNotEmpty()
  resolution: string;
}
</file>

<file path="src/domains/report/request/report-resolve-feeback.request.ts">
import { ReportResolveBaseREQ } from './report-resolve-base.request';

export class ReportResolveFeedbackREQ extends ReportResolveBaseREQ {}
</file>

<file path="src/domains/report/request/report-resolve-subscription.request.ts">
import { ReportResolveBaseREQ } from './report-resolve-base.request';

export class ReportResolveSubscriptionREQ extends ReportResolveBaseREQ {}
</file>

<file path="src/domains/report/response/report-detail.response.ts">
import { ReportStatus, ReportType } from '@prisma/client';
import { FeedbackListRESP } from 'src/domains/feedback/response/feedback-list.response';
import { SubscriptionDetailRESP } from 'src/domains/subscription/dto/response/subscription-detail.response';
import { ReportFeedbackListRESP } from '../shared/type';

export class ReportSubscriptionDetailRESP extends SubscriptionDetailRESP {
  audioCall: ReportAudioCallDetailRESP;
  feedbacks: ReportFeedbackListRESP[] = [];
}

export class ReportFeedbackDetailRESP extends FeedbackListRESP {}

export class ReportAudioCallDetailRESP {
  id: number;
  cid: string;
}

export class ReportDetailRESP {
  id: number;
  type: ReportType;
  description: string;
  status: ReportStatus;
  resolution: string;
  createdAt: string;
  subscription?: ReportSubscriptionDetailRESP;
  feedback?: ReportFeedbackDetailRESP;
}
</file>

<file path="src/domains/report/response/report-list.response.ts">
export class ReportListRESP {
  id: number;
  type: string;
  description: string;
  status: string;
  resolution: string;
  reporter: {
    id: number;
    name: string;
  };
  createdAt: string;
}
</file>

<file path="src/domains/report/shared/interface.ts">
import { ReportType } from '@prisma/client';

export interface ReportCreateInterface {
  type: ReportType;
  description: string;
}
</file>

<file path="src/domains/report/shared/type.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { SubscriptionDetailRESP } from 'src/domains/subscription/dto/response/subscription-detail.response';
import { ReportFeedbackDetailRESP } from '../response/report-detail.response';

export type ReportGetPayload = Prisma.ReportGetPayload<{
  include: { Feedback: true; Reporter: true; Subscription: true };
}>;

export type ReporterAccountRESP = Pick<AccountRESP, 'id' | 'name' | 'thumbnail'>;

export type ReportRelationDetailRESP = {
  feedback?: ReportFeedbackDetailRESP;
  subscription?: SubscriptionDetailRESP;
};

export type ReportFeedbackListRESP = {
  id: number;
  courseRating: number;
  courseReview: string;
  mentorRating: number;
  mentorReview: string;
  updatedAt: string;
};
</file>

<file path="src/domains/report/shared/utilities.ts">
import { ReportClientFeedbackCreateREQ } from '../request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from '../request/report-client-subscription-create.request';

function getRelationId(body: ReportClientSubscriptionCreateREQ | ReportClientFeedbackCreateREQ): number {
  if ('subscriptionId' in body) return body.subscriptionId;
  if ('feedbackId' in body) return body.feedbackId;

  throw new Error('Unable to resolve relationId: invalid DTO structure');
}
</file>

<file path="src/domains/report/report.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { Roles } from '../auth/auth-role.decorator';
import { AuthRoleGuard } from '../auth/auth-role.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { ReportDetailHelper } from './helper/report-detail.helper';
import { ReportService } from './report.service';
import { ReportClientFeedbackCreateREQ } from './request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from './request/report-client-subscription-create.request';
import { ReportListREQ } from './request/report-list.request';
import { ReportResolveFeedbackREQ } from './request/report-resolve-feeback.request';
import { ReportResolveSubscriptionREQ } from './request/report-resolve-subscription.request';

@Controller('reports')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class ReportController {
  constructor(private readonly reportService: ReportService) {}

  @Get()
  @Roles(AccountType.ADMIN, AccountType.STUDENT)
  async list(@Req() req: AuthRequestDTO, @Query() query: ReportListREQ) {
    const { data, count } = await this.reportService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data, count);
  }

  @Post('subscriptions')
  @Roles(AccountType.STUDENT)
  async createSubscriptionReport(@Req() req: AuthRequestDTO, @Body() body: ReportClientSubscriptionCreateREQ) {
    await this.reportService.createSubscriptionReport(req.user, body);

    return BaseResponse.ok();
  }

  @Post('feedbacks')
  @Roles(AccountType.STUDENT)
  async createFeedbackReport(@Req() req: AuthRequestDTO, @Body() body: ReportClientFeedbackCreateREQ) {
    await this.reportService.createReportFeedback(req.user, body);

    return BaseResponse.ok();
  }

  @Get(':reportId')
  @Roles(AccountType.ADMIN, AccountType.STUDENT)
  async detail(@Req() req: AuthRequestDTO, @Param('reportId', ParseIntPipe) reportId: number) {
    const { report, feedback, subscription } = await this.reportService.detail(req.user, reportId);

    const reportDtos = ReportDetailHelper.fromReportEntity(report, { feedback, subscription });

    return BaseResponse.of(reportDtos);
  }

  @Patch(':reportId/feedback-resolutions')
  @Roles(AccountType.ADMIN)
  async resolve(@Param('reportId', ParseIntPipe) reportId: number, @Body() body: ReportResolveFeedbackREQ) {
    await this.reportService.resolveFeedback(reportId, body);

    return BaseResponse.ok();
  }

  @Patch(':reportId/subscription-resolutions')
  @Roles(AccountType.ADMIN)
  async resolveSubscription(@Param('reportId', ParseIntPipe) reportId: number, @Body() body: ReportResolveSubscriptionREQ) {
    await this.reportService.resolveSubscriptionReport(reportId, body);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/domains/report/report.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from '../accounts/accounts.module';
import { FeedbackClientModule } from '../feedback/client/feedback-client.module';
import { SubscriptionClientModule } from '../subscription/client/subscription-client.module';
import { ReportController } from './report.controller';
import { ReportService } from './report.service';

@Module({
  imports: [AccountModule, SubscriptionClientModule, FeedbackClientModule],
  controllers: [ReportController],
  providers: [ReportService],
})
export class ReportModule {}
</file>

<file path="src/domains/report/report.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { ReportService } from './report.service';

describe('ReportService', () => {
  let service: ReportService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [ReportService],
    }).compile();

    service = module.get<ReportService>(ReportService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/report/report.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AccountStatus,
  AccountSuspensionType,
  AccountType,
  AudioRoomActivityHistory,
  CourseStatus,
  CourseSuspensionType,
  Feedback,
  NotificationRelationType,
  NotificationType,
  PaymentStatus,
  Report,
  ReportStatus,
  ReportType,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import {
  NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER,
  NOTIFICATION_SUSPENSION_COURSE_MAPPER,
} from 'src/shared/constants/notification.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import {
  REPORT_DURATION_TIME_QUERY,
  REPORT_FEEDBACK_TYPE,
  REPORT_SUBSCRIPTION_TYPE,
  ReportNotificationMap,
} from 'src/shared/constants/report.constant';
import { SUBSCRIPTION_ACTIVE_STATUS } from 'src/shared/constants/subscription.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { orNullWithCondition, orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { AccountService } from '../accounts/account.service';
import { AccountRESP } from '../accounts/response/account.response';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { FeedbackClientService } from '../feedback/client/feedback-client.service';
import { FeedbackGetPayload, FeedbackRelation } from '../feedback/shared/type';
import { NotificationHelper } from '../notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from '../notification/shared/types';
import { SubscriptionClientService } from '../subscription/client/subscription-client.service';
import { SubscriptionDetailRESP } from '../subscription/dto/response/subscription-detail.response';
import { SubscriptionGetPlayload } from '../subscription/shared/types';
import { ReportCreateHelper } from './helper/report-create.helper';
import { ReportDetailHelper } from './helper/report-detail.helper';
import { ReportListHelper } from './helper/report-list.helper';
import { ReportResolveHelper } from './helper/report-resolve.helper';
import { ReportClientFeedbackCreateREQ } from './request/report-client-feedback-create.request';
import { ReportClientSubscriptionCreateREQ } from './request/report-client-subscription-create.request';
import { ReportListREQ } from './request/report-list.request';
import { ReportResolveFeedbackREQ } from './request/report-resolve-feeback.request';
import { ReportResolveSubscriptionREQ } from './request/report-resolve-subscription.request';
import { ReportGetPayload } from './shared/type';

@Injectable()
export class ReportService {
  private readonly logger = new Logger(ReportService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly eventEmitterService: EventEmitterService,
    private readonly subscriptionService: SubscriptionClientService,
    private readonly feedbackService: FeedbackClientService,
    private readonly accountService: AccountService,
  ) {}

  async list(user: AuthUserDTO, query: ReportListREQ) {
    const count = await this.transactionHost.tx.report.count({ where: ReportListHelper.toQueryCondition(user, query) });
    const reports = await this.transactionHost.tx.report.findMany(ReportListHelper.toFindMany(user, query));

    const dto = reports.map(ReportListHelper.fromEntity);

    return { data: dto, count };
  }

  async detail(user: AuthUserDTO, reportId: number) {
    let report: ReportGetPayload;
    try {
      report = (await this.transactionHost.tx.report.findUniqueOrThrow(
        ReportDetailHelper.toFindUnique(reportId),
      )) as ReportGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.REPORT_NOT_FOUND);
    }

    const subsriptionDtos = await this.getSubscriptionDetail(user, report.subscriptionId);
    const feedbackDtos = await this.getFeedbackDetail(report.Feedback);

    return { report, subscription: subsriptionDtos, feedback: feedbackDtos };
  }

  async getFeedbackDetail(feedback: Feedback) {
    this.logger.log(' ~ ReportService ~ getFeedbackDetail ~ feedback:', feedback);
    if (!feedback || !feedback.subscriptionId) return null;

    // const { mentorData, studentInfo, subscription } = await this.subscriptionService.detail(feedback.subscriptionId);

    // const subscriptionDtos = SubscriptionDetailRESP.fromEntity(
    //   subscription,
    //   mentorData.mentor,
    //   AccountRESP.fromEntity(
    //     {
    //       ...studentInfo.account,
    //       dob: String(studentInfo.account.dob),
    //     },
    //     studentInfo.thumbnail,
    //   ),
    //   mentorData.thumbnail,
    // );

    // const { dtos: feedbackDtoList } = await this.feedbackService.list({
    //   relationId: subscription.courseId,
    //   relationType: FeedbackRelation.COURSE,
    // });

    // const audioCall = await this.transactionHost.tx.audioRoom.findFirst({
    //   where: { Subscription: { id: feedback.subscriptionId } },
    //   select: { id: true, cid: true },
    // });

    const reviewer = await this.accountService.getMe(feedback.reviewerId);

    return ReportDetailHelper.fromReportFeedback(feedback, {
      id: reviewer.account.id,
      name: reviewer.account.name,
      thumbnail: reviewer.thumbnail,
    });
  }

  async getSubscriptionDetail(user: AuthUserDTO, subscriptionId: number) {
    if (!subscriptionId) return null;
    const { mentorData, studentInfo, subscription } = await this.subscriptionService.detail(user, subscriptionId);

    const subscriptionDto = SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );

    const { dtos: feedbackDtoList } = await this.feedbackService.list({
      relationId: subscription.courseId,
      relationType: FeedbackRelation.COURSE,
    });

    const audioCall = await this.transactionHost.tx.audioRoom.findFirst({
      where: { Subscription: { id: subscriptionId } },
      select: { id: true, cid: true },
    });

    return ReportDetailHelper.fromReportSubscription({
      ...subscriptionDto,
      audioCall: orNullWithCondition(!!audioCall, { id: audioCall.id, cid: audioCall.cid }),
      feedbacks: feedbackDtoList.map((e) => ({
        id: e.id,
        courseRating: e.courseRating,
        mentorRating: e.mentorRating,
        courseReview: e.courseReview,
        mentorReview: e.mentorReview,
        updatedAt: e.updatedAt,
      })),
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resolveFeedback(reportId: number, body: ReportResolveFeedbackREQ) {
    const report = await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: { id: true, status: true, type: true },
    });

    if (!report) {
      throw new ActionFailedException(ActionFailed.REPORT_FEEDBACK_NOT_FOUND);
    } else if (!REPORT_FEEDBACK_TYPE.includes(report.type)) {
      throw new ActionFailedException(ActionFailed.REPORT_INVALID_TYPE, `The report ${report.type} is not feedback`);
    }

    const updatedReport = await this.transactionHost.tx.report.update({
      where: { id: report.id },
      data: { status: body.status, resolution: body.resolution },
      select: { id: true, reporterId: true, feedbackId: true },
    });

    await this.transactionHost.tx.feedback.delete({ where: { id: updatedReport.feedbackId } });

    //TODO: Warning the student about their negative feedback, and maybe ban them from the platform for 30 days

    this.createNotificationReportFeedback(updatedReport as Report, body);
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async resolveSubscriptionReport(reportId: number, body: ReportResolveSubscriptionREQ) {
    const report = await this.transactionHost.tx.report.findFirst({
      where: { id: reportId },
      select: { id: true, status: true, type: true, reporterId: true, subscriptionId: true },
    });

    if (!report) {
      throw new ActionFailedException(ActionFailed.REPORT_FEEDBACK_NOT_FOUND);
    } else if (!REPORT_SUBSCRIPTION_TYPE.includes(report.type)) {
      throw new ActionFailedException(ActionFailed.REPORT_INVALID_TYPE, `The report ${report.type} is not subscription`);
    }

    if (body.status === ReportStatus.RESOLVED) {
      //handle the pushnishment
      await this.handleSubscriptionPushnishment(report as Report, report.subscriptionId);
    }

    const updatedReport = await this.transactionHost.tx.report.update({
      where: { id: report.id },
      data: { status: body.status, resolution: body.resolution },
      select: { id: true, reporterId: true, subscriptionId: true },
    });

    this.logger.log(' ~ ReportService ~ resolveSubscriptionReport ~ Report Subscription after updated:', updatedReport);
  }

  //TODO: Check the logic of this method morning
  async handleSubscriptionPushnishment(report: Report, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findFirst({
      where: { id: subscriptionId },
      select: { id: true, audioRoomId: true, Course: { select: { id: true, creatorId: true, totalDuration: true } } },
    })) as SubscriptionGetPlayload;

    switch (report.type) {
      case ReportType.COURSE_UNQUALIFIED:
        //Get resolved report of COURSES within 3 months
        //Handle the punishment for courses
        await this.handleCourseSuspension(subscription, report);
        break;
      case ReportType.MENTOR_ISSUES:
        //Get resolved report of MENTORS within 3 months
        //Handle the punishment for mentors
        await this.handleMentorSuspension(subscription, report);
        break;
      default:
        break;
    }
  }

  /* Method: Handle Mentor Suspension */
  private async handleMentorSuspension(subscription: SubscriptionGetPlayload, report: Report) {
    this.logger.log(' ~ ReportService ~ handleMentorSuspension ~ subscriptionId:', subscription);

    const noOfReportMentors = await this.getResolvedMentorReportsCount(subscription.Course.creatorId);

    //Get resolved report of MENTORS within 3 months
    // If the number of reports is greater than or equal 5 and less than or equal 7, suspend the mentor for 3 days
    // If the number of reports is greater than 5 and less than 11, suspend the mentor for 7 days
    // If the number of reports is greater than greater than or equal 11, suspend the mentor permanently
    const suspensionType = ReportResolveHelper.calculateAccountSuspensionDays(noOfReportMentors);

    if (suspensionType !== AccountSuspensionType.ACCOUNT_NOT_SUSPENDED) {
      const course = await this.transactionHost.tx.course.findMany({
        where: { creatorId: subscription.Course.creatorId },
        select: { id: true },
      });

      for (const c of course) {
        await this.cancelAllRelatedSubscriptions(c.id, subscription.id, 'MENTOR');
      }
    }

    await this.suspendAccount(subscription.Course.creatorId, suspensionType);

    //Refund base on access time of mentors
    //If the access time of mentors contains more than 70% of the total duration of the course, refund 30% of the course fee
    //If the access time of mentors contains less than 70% of the total duration of the course, refund 50% of the course fee
    //If the access time of mentors contains less than 40% of the total duration of the course, refund 100% of the course fee
    await this.handleSubscriptionPaymentCut(subscription);

    const suspensionPayload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.MENTOR },
      subscription.Course.creatorId,
      NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER.get(suspensionType),
    );

    const resolveSubsriptionPayload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      report.reporterId,
      NotificationType.REPORT_RESOLVED,
    );

    runFunctionWithCondition(!!subscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, suspensionPayload);
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, resolveSubsriptionPayload);
    });
  }

  private async suspendAccount(accountId: number, suspensionType: AccountSuspensionType) {
    if (suspensionType === AccountSuspensionType.ACCOUNT_NOT_SUSPENDED) return;
    await this.transactionHost.tx.account.update({
      where: { id: accountId },
      data: { status: AccountStatus.SUSPENSIVE, suspendedAt: nowEpoch(), suspensionType },
      select: { id: true },
    });
  }

  private async getResolvedMentorReportsCount(creatorId: number) {
    return this.transactionHost.tx.report.count({
      where: {
        Subscription: { Course: { creatorId } },
        status: ReportStatus.RESOLVED,
        type: ReportType.MENTOR_ISSUES,
        createdAt: { gte: nowEpoch() - REPORT_DURATION_TIME_QUERY },
      },
    });
  }

  /* Method: Handle Course Suspension */
  private async handleCourseSuspension(subscription: SubscriptionGetPlayload, report: Report) {
    this.logger.log(' ~ ReportService ~ handleCourseSuspension ~ subscriptionId:', subscription);

    const noOfCourseReports = await this.getResolvedCourseReportsCount(subscription.Course.id);

    //Get resolved report of COURSES within 3 months
    // If the number of reports is greater than 3, suspend the mentor for 3 days
    // If the number of reports is greater than 5, suspend the mentor for 7 days
    // If the number of reports is greater than 7, suspend the mentor permanently
    const suspensionTypeCourse = ReportResolveHelper.calculateCourseSuspensionDays(noOfCourseReports);

    // Cancel all related subscriptions in active status relating to the course
    if (suspensionTypeCourse !== CourseSuspensionType.COURSE_NOT_SUSPENDED) {
      await this.cancelAllRelatedSubscriptions(subscription.Course.id, subscription.id, 'COURSE');
    }

    this.logger.log(' ~ ReportService ~ handleCourseSuspension ~ suspensionTypeCourse:', suspensionTypeCourse);
    const suspendedCourse = await this.suspendCourse(subscription.Course.id, suspensionTypeCourse);

    //Refund base on access time of mentors
    //If the access time of mentors contains more than 70% of the total duration of the course, refund 30% of the course fee
    //If the access time of mentors contains less than 70% of the total duration of the course, refund 50% of the course fee
    //If the access time of mentors contains less than 40% of the total duration of the course, refund 100% of the course fee
    //TODO: Implement refund for the subscription

    await this.handleSubscriptionPaymentCut(subscription);

    const suspensionPayloadCourse = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.COURSE },
      subscription.Course.creatorId,
      NOTIFICATION_SUSPENSION_COURSE_MAPPER.get(suspensionTypeCourse),
    );

    const resolveSubsriptionPayloadCourse = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      NotificationType.REPORT_RESOLVED,
    );

    runFunctionWithCondition(!!suspendedCourse, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, suspensionPayloadCourse);
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, resolveSubsriptionPayloadCourse);
    });
  }

  private async cancelAllRelatedSubscriptions(courseId: number, suspendSubscriptionId: number, type: 'MENTOR' | 'COURSE') {
    const canceledSubscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { id: courseId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS } },
      select: { id: true, status: true, accountId: true, Payment: { select: { id: true } } },
    });

    for (const sub of canceledSubscriptions) {
      if (sub.id === suspendSubscriptionId) continue;

      const updatedAudioRoom = orUndefinedWithCondition(sub.status === SubscriptionStatus.ACTIVE, {
        AudioRoom: { update: { data: { status: RoomStatus.CANCELLED } } },
      });
      const updatedPayment = orUndefinedWithCondition(!!sub.Payment, {
        Payment: {
          update: {
            data: { status: sub.status === SubscriptionStatus.ACTIVE ? PaymentStatus.REFUNDED : PaymentStatus.CANCELED },
          },
        },
      });

      const updatedSub = await this.transactionHost.tx.subscription.update({
        where: { id: sub.id },
        data: {
          canceledAt: nowEpoch(),
          status: SubscriptionStatus.CANCELED,
          ...updatedAudioRoom,
          ...updatedPayment,
        },
        select: { id: true },
      });

      const notificationType =
        sub.status === SubscriptionStatus.ACTIVE
          ? type === 'MENTOR'
            ? NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION
            : NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION
          : type === 'MENTOR'
            ? NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION
            : NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION;

      const cancelSubPayload = NotificationHelper.makeAppNotificationPayload(
        { id: sub.id, type: NotificationRelationType.SUBSCRIPTION },
        sub.accountId,
        notificationType,
      );

      runFunctionWithCondition(!!updatedSub, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, cancelSubPayload);
      });
    }
  }

  private async suspendCourse(courseId: number, suspensionType: CourseSuspensionType) {
    if (suspensionType === CourseSuspensionType.COURSE_NOT_SUSPENDED) return;

    return this.transactionHost.tx.course.update({
      where: { id: courseId },
      data: { status: CourseStatus.SUSPENDED, suspendedAt: nowEpoch(), suspensionType },
      select: { id: true },
    });
  }

  private async getResolvedCourseReportsCount(courseId: number) {
    return this.transactionHost.tx.report.count({
      where: {
        Subscription: { Course: { id: courseId } },
        status: ReportStatus.RESOLVED,
        type: ReportType.COURSE_UNQUALIFIED,
        createdAt: { gte: nowEpoch() - REPORT_DURATION_TIME_QUERY },
      },
    });
  }

  /* Method: Handle Subscription Payment Cut */
  private async handleSubscriptionPaymentCut(subscription: SubscriptionGetPlayload) {
    const audioRoomHistories = (await this.transactionHost.tx.audioRoomActivityHistory.findMany({
      where: { AudioRoomParticipant: { accountId: subscription.Course.creatorId, roomId: subscription.audioRoomId } },
      orderBy: { joinedAt: SortOrder.DESC },
      select: { joinedAt: true, leftAt: true },
    })) as AudioRoomActivityHistory[];

    const totalTimeInAudioRoom = ReportResolveHelper.getTotalTimeInAudioRoom(audioRoomHistories);

    this.logger.log(' ~ ReportService ~ handleSubscriptionPaymentCut ~ totalTimeInAudioRoom:', totalTimeInAudioRoom);

    await this.updateSubscriptionPaymentCut(subscription.id, totalTimeInAudioRoom, subscription.Course.totalDuration);
    //TODO: Implement NOTIFICATION
  }

  private async updateSubscriptionPaymentCut(subscriptionId: number, totalTimeInAudioRoom: number, totalDuration: number) {
    await this.transactionHost.tx.subscription.update({
      where: { id: subscriptionId },
      data: { wageStatus: ReportResolveHelper.calculatePaymentCut(totalTimeInAudioRoom, totalDuration) },
      select: { id: true },
    });
  }

  async createNotificationSubscriptionFeedback(report: Report, body: ReportResolveFeedbackREQ) {
    const isResolved = body.status === ReportStatus.RESOLVED;

    // notification receiver includes mentor (reporter) and feedback owner
    const reporterPayload = NotificationHelper.makeAppNotificationPayload(
      { id: report.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      isResolved ? NotificationType.REPORT_RESOLVED : NotificationType.REPORT_REJECTED,
    );

    if (isResolved) {
      const feeback = await this.transactionHost.tx.feedback.findUnique({
        where: { id: report.feedbackId },
        select: { id: true, reviewerId: true },
      });

      const feedbackPayload = NotificationHelper.makeAppNotificationPayload(
        { id: report.feedbackId, type: NotificationRelationType.FEEDBACK },
        report.reporterId,
        NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
      );

      this.logger.log(' ~ ReportService ~ createNotificationReportFeedback ~ feedbackPayload created:', feedbackPayload);

      runFunctionWithCondition(!!feeback, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, feedbackPayload);
      });
    }

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, reporterPayload);
    });
  }

  async createNotificationReportFeedback(report: Report, body: ReportResolveFeedbackREQ) {
    const isResolved = body.status === ReportStatus.RESOLVED;

    // notification receiver includes mentor (reporter) and feedback owner
    const reporterPayload = NotificationHelper.makeAppNotificationPayload(
      { id: report.id, type: NotificationRelationType.REPORT },
      report.reporterId,
      isResolved ? NotificationType.REPORT_RESOLVED : NotificationType.REPORT_REJECTED,
    );

    if (isResolved) {
      const feeback = await this.transactionHost.tx.feedback.findUnique({
        where: { id: report.feedbackId },
        select: { id: true, reviewerId: true },
      });

      const feedbackPayload = NotificationHelper.makeAppNotificationPayload(
        { id: report.feedbackId, type: NotificationRelationType.FEEDBACK },
        report.reporterId,
        NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
      );

      this.logger.log(' ~ ReportService ~ createNotificationReportFeedback ~ feedbackPayload created:', feedbackPayload);

      runFunctionWithCondition(!!feeback, () => {
        this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, feedbackPayload);
      });
    }

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, reporterPayload);
    });
  }

  async createSubscriptionReport(user: AuthUserDTO, body: ReportClientSubscriptionCreateREQ) {
    let subscription: SubscriptionGetPlayload;
    if (!REPORT_SUBSCRIPTION_TYPE.includes(body.type)) {
      throw new ActionFailedException(
        ActionFailed.REPORT_INVALID_TYPE,
        `The type ${body.type} is invalid, the types are ${REPORT_SUBSCRIPTION_TYPE.join(', ')}`,
      );
    }

    try {
      subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow({
        where: { id: body.subscriptionId, accountId: user.accountId },
        select: { id: true, courseId: true },
      })) as SubscriptionGetPlayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);
    }

    const report = await this.transactionHost.tx.report.create(
      ReportCreateHelper.toCreate<ReportClientSubscriptionCreateREQ>(user, body),
    );

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      admin.id,
      ReportNotificationMap.get(body.type),
    );

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });
  }

  async createReportFeedback(user: AuthUserDTO, body: ReportClientFeedbackCreateREQ) {
    if (!REPORT_FEEDBACK_TYPE.includes(body.type)) {
      throw new ActionFailedException(
        ActionFailed.REPORT_INVALID_TYPE,
        `The type ${body.type} is invalid, the types are ${REPORT_FEEDBACK_TYPE.join(', ')}`,
      );
    }

    let feedback: FeedbackGetPayload;
    try {
      feedback = (await this.transactionHost.tx.feedback.findUniqueOrThrow({
        where: { id: body.feedbackId, reviewerId: user.accountId },
        select: { id: true },
      })) as FeedbackGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.FEEDBACK_NOT_BELONG_TO_REVIEWER);
    }

    const report = await this.transactionHost.tx.report.create(
      ReportCreateHelper.toCreate<ReportClientFeedbackCreateREQ>(user, body),
    );

    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: feedback.id, type: NotificationRelationType.FEEDBACK },
      admin.id,
      ReportNotificationMap.get(body.type),
    );

    runFunctionWithCondition(!!report, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });
  }
}
</file>

<file path="src/domains/student/client/student-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StudentClientController } from './student-client.controller';
import { StudentClientService } from './student-client.service';

describe('StudentClientController', () => {
  let controller: StudentClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [StudentClientController],
      providers: [StudentClientService],
    }).compile();

    controller = module.get<StudentClientController>(StudentClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/student/client/student-client.controller.ts">
import { Controller } from '@nestjs/common';
import { StudentClientService } from './student-client.service';

@Controller('student-client')
export class StudentClientController {
  constructor(private readonly studentClientService: StudentClientService) {}
}
</file>

<file path="src/domains/student/client/student-client.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from 'src/domains/auth/auth.module';
import { PrismaModule } from 'src/services/prisma/prisma.module';
import { StudentClientController } from './student-client.controller';
import { StudentClientService } from './student-client.service';

@Module({
  imports: [PrismaModule, AuthModule],
  controllers: [StudentClientController],
  providers: [StudentClientService],
})
export class StudentClientModule {}
</file>

<file path="src/domains/student/client/student-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StudentClientService } from './student-client.service';

describe('StudentClientService', () => {
  let service: StudentClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [StudentClientService],
    }).compile();

    service = module.get<StudentClientService>(StudentClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/student/client/student-client.service.ts">
import { Injectable } from '@nestjs/common';
import { AuthService } from 'src/domains/auth/auth.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';

@Injectable()
export class StudentClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly authService: AuthService,
  ) {}
}
</file>

<file path="src/domains/student/shared/types.ts">
import { Prisma } from '@prisma/client';

export type StudentGetPayload = Prisma.StudentGetPayload<{ include: { Account: true } }>;
</file>

<file path="src/domains/student/student.module.ts">
import { Module } from '@nestjs/common';
import { StudentClientModule } from './client/student-client.module';

@Module({
  imports: [StudentClientModule],
})
export class StudentModule {}
</file>

<file path="src/domains/subscription/client/subscription-client.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Put, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionClientService } from './subscription-client.service';

@Controller('client/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class SubscriptionClientController {
  constructor(private readonly subscriptionClientService: SubscriptionClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByAccount(req.user);

    return BaseResponse.of(subscriptions);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionClientService.getSubscriptionDetailWithAccount(
      req.user,
      id,
    );

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }

  @Patch(':id/cancel')
  @Roles(AccountType.STUDENT)
  async cancel(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.subscriptionClientService.cancel(req.user, id);

    return BaseResponse.ok();
  }

  @Get('mentors/:mentorId')
  @Roles(AccountType.STUDENT)
  async listByMentor(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByMentorId(mentorId);

    return BaseResponse.of(subscriptions);
  }

  @Post('courses/:courseId')
  @Roles(AccountType.STUDENT)
  async createSubscription(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: SubscriptionCreateREQ,
  ) {
    const subscription = await this.subscriptionClientService.create(req.user, courseId, body);

    return BaseResponse.of({ subscriptionId: subscription.id });
  }

  @Post(':id/payments')
  @Roles(AccountType.STUDENT)
  async createPayment(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) id: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.makePayment(req.user, id, {
      ...body,
      ipAddr: req.ip,
    });

    return BaseResponse.of(payment);
  }

  @Put(':id/payments')
  async continue(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) subscriptionId: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.continue(req.user, subscriptionId, { ...body, ipAddr: req.ip });

    return BaseResponse.of(payment);
  }

  @Patch('approvement')
  @Roles(AccountType.MENTOR)
  async approveSubscription(@Req() req: AuthRequestDTO, @Body() body: SubscriptionMentorApproveREQ) {
    const subscriptionId = await this.subscriptionClientService.approve(req.user, body);

    return BaseResponse.of({ subscriptionId: subscriptionId });
  }
}
</file>

<file path="src/domains/subscription/client/subscription-client.module.ts">
import { forwardRef, Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { AudioCallModule } from 'src/domains/audio-call/audio-call.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { PaymentClientModule } from 'src/domains/payment/client/payment-client.module';
import { SubscriptionClientController } from './subscription-client.controller';
import { SubscriptionClientService } from './subscription-client.service';

@Module({
  imports: [forwardRef(() => MentorClientModule), AccountModule, PaymentClientModule, AudioCallModule],
  controllers: [SubscriptionClientController],
  providers: [SubscriptionClientService],
  exports: [SubscriptionClientService],
})
export class SubscriptionClientModule {}
</file>

<file path="src/domains/subscription/client/subscription-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionClientService } from './subscription-client.service';

describe('SubscriptionClientService', () => {
  let service: SubscriptionClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionClientService],
    }).compile();

    service = module.get<SubscriptionClientService>(SubscriptionClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/client/subscription-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import {
  AccountType,
  Course,
  CourseStatus,
  NotificationRelationType,
  NotificationType,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AudioCallService } from 'src/domains/audio-call/audio-call.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { PaymentClientService } from 'src/domains/payment/client/payment-client.service';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { DAY_OF_WEEK } from 'src/shared/constants/date.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import {
  EXPIRED_PENDING_SUBSCRIPTION,
  EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
  SUBSCRIPTION_ACTIVE_STATUS,
  SUBSCRIPTION_NOT_CANCELED_STATUS,
  SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO,
} from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { getDayOfWeek, parseDateToHyphen, parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionListRESP } from '../dto/response/subscription-list.response';
import { SubscriptionCreateHelper } from '../helper/subcription-create.helper';
import { SubscriptionApproveHelper } from '../helper/subscription-approve.helper';
import { parseBookingDateTimeToEpoch } from '../helper/subscription-common.helper';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionClientService {
  private readonly logger = new Logger(SubscriptionClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
    private readonly audioCallService: AudioCallService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Cron('0 0 * * * *', {
    name: 'handle-expired-pending-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.PENDING },
      select: {
        mentorScheduleId: true,
        status: true,
        createdAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const createdAt = parseEpoch(subscription.createdAt);

        if (now - createdAt > EXPIRED_PENDING_SUBSCRIPTION) {
          this.logger.warn(
            ` ~ SubscriptionClientService ~ Cron ~ handleExpiredSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because mentor not reponse after 2 days`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: { status: SubscriptionStatus.EXPIRED, canceledAt: nowEpoch() },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 * * * *', {
    name: 'handle-expired-paid-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredApprovedSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.ACCEPTED },
      select: {
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const approvedAt = parseEpoch(subscription.approvedAt);

        if (now - approvedAt > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
          this.logger.warn(
            ` ~ SubscriptionClientService ~ Cron ~ handleExpiredApprovedSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because student not paid after 1 day`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.EXPIRED,
              Payment: { update: { status: PaymentStatus.EXPIRED } },
              canceledAt: nowEpoch(),
            },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 0 * * *', {
    name: 'handle-suspended-course-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleSuspendedCourseSubscription() {
    const courses = await this.transactionHost.tx.course.findMany({
      where: { status: CourseStatus.SUSPENDED, ...IS_ACTIVE_NESTED },
      select: { id: true, status: true },
    });

    await Promise.all(
      courses.map(async (course) => {
        const subscriptions = await this.transactionHost.tx.subscription.findMany({
          where: { courseId: course.id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
          select: { id: true, audioRoomId: true, Payment: { select: { id: true } } },
        });

        for (const subscription of subscriptions) {
          await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.CANCELED,
              canceledAt: nowEpoch(),
              AudioRoom: { update: { status: RoomStatus.FINISHED } },
              Payment: { update: { status: PaymentStatus.REFUNDED } },
            },
            select: { id: true },
          });

          //TODO: Refund money to student
        }
      }),
    );
  }

  async listSubscriptionByAccount(user: AuthUserDTO) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(SubscriptionListHelper.toFindManyWithAccount(user));

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData =
          user.accountType !== AccountType.MENTOR
            ? await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId)
            : null;

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );
  }

  async listSubscriptionByMentorId(mentorId: number) {
    const { mentor } = await this.mentorClientService.detail(mentorId);

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: mentor.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS } },
      select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true, status: true },
    });

    return subscriptions.map((subscription) => {
      return {
        id: subscription.id,
        status: subscription.status,
        courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
        courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      };
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, courseId: number, body: SubscriptionCreateREQ): Promise<any> {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, startDate: true, endDate: true, price: true, creatorId: true },
    })) as Course;

    const existedSubscriptions = (await this.transactionHost.tx.subscription.findMany(
      SubscriptionCreateHelper.toFindManyByAccountId(user.accountId),
    )) as SubscriptionGetPlayload[];

    // 1. Check for active subscription by the user for the same course
    const existedAccountSubscriptions = existedSubscriptions.filter((subscription) => subscription.Course.id === course.id);

    if (!isEmpty(existedAccountSubscriptions) && SUBSCRIPTION_ACTIVE_STATUS.includes(existedAccountSubscriptions[0]?.status)) {
      this.logger.error(` ~ SubscriptionClientService ~ create ~ there are same courses subscribed which are ACTIVE`);
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE);
    } else if (!isEmpty(existedAccountSubscriptions)) {
      //TODO: Uncomment this code when the feature is ready
      // const now = nowEpoch();
      // const lastSubscriptionInActive =
      //   parseEpoch(existedAccountSubscriptions[0].rejectedAt) || parseEpoch(existedAccountSubscriptions[0].canceledAt);
      //
      // const isStillBanned = now - lastSubscriptionInActive > EXPIRED_PENDING_SUBSCRIPTION;
      // if (lastSubscriptionInActive && isStillBanned) {
      //   this.logger.log(
      //     ` ~ SubscriptionClientService ~ create ~ the user with account id ${user.accountId} can not subscribe to this course with course id ${course.id}`,
      //   );
      //   throw new ActionFailedException(ActionFailed.SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS);
      // }
    }

    // 2. Check for mentor schedule conflicts
    const schedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: body.mentorScheduleId, Mentor: { Account: { id: course.creatorId } } },
    });

    const conflictSchedule = await this.transactionHost.tx.subscription.findFirst({
      where: {
        status: { in: SUBSCRIPTION_ACTIVE_STATUS },
        mentorScheduleId: body.mentorScheduleId,
        courseAccessStartAt: parseBookingDateTimeToEpoch(body.date, schedule.startTime),
      },
      select: { id: true },
    });

    // Check if schedule is already booked
    if (conflictSchedule) {
      this.logger.error(
        ` ~ SubscriptionClientService ~ create ~ This schedule has been booked with the subscription id ${conflictSchedule.id}`,
      );
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);
    }

    //3. Check for overlapping subscriptions with other mentors
    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const isNotMentorSubscriptionActive = existedSubscriptions.some((subscription) => {
      if (
        SUBSCRIPTION_ACTIVE_STATUS.includes(subscription.status) &&
        subscription.Course.creatorId !== course.creatorId &&
        Number(parseEpoch(subscription.courseAccessStartAt)) === courseAccessStartAt
      ) {
        this.logger.error(
          ` ~ SubscriptionClientService ~ isNotMentorSubscriptionActive ~ This subscription has been scheduled overlap with the subscription id ${subscription.id} and the course id ${subscription.Course.id}`,
        );
        return true;
      }
    });

    if (isNotMentorSubscriptionActive) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE);
    }

    const parsedDate = parseDateToHyphen(body.date);
    const dayOfWeek = getDayOfWeek(parsedDate);
    this.logger.log(` ~ SubscriptionClientService ~ create ~ the date ${body.date} is ${DAY_OF_WEEK[dayOfWeek]}`);
    this.logger.log(` ~ SubscriptionClientService ~ create ~ the schedule day is ${schedule.dayOfWeek}`);

    if (schedule.dayOfWeek !== DAY_OF_WEEK[dayOfWeek]) {
      throw new ActionFailedException(
        ActionFailed.MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK,
        `the schedule day is ${schedule.dayOfWeek} but you choose ${DAY_OF_WEEK[dayOfWeek]}`,
      );
    }

    const subscription = await this.transactionHost.tx.subscription.create(
      SubscriptionCreateHelper.toCreate(user, course, schedule, body),
    );

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      course.creatorId,
      NotificationType.SUBSCRIPTION_CREATED,
    );
    runFunctionWithCondition(!!subscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return subscription;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async approve(courseCreator: AuthUserDTO, body: SubscriptionMentorApproveREQ) {
    await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      select: { id: true },
    });

    const updatedSubscription = await this.transactionHost.tx.subscription.update(
      SubscriptionApproveHelper.toApprove(body, courseCreator),
    );

    //Notification: send notification to student
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
      updatedSubscription.accountId,
      body.isApproved ? NotificationType.SUBSCRIPTION_APPROVED : NotificationType.SUBSCRIPTION_REJECTED,
    );
    runFunctionWithCondition(!!updatedSubscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedSubscription.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async makePayment(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { originalPrice: true, status: true, accountId: true },
    })) as SubscriptionGetPlayload;

    if (subscription.status !== SubscriptionStatus.ACCEPTED)
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_MAKE_PAYMENT,
        `Subscription status is ${subscription.status}`,
      );

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const { payment, url } = await this.paymentClientService.create(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  async continue(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { id: true, originalPrice: true, status: true, accountId: true, approvedAt: true },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const now = nowEpoch();
    if (
      now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED ||
      subscription.status === SubscriptionStatus.EXPIRED
    ) {
      this.logger.warn(
        ` ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      // throw new ActionFailedException(ActionFailed.SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT);
    } else if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    const { payment, url } = await this.paymentClientService.continue(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancel(user: AuthUserDTO, subscriptionId: number) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: {
        status: true,
        accountId: true,
        mentorScheduleId: true,
        audioRoomId: true,
        Course: { select: { creatorId: true } },
      },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    if (SUBSCRIPTION_NOT_CANCELED_STATUS.includes(subscription.status)) {
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_CANCEL,
        `Subscription status in ${SUBSCRIPTION_NOT_CANCELED_STATUS} can not be canceled`,
      );
    }

    if (SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO.includes(subscription.status)) {
      await this.audioCallService.cancelCall(subscription.audioRoomId);
    }

    await this.transactionHost.tx.subscription.update({
      where: { id: subscriptionId },
      data: {
        status: subscription.status === SubscriptionStatus.ACTIVE ? SubscriptionStatus.ENDED : SubscriptionStatus.CANCELED,
        canceledAt: nowEpoch(),
      },
    });
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetailWithAccount(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    if (subscription.Account.id !== user.accountId && user.accountType === AccountType.STUDENT) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);
    } else if (subscription.Course.creatorId !== user.accountId && user.accountType === AccountType.MENTOR) {
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    return { subscription, mentorData, studentInfo };
  }

  async detail(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/dto/request/subscription-admin-list.request.ts">
import { SubscriptionStatus, WageStatus } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';

export class SubscriptionAdminListREQ extends PaginationREQ {
  @NameValidator()
  @IsOptional()
  mentorName?: string;

  @NameValidator()
  @IsOptional()
  courseName?: string;

  @NameValidator()
  @IsOptional()
  studentName?: string;

  @IsEnum(SubscriptionStatus)
  @IsOptional()
  status?: SubscriptionStatus;

  @IsEnum(WageStatus)
  @IsOptional()
  wageStatus?: WageStatus;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-create.request.ts">
import { IsOptional, IsString, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class SubscriptionCreateREQ {
  @OnlyDate()
  date: string;

  @IdValidator()
  mentorScheduleId: number;

  @IsString()
  @MaxLength(500)
  message: string;

  @IsString()
  @IsOptional()
  ipAddr: string;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-mentor-approve.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class SubscriptionMentorApproveREQ {
  @IdValidator()
  subscriptionId: number;

  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-payment-create.ts">
import { IsOptional, IsString } from 'class-validator';

export class SubscriptionPaymentCreateREQ {
  @IsString()
  message: string;

  @IsString()
  @IsOptional()
  ipAddr?: string;
}
</file>

<file path="src/domains/subscription/dto/response/subscription-admin-list.response.ts">
import { SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { SubscriptionMentorListRESP } from '../../shared/types';

export class SubscriptionAdminListRESP {
  id: string;
  status: SubscriptionStatus;
  wageStatus: SubscriptionStatus;
  originalPrice: number;
  courseAccessStartAt: Date;
  courseAccessEndAt: Date;
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  course: { id: number; name: string };

  static fromEntity(
    subscription: any,
    studentInfo: AccountRESP,
    mentorInfo: SubscriptionMentorListRESP,
  ): SubscriptionAdminListRESP {
    return {
      id: subscription.id,
      status: subscription.status,
      wageStatus: subscription.wageStatus,
      originalPrice: subscription.originalPrice,
      courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      course: { id: subscription.Course.id, name: subscription.Course.name },
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-detail.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus, WageStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionGetPlayload, SubscriptionReportRESP } from '../../shared/types';

export class SubscriptionDetailRESP {
  id: number;
  status: SubscriptionStatus;
  wageStatus: WageStatus;
  orginalPrice: number;
  message: string;
  courseAccessStartAt: number;
  courseAccessEndAt: number;
  course: Pick<CourseClientDetailRESP, 'id' | 'name' | 'status' | 'description'>;
  mentor: Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
  student: AccountRESP;
  audiCall?: { status: RoomStatus; cid: string };
  report?: SubscriptionReportRESP;
  payment?: { status: PaymentStatus; price: number };

  static fromEntity(
    e: SubscriptionGetPlayload,
    mentor: MentorGetPayload,
    student: AccountRESP,
    thumbnail?: ImageRESP,
  ): SubscriptionDetailRESP {
    return {
      id: e.id,
      status: e.status,
      wageStatus: e.wageStatus,
      orginalPrice: parseDecimalNumber(e.originalPrice),
      message: e.message,
      courseAccessStartAt: parseEpoch(e.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(e.courseAccessEndAt),
      course: { id: e.Course.id, name: e.Course.name, status: e.Course.status, description: e.Course.description },
      mentor: { id: mentor.id, accountId: mentor.accountId, name: mentor.Account.name, thumbnail: thumbnail },
      payment: orNullWithCondition(!!e.Payment, {
        status: e.Payment?.status,
        price: parseDecimalNumber(e.Payment?.price),
      }),
      audiCall: orNullWithCondition(!!e.AudioRoom, {
        status: e.AudioRoom?.status,
        cid: e.AudioRoom?.cid,
      }),
      report: orNullWithCondition(!!e.Report, {
        id: e.Report?.id,
        type: e.Report?.type,
        description: e.Report?.description,
        status: e.Report?.status,
        resolution: e.Report?.resolution,
      }),
      student: student,
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-list.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import {
  SubscriptionFeedbackRESP,
  SubscriptionGetPlayload,
  SubscriptionMentorListRESP,
  SubscriptionReportRESP,
} from '../../shared/types';

export class SubscriptionListRESP {
  id: number;
  status: SubscriptionStatus;
  originalPrice: number;
  courseStartAt: string;
  courseEndAt: string;
  course: { id: number; name: string };
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  audiCall: { status: RoomStatus; cid: string };
  payment?: { id: true; status: PaymentStatus; price: number };
  feedback?: SubscriptionFeedbackRESP;
  report?: SubscriptionReportRESP;
  canceledAt?: string;
  approvedAt?: string;
  rejectedAt?: string;

  static fromEntity(
    subcription: SubscriptionGetPlayload,
    studentInfo: AccountRESP,
    audiCall: { status: RoomStatus; cid: string },
    mentorInfo?: SubscriptionMentorListRESP,
  ): SubscriptionListRESP {
    return {
      id: subcription.id,
      status: subcription.status,
      originalPrice: parseDecimalNumber(subcription.originalPrice),
      courseStartAt: parseEpoch(subcription.courseAccessStartAt),
      courseEndAt: parseEpoch(subcription.courseAccessEndAt),
      canceledAt: parseEpoch(subcription.canceledAt),
      approvedAt: parseEpoch(subcription.approvedAt),
      rejectedAt: parseEpoch(subcription.rejectedAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      report: orNullWithCondition(!!subcription.Report, {
        id: subcription.Report?.id,
        type: subcription.Report?.type,
        description: subcription.Report?.description,
        status: subcription.Report?.status,
        resolution: subcription.Report?.resolution,
      }),
      course: { id: subcription.Course.id, name: subcription.Course.name },
      audiCall: audiCall,
      payment: orNullWithCondition(!!subcription.Payment, {
        id: subcription.Payment?.id,
        status: subcription.Payment?.status,
        price: parseDecimalNumber(subcription.Payment?.price),
      }),
      feedback: orNullWithCondition(!!subcription.Feedback, {
        id: subcription.Feedback?.id,
        courseRating: subcription.Feedback?.courseRating,
        mentorRating: subcription.Feedback?.mentorRating,
        courseReview: subcription.Feedback?.courseReview,
        mentorReview: subcription.Feedback?.mentorReview,
      }),
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subcription-create.helper.ts">
import {
  Course,
  MentorSchedule,
  NotificationRelationType,
  NotificationScope,
  NotificationType,
  Prisma,
  Subscription,
  SubscriptionStatus,
} from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { NotificationAppHandlerPayload } from 'src/domains/notification/shared/types';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { parseBookingDateTimeToEpoch } from './subscription-common.helper';

export class SubscriptionCreateHelper {
  static toCreate(
    user: AuthUserDTO,
    course: Course,
    schedule: MentorSchedule,
    body: SubscriptionCreateREQ,
  ): Prisma.SubscriptionCreateArgs {
    if (!course) return;

    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const courseAccessEndAt = parseBookingDateTimeToEpoch(body.date, schedule.endTime);

    return {
      data: {
        message: body.message,
        originalPrice: course.price,
        status: SubscriptionStatus.PENDING,
        courseAccessEndAt: courseAccessEndAt,
        courseAccessStartAt: courseAccessStartAt,
        Course: connectRelation(course.id),
        Account: connectRelation(user.accountId),
        MentorSchedule: connectRelation(body.mentorScheduleId),
      },
      select: { id: true },
    };
  }

  static toFindMany(courseId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Course: { id: courseId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toFindManyByAccountId(accountId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Account: { id: accountId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true } },
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toCreateNotification(subcription: Subscription, targetAccountId: number): NotificationAppHandlerPayload {
    return {
      notificationREQ: {
        relationId: subcription.id,
        relationType: NotificationRelationType.SUBSCRIPTION,
        type: NotificationType.SUBSCRIPTION_CREATED,
        scopes: [NotificationScope.INDIVIDUAL],
        targetAccountId: targetAccountId,
      },
      data: {
        title: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).title,
        topic: NotificationType.SUBSCRIPTION_CREATED,
        body: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).content,
      },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-approve.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';

export class SubscriptionApproveHelper {
  static toApprove(body: SubscriptionMentorApproveREQ, courseCreator: AuthUserDTO): Prisma.SubscriptionUpdateArgs {
    const timeUpdate = body.isApproved ? { approvedAt: nowEpoch() } : { rejectedAt: nowEpoch() };

    return {
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      data: {
        status: body.isApproved ? SubscriptionStatus.ACCEPTED : SubscriptionStatus.REJECTED,
        ...timeUpdate,
      },
      select: { id: true, accountId: true, status: true },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-common.helper.ts">
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseDateTimeToEpochV2 } from 'src/shared/parsers/datetime.parse';

export const parseBookingDateTimeToEpoch = (date: string, time: string) => {
  const [day, month, year] = date.split('/');
  const [hour, minute] = time.split(':');

  if (!time) throw new ActionFailedException(ActionFailed.DATE_TIME_INVALID);

  const dateAfterParse = new Date(`${year}-${month}-${day}T${hour}:${minute}:00.00Z`);

  const epoch = parseDateTimeToEpochV2(dateAfterParse.toISOString());

  const now = Date.now();

  if (epoch < now) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW);

  return epoch;
};

export const compareDateFromEpoch = (epoch1: number, epoch2: number) => {
  const date1 = new Date(epoch1);
  const date2 = new Date(epoch2);

  return (
    date1.getDate() === date2.getDate() && date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear()
  );
};
</file>

<file path="src/domains/subscription/helper/subscription-detail.helper.ts">
import { AccountType, Prisma, ReportStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class SubscriptionDetailHelper {
  static toFindUnique(subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: { select: { id: true, type: true, description: true, status: true, resolution: true } },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindUniqueWithAccount(user: AuthUserDTO, subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true },
        },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindByAccount(user: AuthUserDTO, id: number): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT:
        return {
          accountId: user.accountId,
          id: id,
        };

      case AccountType.MENTOR:
        return {
          Course: {
            creatorId: user.accountId,
          },
          id: id,
        };
      case AccountType.ADMIN:
        return {};
      default:
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-list.helper.ts">
import { AccountType, Prisma, ReportStatus } from '.prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';

export class SubscriptionListHelper {
  static toFindMany(): Prisma.SubscriptionFindManyArgs {
    return {
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: SubscriptionListHelper.toFilterByAccount(user),
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        canceledAt: true,
        approvedAt: true,
        rejectedAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true, createdAt: true },
        },
        Feedback: { select: { id: true, courseRating: true, mentorRating: true, courseReview: true, mentorReview: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = SubscriptionListHelper.toFilterByCondition(query);
    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: defaultSortDesc,
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Account: { select: { id: true, name: true } },
        Course: { select: { id: true, name: true, Creator: { select: { id: true, name: true } } } },
      },
    };
  }

  static toFilterByCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs['where'] {
    const studentName = orUndefinedWithCondition(!!query.studentName, {
      Account: parsePrismaSearch('name', query.studentName),
    });

    const mentorName = orUndefinedWithCondition(!!query.mentorName, {
      Course: {
        Creator: parsePrismaSearch('name', query.mentorName),
      },
    });

    const courseName = orUndefinedWithCondition(!!query.courseName, {
      Course: parsePrismaSearch('name', query.courseName),
    });

    return leanObject({
      ...studentName,
      ...mentorName,
      ...courseName,
      status: query.status,
      wageStatus: query.wageStatus,
    });
  }

  static toFilterByAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT: {
        return { accountId: user.accountId };
      }
      case AccountType.MENTOR: {
        return {
          Course: { creatorId: user.accountId },
        };
      }
      default:
        return;
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-make-payment.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { Nil } from 'src/shared/generics/type.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';

export class SubscriptionMakePaymentHelper {
  static toActivate(
    subscriptionId: number,
    subscriptionStatus: SubscriptionStatus,
    callId: number,
  ): Prisma.SubscriptionUpdateArgs {
    const audioRoom = orUndefinedWithCondition(subscriptionStatus === SubscriptionStatus.ACTIVE, {
      AudioRoom: connectRelation(callId),
    });

    return {
      where: { id: subscriptionId },
      data: { status: subscriptionStatus, ...audioRoom },
      select: { id: true },
    };
  }

  static parseAudioCallStartsAt(epoch: Nil<number>): string {
    if (!epoch) return;
    const [year, month, day, hour, minute, second] = parseEpochToDate(epoch)
      .split(/[-:\s]/)
      .map((value) => parseInt(value, 10));

    console.log(year, month, day, hour, minute, second); // Output: 2024 12 16 19 0 0

    // parse date time in this format DD/MM/YY to YYYY-MM-dd
    const parsedDate = `${day}/${month}/${year} ${hour}:${minute}:${second}`;
    return parsedDate;
  }
}
</file>

<file path="src/domains/subscription/shared/types.ts">
import { Prisma } from '@prisma/client';
import { FeedbackListRESP } from 'src/domains/feedback/response/feedback-list.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { ReportDetailRESP } from 'src/domains/report/response/report-detail.response';

export type SubscriptionGetPlayload = Prisma.SubscriptionGetPayload<{
  include: { Course: true; Account: true; Payment: true; AudioRoom: true; Feedback: true; Report: true };
}>;

export type SubscriptionMentorListRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;

export type SubscriptionFeedbackRESP = Pick<
  FeedbackListRESP,
  'id' | 'courseRating' | 'mentorRating' | 'courseReview' | 'mentorReview'
>;

export type SubscriptionReportRESP = Pick<ReportDetailRESP, 'id' | 'type' | 'description' | 'status' | 'resolution'>;
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminController', () => {
  let controller: SubscriptionAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SubscriptionAdminController],
      providers: [SubscriptionAdminService],
    }).compile();

    controller = module.get<SubscriptionAdminController>(SubscriptionAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionAdminService } from './subscription-admin.service';

@Controller('admin/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class SubscriptionAdminController {
  constructor(private readonly subscriptionAdminService: SubscriptionAdminService) {}

  @Get()
  async listSubscription(@Query() query: SubscriptionAdminListREQ) {
    const { subscriptionDtos, count } = await this.subscriptionAdminService.listSubscription(query);

    return PaginationResponse.ofWithTotal(subscriptionDtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionAdminService.getSubscriptionDetail(id);

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }
}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

@Module({
  imports: [AccountModule, MentorClientModule],
  controllers: [SubscriptionAdminController],
  providers: [SubscriptionAdminService],
})
export class SubscriptionAdminModule {}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminService', () => {
  let service: SubscriptionAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionAdminService],
    }).compile();

    service = module.get<SubscriptionAdminService>(SubscriptionAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionAdminListRESP } from '../dto/response/subscription-admin-list.response';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionAdminService {
  private readonly logger = new Logger(SubscriptionAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    // private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
  ) {}

  async listSubscription(query: SubscriptionAdminListREQ) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      SubscriptionListHelper.toFindManyWithCondition(query),
    );

    const count = await this.transactionHost.tx.subscription.count({
      where: SubscriptionListHelper.toFilterByCondition(query),
    });

    const subscriptionDtos = await Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);

        return SubscriptionAdminListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );

    return { subscriptionDtos, count };
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetail(subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUnique(subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/subscription.module.ts">
import { Module } from '@nestjs/common';
import { SubscriptionClientModule } from './client/subscription-client.module';
import { SubscriptionAdminModule } from './subscription-admin/subscription-admin.module';

@Module({
  imports: [SubscriptionClientModule, SubscriptionAdminModule],
})
export class SubscriptionModule {}
</file>

<file path="src/domains/utility/request/utility-enum.request.ts">
import { ApiPropertyOptional } from '@nestjs/swagger';
import { Transform } from 'class-transformer';
import { IsNotEmpty, IsString } from 'class-validator';

export class UtilityEnumREQ {
  @IsString({
    each: true,
  })
  @IsNotEmpty({
    each: true,
  })
  @Transform(({ value }) => (Array.isArray(value) ? value : [value]))
  @ApiPropertyOptional({
    type: [String],
    description: 'List of keys to get',
    example: ['SortOrder', 'AccountType', 'ActionFailed'],
  })
  keys: string[] = [];
}
</file>

<file path="src/domains/utility/utility.controller.ts">
import { Controller, Get, Query } from '@nestjs/common';

import { ApiResponse, ApiTags } from '@nestjs/swagger';
import { UtilityEnumREQ } from './request/utility-enum.request';
import { UtilityService } from './utility.service';

@Controller('utilities')
@ApiTags('Utilities')
export class UtilityController {
  constructor(private readonly utilityService: UtilityService) {}

  @Get('enums')
  @ApiResponse({
    status: 200,
    description: 'Get all enums',
    example: {
      data: {
        SortOrder: ['asc', 'desc'],
        AccountType: ['STUDENT', 'MENTOR', 'ADMIN'],
        ActionFailed: ['ACCOUNT_NOT_FOUND', 'INCORRECT_PASSWORD', 'AUTH_PHONE_EXISTED', 'AUTH_EMAIL_EXISTED'],
      },
      message: 'OK',
    },
  })
  findAll(@Query() body: UtilityEnumREQ) {
    return this.utilityService.findAll(body);
  }
}
</file>

<file path="src/domains/utility/utility.module.ts">
import { Module } from '@nestjs/common';
import { UtilityController } from './utility.controller';
import { UtilityService } from './utility.service';

@Module({
  controllers: [UtilityController],
  providers: [UtilityService],
})
export class UtilityModule {}
</file>

<file path="src/domains/utility/utility.service.ts">
import { Injectable, UnprocessableEntityException } from '@nestjs/common';
import { $Enums } from '@prisma/client';
import { SortOrder } from 'src/shared/enums/query.enum';
import { BaseResponse } from 'src/shared/generics/base.response';

import { ActionFailed } from 'src/shared/exceptions/action-failed.exception';
import { MentorAdminListSortableFields } from '../mentor/shared/enums';
import { UtilityEnumREQ } from './request/utility-enum.request';

@Injectable()
export class UtilityService {
  constructor() {}

  private readonly additionEnums = {
    SortOrder: SortOrder,
    ...$Enums,
    ActionFailed: ActionFailed,
    MentorAdminListSortableFields: MentorAdminListSortableFields,
  };
  findAll(body: UtilityEnumREQ) {
    const response: { [key: string]: object } = {};
    if (body.keys.length === 0) {
      Object.keys(this.additionEnums).forEach((k) => (response[k] = Object.values(this.additionEnums[k])));
    } else
      body.keys.forEach((k) => {
        const value = this.additionEnums[k];
        if (!value) throw new UnprocessableEntityException(`Key: ${k} doesn't not exist`);
        response[k] = value;
      });
    return BaseResponse.of(response);
  }
}
</file>

<file path="src/interceptors/logging.interceptor.ts">
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import chalk from 'chalk';
import { Observable } from 'rxjs';
import { tap } from 'rxjs/operators';

/**
 * Logger Interceptor.
 * Creates informative logs to all requests, showing the path and
 * the method name.
 */
@Injectable()
export class LoggingInterceptor implements NestInterceptor {
  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    const parentType = chalk.hex('#5f02f5').bold(`${context.getArgs()[0].route.path}`);
    const fieldName = chalk.hex('#2ec8f2').bold(`${context.getArgs()[0].route.stack[0].method}`);
    return next.handle().pipe(
      tap(() => {
        Logger.debug(`${parentType}  ${fieldName}`, 'RESTful');
      }),
    );
  }
}
</file>

<file path="src/interceptors/prisma-exception.interceptor.ts">
import { CallHandler, ExecutionContext, Injectable, Logger, NestInterceptor } from '@nestjs/common';
import {
  PrismaClientInitializationError,
  PrismaClientKnownRequestError,
  PrismaClientRustPanicError,
  PrismaClientUnknownRequestError,
  PrismaClientValidationError,
} from '@prisma/client/runtime/library';
import { Observable } from 'rxjs';
import { catchError } from 'rxjs/operators';
import { EntityNotFoundException } from 'src/shared/exceptions/entity-not-found.exception';
import { KeyDuplicationException } from 'src/shared/exceptions/key-duplication.exception';
import { PrismaClientValidationException } from 'src/shared/exceptions/prisma-client-validation.exception';
import { RelationViolationException } from 'src/shared/exceptions/relation-violation.request';
import { WriteRelationNotFoundException } from 'src/shared/exceptions/write-relation-not-found.exception';
import { DatabaseConnectionException } from '../shared/exceptions/database-connnection.exception';
import { UnknownPrismaException } from '../shared/exceptions/unknown-prisma.exception';

@Injectable()
export class PrismaExceptionInterceptor implements NestInterceptor {
  private readonly logger = new Logger(PrismaExceptionInterceptor.name);

  intercept(context: ExecutionContext, next: CallHandler): Observable<any> {
    return next.handle().pipe(
      catchError((error) => {
        console.log(' ~ PrismaExceptionInterceptor ~ catchError ~ error:', error);
        this.logger.error('PrismaExceptionInterceptor:', error);

        if (error instanceof PrismaClientValidationError) {
          throw new PrismaClientValidationException(error.message);
        } else if (error instanceof PrismaClientKnownRequestError) {
          switch (error.code) {
            case 'P2002':
              throw new KeyDuplicationException(error.meta.modelName as string, `${error.meta.target}` as string);
            case 'P2025':
              if (
                ['record to update', 'relation'].some((p) =>
                  error.meta?.cause?.toString().toLowerCase().includes(p.toLowerCase()),
                )
              ) {
                throw new WriteRelationNotFoundException(null, error.meta.modelName as string, error.meta.cause as string);
              }
              throw new EntityNotFoundException(undefined, error.message);
            case 'P2017':
              if (error.meta.relation_name) {
                throw new WriteRelationNotFoundException(
                  undefined,
                  error.meta.modelName as string,
                  `No relation between ${error.meta.parent_name} & ${error.meta.child_name}`,
                );
              }
              break;
            case 'P2014':
              if (error.meta.relation_name) {
                throw new RelationViolationException(
                  String(error.meta?.relation_name),
                  String(error.meta?.model_a_name),
                  String(error.meta?.model_b_name),
                );
              }
              break;
            // Handle additional known error codes here
            default:
              throw new UnknownPrismaException(error.message);
          }
        } else if (error instanceof PrismaClientUnknownRequestError) {
          throw new UnknownPrismaException(error.message);
        } else if (error instanceof PrismaClientInitializationError) {
          throw new DatabaseConnectionException(error.message);
        } else if (error instanceof PrismaClientRustPanicError) {
          throw new DatabaseConnectionException('The database encountered an unexpected panic.');
        }

        // If it's not a known Prisma error, rethrow it
        throw error;
      }),
    );
  }
}
</file>

<file path="src/middlewares/http-exception.middlewave.ts">
import { ArgumentsHost, Catch, ExceptionFilter, HttpException, HttpStatus, Logger } from '@nestjs/common';
import { Response } from 'express';
import { NODE_ENV } from 'src/app.config';

@Catch(HttpException)
export class HttpExceptionMiddleware implements ExceptionFilter {
  private readonly logger = new Logger(HttpExceptionMiddleware.name);

  catch(exception: HttpException, host: ArgumentsHost) {
    const ctx = host.switchToHttp();
    const response = ctx.getResponse<Response>();
    const request = ctx.getRequest<Request>();
    const message = this.getErrorMessage(exception.getStatus(), exception.getResponse());
    const name: string = exception.name || 'HttpException';
    const statusCode = exception.getStatus();

    if (
      [
        HttpStatus.UNPROCESSABLE_ENTITY,
        HttpStatus.BAD_REQUEST,
        HttpStatus.CONFLICT,
        HttpStatus.UNAUTHORIZED,
        HttpStatus.FORBIDDEN,
      ].includes(statusCode)
    ) {
      // Log nothing
    } else this.logger.error(message, exception.stack);

    response.status(exception.getStatus()).json({
      name,
      message,
      statusCode,
      data: (exception as any).response,
      path: request.url,
      timestamp: new Date().toISOString(),
      error: (exception as any).error,
      stack: NODE_ENV === 'production' ? '' : exception.stack,
    });
  }

  private getErrorMessage(httpStatus: number, errorResponse: string | object): string | { [key: string]: any } {
    if (httpStatus === HttpStatus.UNPROCESSABLE_ENTITY && typeof errorResponse === 'object' && 'message' in errorResponse)
      return errorResponse.message;
    else if (typeof errorResponse === 'string') return errorResponse;
    else if ('message' in errorResponse) return errorResponse.message;
    else return 'Server Error';
  }
}
</file>

<file path="src/middlewares/socket-auth.middleware.ts">
import { Logger } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { Socket } from 'socket.io';
import { AuthJwtPayloadDTO } from 'src/domains/auth/dto/auth-jwt-payload.dto';

export interface AuthSocket extends Socket {
  payload: AuthJwtPayloadDTO;
}
export type SocketMiddleware = (socket: AuthSocket, next: (err?: Error) => void) => void;

export const SocketAuthMiddleware = (jwtService: JwtService, logger: Logger): SocketMiddleware => {
  return (client, next) => {
    try {
      const authorization =
        client.handshake.auth.token || client.handshake.headers['token'] || client.handshake.headers.authorization;
      const jwtPayload = jwtService.verify(authorization ?? '') as AuthJwtPayloadDTO;

      logger.log(' ~ return ~ authorization:', authorization);

      if (jwtPayload) {
        logger.log(' ~ return ~ jwtPayload:', jwtPayload);
        client.payload = jwtPayload;
        next();
      } else {
        next({
          name: 'Unauthorizaed',
          message: 'Unauthorizaed',
        });
      }
    } catch (error) {
      next({
        name: 'Unauthorizaed',
        message: 'Unauthorizaed',
      });
    }
  };
};
</file>

<file path="src/pipes/validation-array.pipe.ts">
import { HttpException, HttpStatus, Injectable, PipeTransform } from '@nestjs/common';
import { plainToClass } from 'class-transformer';
import { validate } from 'class-validator';

@Injectable()
export class ParseArrayPipe implements PipeTransform<any> {
  constructor(private readonly type?: any) {}

  async transform(value: any, metadata: any) {
    if (!Array.isArray(value)) {
      throw new HttpException('Invalid input', HttpStatus.BAD_REQUEST);
    }

    const { metatype } = metadata;
    const parsedArray = [];

    for (const item of value) {
      const object = plainToClass(this.type || metatype, item);
      const errors = await validate(object);

      if (errors.length > 0) {
        const message = errors.map((error) => Object.values(error.constraints)).join(', ');
        throw new HttpException(message, HttpStatus.BAD_REQUEST);
      }

      parsedArray.push(object);
    }

    return parsedArray;
  }
}
</file>

<file path="src/pipes/validation-custom.pipe.ts">
import { HttpStatus, UnprocessableEntityException, ValidationPipe } from '@nestjs/common';
import { ValidationError } from 'class-validator';

export class ValidationCustomPipe {
  static compactVersion() {
    return new ValidationPipe({ whitelist: true, errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY });
  }

  static extendVersion() {
    return new ValidationPipe({
      whitelist: true,
      errorHttpStatusCode: HttpStatus.UNPROCESSABLE_ENTITY,
      exceptionFactory: (validationErrors: ValidationError[] = []) => {
        type MyError = { field: string; errors: string[] | MyError[] };
        function parseError(error: ValidationError, parentName = ''): MyError {
          const fieldName = parentName ? [parentName, error.property].join('.') : error.property;
          if (error.children.length === 0) return { field: fieldName, errors: Object.values(error.constraints) };
          return {
            field: fieldName,
            errors: error.children.map((e) => parseError(e, fieldName)),
          };
        }
        return new UnprocessableEntityException(validationErrors.map((e) => parseError(e)));
      },
    });
  }
}
</file>

<file path="src/pipes/validation.pipe.ts">
import { HttpException, HttpStatus, Injectable, PipeTransform } from '@nestjs/common';
import { instanceToPlain, plainToInstance } from 'class-transformer';
import { ValidationError, validate, validateOrReject } from 'class-validator';
@Injectable()
export class ValidationPipe implements PipeTransform<any> {
  async transform(value: any, metadata: any) {
    const { metatype } = metadata;
    if (!metatype || !this.toValidate(metatype)) {
      return value;
    }

    try {
      const object = plainToInstance(metatype, value);
      await validateOrReject(object);

      await this.validateNestedDTOs(object);

      const plainObject = instanceToPlain(object, { excludeExtraneousValues: false });
      return plainObject;
    } catch (errors) {
      if (errors instanceof Array && errors.every((error) => error instanceof ValidationError)) {
        // const message = errors.map((error: ValidationError) => Object.values(error.constraints)).join(', ');
        const message = errors.map((error: ValidationError) => ({
          name: error.property,
          errors: Object.values(error.constraints),
        }));

        throw new HttpException(
          Object.values(message).reduce((prev, cur) => {
            return {
              ...prev,
              [cur.name]: cur.errors,
            };
          }, {}),
          HttpStatus.UNPROCESSABLE_ENTITY,
        );
      } else {
        throw new HttpException('Validation failed.', HttpStatus.BAD_REQUEST);
      }
    }
  }

  private async validateNestedDTOs(object: any) {
    const properties = Object.getOwnPropertyNames(object);
    for (const property of properties) {
      const propertyValue = object[property];
      if (propertyValue && typeof propertyValue === 'object' && !Array.isArray(propertyValue)) {
        const nestedMetatype = (Reflect as any).getMetadata('design:type', object, property);
        if (this.toValidate(nestedMetatype)) {
          await validate(propertyValue).then((errors) => {
            if (errors.length > 0) {
              throw errors;
            }
          });
          await this.validateNestedDTOs(propertyValue);
        }
      }
    }
  }

  private toValidate(metaType: any): boolean {
    const types: any[] = [String, Boolean, Number, Array, Object];
    return !types.includes(metaType);
  }
}
</file>

<file path="src/services/axios/axios.module.ts">
import { HttpModule } from '@nestjs/axios';
import { DynamicModule, Module } from '@nestjs/common';
import { AXIOS_CONFIG } from 'src/shared/constants/common.constant';
import { AxiosService } from './axios.service';

@Module({
  imports: [HttpModule],
})
export class AxiosModule {
  static register(options: { apiDomain: string }): DynamicModule {
    return {
      module: AxiosModule,
      providers: [
        {
          provide: AXIOS_CONFIG,
          useValue: options,
        },
        AxiosService,
      ],
      exports: [AxiosService],
    };
  }
}
</file>

<file path="src/services/axios/axios.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AxiosService } from './axios.service';

describe('AxiosService', () => {
  let service: AxiosService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AxiosService],
    }).compile();

    service = module.get<AxiosService>(AxiosService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/axios/axios.service.ts">
import { HttpService } from '@nestjs/axios';
import { Inject, Injectable } from '@nestjs/common';
import { lastValueFrom } from 'rxjs';
import { AXIOS_CONFIG } from 'src/shared/constants/common.constant';

@Injectable()
export class AxiosService {
  constructor(
    @Inject(AXIOS_CONFIG) private readonly options: { apiDomain: string },
    private readonly httpService: HttpService,
  ) {}

  async post<T>(headers: { [key: string]: string }, path: string, body: any): Promise<T> {
    try {
      const response = await lastValueFrom(
        this.httpService.post<T>(this.options.apiDomain + path, body, {
          headers: {
            ...headers,
            'Content-Type': 'application/json',
          },
        }),
      );
      return response.data as T;
    } catch (error) {
      console.log(' ~ AxiosService ~ error:', error);
      //   if (error instanceof AxiosError) {
      //     throw new PayosPaymentsException(error.response.data as PayosErrorResponse, error.response.status);
      //   }
      throw error;
    }
  }

  async get<T>(headers: { [key: string]: string }, path: string, searchParams: any = {}): Promise<T> {
    try {
      const response = await lastValueFrom(
        this.httpService.get<T>(this.options.apiDomain + path, {
          params: searchParams,
          headers: {
            ...headers,
          },
        }),
      );
      return response.data as T;
    } catch (error) {
      console.log(' ~ AxiosService ~ error:', error);
      //   if (error instanceof AxiosError) {
      //     throw new PayosPaymentsException(error.response.data as PayosErrorResponse, error.response.status);
      //   }
      throw error;
    }
  }
}
</file>

<file path="src/services/email/shared/types.ts">
export type EmailPayload = {
  email: string;
  subject: string;
  text: string;
};

export type EmailTemplate = {
  path: string;
  context?: Record<string, string>;
};
</file>

<file path="src/services/email/email.module.ts">
import { MailerModule } from '@nestjs-modules/mailer';
import { HandlebarsAdapter } from '@nestjs-modules/mailer/dist/adapters/handlebars.adapter';
import { Global, Module } from '@nestjs/common';
import { join } from 'path';
import { EMAIL_FROM, EMAIL_HOST, EMAIL_PASSWORD, EMAIL_USER } from 'src/app.config';
import { EmailService } from './email.service';

@Global()
@Module({
  imports: [
    MailerModule.forRootAsync({
      useFactory: async () => {
        return {
          transport: {
            host: EMAIL_HOST,

            secure: false,
            auth: {
              user: EMAIL_USER,
              pass: EMAIL_PASSWORD,
            },
          },
          defaults: {
            from: `"No Reply" <${EMAIL_FROM}>`,
          },
          template: {
            dir: join(__dirname, 'templates'),
            adapter: new HandlebarsAdapter(),
            options: {
              strict: true,
            },
          },
        };
      },
    }),
  ],
  providers: [EmailService],
  exports: [EmailService],
})
export class EmailModule {}
</file>

<file path="src/services/email/email.service.ts">
import { MailerService } from '@nestjs-modules/mailer';
import { Injectable, Logger } from '@nestjs/common';
import { leanObject } from 'src/shared/parsers/common.parser';
import { EmailPayload, EmailTemplate } from './shared/types';

@Injectable()
export class EmailService {
  private readonly logger = new Logger(EmailService.name);
  constructor(private readonly mailService: MailerService) {}

  async sendMail(payload: EmailPayload, template?: EmailTemplate) {
    try {
      const sentEmail = await this.mailService.sendMail({
        to: payload.email,
        subject: payload.subject,
        text: payload.text,
        ...(template.path && leanObject({ template: template.path, context: template.context })),
      });

      this.logger.log(' ~ EmailService ~ sendMail ~ sentEmail:', sentEmail);
    } catch (error) {
      this.logger.error(' ~ EmailService ~ sendMail ~ error:', error);
    }
  }
}
</file>

<file path="src/services/event-emitter/event-emitter.interface.ts">
interface EventOptions {
  /** Indicates if the event should be emitted asynchronously */
  async?: boolean;
  /** Any additional options to pass to the emitter */
  [key: string]: any;
}
</file>

<file path="src/services/event-emitter/event-emitter.module.ts">
import { Global, Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { EventEmitterService } from './event-emitter.service';

@Global()
@Module({
  imports: [EventEmitterModule.forRoot()],
  providers: [EventEmitterService],
  exports: [EventEmitterService],
})
export class EventNestModule {}
</file>

<file path="src/services/event-emitter/event-emitter.service.ts">
import { Injectable } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';

@Injectable()
export class EventEmitterService {
  constructor(private readonly eventEmitter: EventEmitter2) {}

  /**
   * Emit an event with the given payload
   * @param eventName Name of the event
   * @param payload Payload to emit with the event
   * @param options Optional configurations for emitting the event
   */
  emit<T = any>(eventName: string, payload: T, options?: EventOptions): void {
    if (options?.async) {
      this.eventEmitter.emitAsync(eventName, payload, options);
    } else {
      this.eventEmitter.emit(eventName, payload, options);
    }
  }
}
</file>

<file path="src/services/fcm/request/fcm-register-token.request.ts">
import { Prisma } from '@prisma/client';
import { IsString } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class FcmRegisterTokenREQ {
  @IsString()
  token: string;

  static toCreateToken(accountId: number, body: FcmRegisterTokenREQ): Prisma.DeviceTokenCreateArgs {
    return {
      data: { token: body.token, Account: connectRelation(accountId) },
      select: { id: true },
    };
  }
}
</file>

<file path="src/services/fcm/request/fcm-remove-token.request.ts">
import { IsString } from 'class-validator';

export class FcmRemoveTokenREQ {
  @IsString()
  token: string;
}
</file>

<file path="src/services/fcm/shared/helpers.ts">
import { NotificationType } from '@prisma/client';
import { FcmNotificationPayload } from 'src/domains/notification/shared/interfaces';

// adapter for the FCM service
export const payloadFcmAdapter = (
  title: string | NotificationType,
  topic: string | NotificationType,
  body: string | object,
): FcmNotificationPayload => {
  return {
    title: typeof title === 'string' ? title : NotificationType[title],
    topic: typeof topic === 'string' ? topic : NotificationType[topic],
    body: typeof body === 'object' ? JSON.stringify(body) : body,
  };
};
</file>

<file path="src/services/fcm/fcm.controller.ts">
import { Body, Controller, Delete, Post, Req, UseGuards } from '@nestjs/common';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { FCMService } from './fcm.service';
import { FcmRegisterTokenREQ } from './request/fcm-register-token.request';
import { FcmRemoveTokenREQ } from './request/fcm-remove-token.request';

@Controller('fcm')
@UseGuards(AuthJwtGuard)
export class FcmController {
  constructor(private readonly fcmService: FCMService) {}

  @Post('device-tokens')
  async registerToken(@Req() req: AuthRequestDTO, @Body() body: FcmRegisterTokenREQ) {
    return await this.fcmService.registerToken(req.user, body);
  }

  @Delete('device-tokens')
  async removeToken(@Req() req: AuthRequestDTO, @Body() body: FcmRemoveTokenREQ) {
    await this.fcmService.removeToken(req.user, body);

    return BaseResponse.ok();
  }
}
</file>

<file path="src/services/fcm/fcm.module.ts">
import { Module } from '@nestjs/common';
import { PrismaModule } from '../prisma/prisma.module';
import { FcmController } from './fcm.controller';
import { FCMService } from './fcm.service';

@Module({
  imports: [PrismaModule],
  controllers: [FcmController],
  providers: [FCMService],
  exports: [FCMService],
})
export class FcmModule {}
</file>

<file path="src/services/fcm/fcm.service.ts">
import { ForbiddenException, Injectable, Logger } from '@nestjs/common';
import { Prisma } from '@prisma/client';
import * as firebaseAdmin from 'firebase-admin';
import { Message } from 'firebase-admin/lib/messaging/messaging-api';
import { isEmpty } from 'lodash';
import { FIREBASE_CLOUD_MESSAGE_CERTIFICATION } from 'src/app.config';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FcmNotificationPayload, FCMSendOptions } from 'src/domains/notification/shared/interfaces';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { resolvePathFromRoot } from 'src/shared/helpers/path.helper';
import { PrismaRawService } from '../prisma/prisma-raw.service';
import { TransactionHost } from '../prisma/transactions/transaction-host';
import { Transactional } from '../prisma/transactions/transactional.decorator';
import { FcmRegisterTokenREQ } from './request/fcm-register-token.request';
import { FcmRemoveTokenREQ } from './request/fcm-remove-token.request';

@Injectable()
export class FCMService {
  private readonly logger = new Logger(FCMService.name);

  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly prismaRawService: PrismaRawService,
  ) {
    try {
      firebaseAdmin.initializeApp({
        credential: firebaseAdmin.credential.cert(resolvePathFromRoot(FIREBASE_CLOUD_MESSAGE_CERTIFICATION)),
      });
      this.logger.log('Firebase Admin initialized successfully');
    } catch (error) {
      this.logger.error('Failed to initialize Firebase Admin', error);
      throw new Error('Firebase initialization failed');
    }
  }

  private notificationMessageBuilder(payload: FcmNotificationPayload, options: FCMSendOptions) {
    const message: Message = {
      notification: {
        title: payload.title,
        body: payload.body,
      },
      data: options.data || {},
      ...(options.token && { token: options.token }),
      // ...(options.topic && { topic: options.topic }),
      // ...(options.condition && { condition: options.condition }),
    };
    return message;
  }

  async sendNotification(payload: FcmNotificationPayload, options: FCMSendOptions): Promise<string> {
    try {
      const message = this.notificationMessageBuilder(payload, options);
      const response = await firebaseAdmin.messaging().send(message);
      this.logger.log('PUSHING NOTIFICATION SUCCESS on DEVICE', message.token);
      return response;
    } catch (error) {
      this.logger.error('PUSHING NOTIFICATION FAILED:', error);
      // throw new ActionFailedException(ActionFailed.NOTIFICATION_PUSH_FAILED, 'Error sending notification:', error);
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async sendNotificationToAllDevices(
    accountId: number,
    condition: Prisma.DeviceTokenWhereInput,
    payload: FcmNotificationPayload,
  ) {
    if (!accountId) return;

    const deviceTokens = await this.transactionHost.tx.deviceToken.findMany({
      where: condition,
      select: { token: true },
    });

    if (isEmpty(deviceTokens)) return;

    for (const device of deviceTokens) {
      await this.sendNotification(
        { body: typeof payload.body === 'object' ? JSON.stringify(payload.body) : payload.body, title: payload.title },
        { token: device.token },
      );
    }
  }

  async registerToken(user: AuthUserDTO, body: FcmRegisterTokenREQ) {
    const exiestedToken = await this.transactionHost.tx.deviceToken.findUnique({
      where: { token: body.token },
      select: { id: true },
    });

    if (exiestedToken) return exiestedToken;

    const token = await this.transactionHost.tx.deviceToken.create(FcmRegisterTokenREQ.toCreateToken(user.accountId, body));

    return token;
  }

  async removeToken(user: AuthUserDTO, body: FcmRemoveTokenREQ) {
    const deviceToken = await this.transactionHost.tx.deviceToken.findUniqueOrThrow({
      where: { token: body.token },
      select: { accountId: true, id: true },
    });

    if (deviceToken && deviceToken.accountId !== user.accountId) throw new ForbiddenException();

    await this.prismaRawService.deviceToken.delete({ where: { token: body.token } });
  }
}
</file>

<file path="src/services/fcm/fcm.types.ts">
export type NotificationPayload = {
  title: string;
  body: string;
  [key: string]: any; // Additional properties for custom data
};

export type SendNotificationOptions = {
  token?: string;
  topic?: string;
  condition?: string;
  data?: { [key: string]: string }; // Custom data
};
</file>

<file path="src/services/getstream/request/getstream.request.ts">
export interface GetstreamREQ {
  user_id: string;
  role?: string;
  call_cids: string[];
  validity_in_seconds?: number;
  exp?: number;
  iat?: number;
}
</file>

<file path="src/services/getstream/getstream.controller.ts">
import { Body, Controller, Post, Req } from '@nestjs/common';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { GetStreamService } from './getstream.service';

@Controller('getstream')
export class GetStreamController {
  constructor(private readonly getStreamService: GetStreamService) {}

  @Post('webhooks')
  async push(@Body() payload: any, @Req() req: AuthRequestDTO) {
    this.getStreamService.verifyWebhook(req, payload);
    console.log(' ~ AudioCallController ~ push ~ payload:', payload);
    this.getStreamService.emitEvent(payload);
  }
}
</file>

<file path="src/services/getstream/getstream.module.ts">
import { Module } from '@nestjs/common';
import { GetStreamController } from './getstream.controller';
import { GetStreamService } from './getstream.service';

@Module({
  providers: [GetStreamService],
  controllers: [GetStreamController],
  exports: [GetStreamService],
})
export class GetstreamModule {}
</file>

<file path="src/services/getstream/getstream.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { GetstreamService } from './getstream.service';

describe('GetstreamService', () => {
  let service: GetstreamService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [GetstreamService],
    }).compile();

    service = module.get<GetstreamService>(GetstreamService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/getstream/getstream.service.ts">
import { Injectable, Logger, OnModuleInit } from '@nestjs/common';
import { EventEmitter2 } from '@nestjs/event-emitter';
import { StreamClient } from '@stream-io/node-sdk';
import { GETSTREAM_API_KEY, GETSTREAM_API_SECRET, GETSTREAM_WEBHOOK_URL } from 'src/app.config';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { AudioCallChannel } from 'src/shared/constants/event.constant';
import { GetstreamREQ } from './request/getstream.request';

@Injectable()
export class GetStreamService implements OnModuleInit {
  private readonly streamClient: StreamClient;
  private logger = new Logger(GetStreamService.name);
  constructor(private readonly eventEmitter: EventEmitter2) {
    this.streamClient = new StreamClient(GETSTREAM_API_KEY, GETSTREAM_API_SECRET, { timeout: 10000 });
    this.logger.log('StreamClient initialized');
  }
  async onModuleInit() {
    try {
      await this.streamClient.updateApp({
        webhook_url: GETSTREAM_WEBHOOK_URL,
      });
    } catch (err) {
      this.logger.error(err.message);
    }
  }

  createCallToken(request: GetstreamREQ) {
    try {
      this.streamClient.generateCallToken(request as any);
    } catch (e) {
      this.logger.error(e);
    }
  }

  emitEvent(payload: any) {
    switch (payload.type) {
      case AudioCallChannel.LEAVE_CALL:
        this.eventEmitter.emit(AudioCallChannel.LEAVE_CALL, payload);
        break;
      default:
        break;
    }
  }

  verifyWebhook(req: AuthRequestDTO, body: any) {
    try {
      const signature = Array.isArray(req.headers['x-signature']) ? req.headers['x-signature'][0] : req.headers['x-signature'];
      const isVerified = this.streamClient.verifyWebhook(JSON.stringify(body), signature);
      if (!isVerified) {
        throw new Error('Webhook verification failed');
      }
    } catch (e) {
      this.logger.error(e.message);
    }
  }

  async createCall(request: any) {
    try {
      await this.streamClient.video.getOrCreateCall(request);
    } catch (e) {
      this.logger.error(e);
    }
  }
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.constant.ts">
import { VnpLocale } from './vnpay.enum';

export const VNP_DEFAULT_COMMAND = 'pay';
export const VNP_DEFAULT_CURR_CODE = 'VND';
export const WRONG_CHECKSUM_KEY = 'WRONG CHECKSUM';
export const VNPAY_RESPONSE_MAP = new Map<string, Record<VnpLocale, string>>([
  ['00', { vn: 'Giao dch thnh cng', en: 'Approved' }],
  ['01', { vn: 'Giao dch  tn ti', en: 'Transaction is already exist' }],
  [
    '02',
    {
      vn: 'Merchant khng hp l (kim tra li vnp_TmnCode)',
      en: 'Invalid merchant (check vnp_TmnCode value)',
    },
  ],
  [
    '03',
    {
      vn: 'D liu gi sang khng ng nh dng',
      en: 'Sent data is not in the right format',
    },
  ],
  [
    '04',
    {
      vn: 'Khi to GD khng thnh cng do Website ang b tm kho',
      en: 'Payment website is not available',
    },
  ],
  [
    '05',
    {
      vn: 'Giao dch khng thnh cng do: Qu khch nhp sai mt khu thanh ton qu s ln quy nh. Xin qu khch vui lng thc hin li giao dch',
      en: 'Transaction failed: Too many wrong password input',
    },
  ],
  [
    '06',
    {
      vn: 'Giao dch khng thnh cng do Qu khch nhp sai mt khu xc thc giao dch (OTP). Xin qu khch vui lng thc hin li giao dch.',
      en: 'Transaction failed: Wrong OTP input',
    },
  ],
  [
    '07',
    {
      vn: 'Tr tin thnh cng. Giao dch b nghi ng (lin quan ti la o, giao dch bt thng). i vi giao dch ny cn merchant xc nhn thng qua merchant admin: T chi/ng  giao dch',
      en: 'This transaction is suspicious',
    },
  ],
  [
    '08',
    {
      vn: 'Giao dch khng thnh cng do: H thng Ngn hng ang bo tr. Xin qu khch tm thi khng thc hin giao dch bng th/ti khon ca Ngn hng ny.',
      en: 'Transaction failed: The banking system is under maintenance. Please do not temporarily make transactions by card / account of this Bank.',
    },
  ],
  [
    '09',
    {
      vn: 'Giao dch khng thnh cng do: Th/Ti khon ca khch hng cha ng k dch v InternetBanking ti ngn hng.',
      en: 'Transaction failed: Cards / accounts of customer who has not yet registered for Internet Banking service.',
    },
  ],
  [
    '10',
    {
      vn: 'Giao dch khng thnh cng do: Khch hng xc thc thng tin th/ti khon khng ng qu 3 ln',
      en: 'Transaction failed: Customer incorrectly validate the card / account information more than 3 times',
    },
  ],
  [
    '11',
    {
      vn: 'Giao dch khng thnh cng do:  ht hn ch thanh ton. Xin qu khch vui lng thc hin li giao dch.',
      en: 'Transaction failed: Pending payment is expired. Please try again.',
    },
  ],
  [
    '24',
    {
      vn: 'Giao dch khng thnh cng do: Khch hng hy giao dch',
      en: 'Transaction canceled',
    },
  ],
  [
    '51',
    {
      vn: 'Giao dch khng thnh cng do: Ti khon ca qu khch khng  s d  thc hin giao dch.',
      en: 'Transaction failed: Your account is not enough balance to make the transaction.',
    },
  ],
  [
    '65',
    {
      vn: 'Giao dch khng thnh cng do: Ti khon ca Qu khch  vt qu hn mc giao dch trong ngy.',
      en: 'Transaction failed: Your account has exceeded the daily limit.',
    },
  ],
  [
    '75',
    {
      vn: 'Ngn hng thanh ton ang bo tr',
      en: 'Banking system is under maintenance',
    },
  ],
  [WRONG_CHECKSUM_KEY, { vn: 'Sai checksum', en: 'Wrong checksum' }],
  ['default', { vn: 'Giao dch tht bi', en: 'Failure' }],
]);

export const QUERY_DR_RESPONSE_MAP = new Map<string, Record<VnpLocale, string>>([
  ['00', { vn: 'Yu cu thnh cng', en: 'Success' }],
  [
    '02',
    {
      vn: 'M nh danh kt ni khng hp l (kim tra li TmnCode)',
      en: 'Invalid connection identifier (check TmnCode)',
    },
  ],
  [
    '03',
    {
      vn: 'D liu gi sang khng ng nh dng',
      en: 'Sent data is not in the right format',
    },
  ],
  [
    '91',
    {
      vn: 'Khng tm thy giao dch yu cu',
      en: 'Transaction not found for request',
    },
  ],
  [
    '94',
    {
      vn: 'Yu cu trng lp, duplicate request trong thi gian gii hn ca API',
      en: 'Duplicate request within the time limit of the API',
    },
  ],
  [
    '97',
    {
      vn: 'Checksum khng hp l',
      en: 'Invalid checksum',
    },
  ],
  [
    '99',
    {
      vn: 'Cc li khc (li cn li, khng c trong danh sch m li  lit k)',
      en: 'Other errors (remaining errors, not in the list of error codes listed)',
    },
  ],
  [WRONG_CHECKSUM_KEY, { vn: 'Sai checksum', en: 'Wrong checksum' }],
  ['default', { vn: 'Giao dch tht bi', en: 'Failure' }],
]);
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.enum.ts">
export enum HashAlgorithm {
  SHA256 = 'SHA256',
  SHA512 = 'SHA512',
  MD5 = 'MD5',
}

export enum VnpCurrCode {
  VND = 'VND',
}
export enum VnpLocale {
  VN = 'vn',
  EN = 'en',
}

export enum VnpCardType {
  ATM = 'ATM',
  QRCODE = 'QRCODE',
}

export enum BankCode {
  VNPAYQR = 'VNPAYQR',
  VNBANK = 'VNBANK',
  INTCARD = 'INTCARD',
}
export declare enum VnpTransactionType {
  PAYMENT = '01',
  FULL_REFUND = '02',
  PARTIAL_REFUND = '03',
}

export declare enum RefundTransactionType {
  FULL_REFUND = '02',
  PARTIAL_REFUND = '03',
}

/**
 * @see https://sandbox.vnpayment.vn/apis/docs/loai-hang-hoa/
 */
export enum ProductCode {
  Food_Consumption = '100000',
  Phone_Tablet = '110000',
  ElectricAppliance = '120000',
  Computers_OfficeEquipment = '130000',
  Electronics_Sound = '140000',
  Books_Newspapers_Magazines = '150000',
  Sports_Picnics = '160000',
  Hotel_Tourism = '170000',
  Cuisine = '180000',
  Entertainment_Training = '190000',
  Fashion = '200000',
  Health_Beauty = '210000',
  Mother_Baby = '220000',
  KitchenUtensils = '230000',
  Vehicle = '240000',
  Pay = '250000',
  AirlineTickets = '250007',
  CardCode = '260000',
  Pharmacy_MedicalServices = '270000',
  Other = 'other',
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.helper.ts">
import crypto, { type BinaryLike } from 'crypto';
import { VNPAY_ENDPOINT, VNPAY_SANDBOX_HOST } from 'src/app.config';
import { DATE_FORMAT } from 'src/shared/constants/date.constant';
import { resolveUrlString } from 'src/shared/helpers/common.helper';
import { parseAndAddMinutes } from 'src/shared/parsers/datetime.parse';
import { VNPAY_RESPONSE_MAP } from './vnpay.constant';
import { HashAlgorithm, VnpLocale } from './vnpay.enum';
import { DefaultConfig, VNPayBuildUrlRequest, VpnGlobalConfig } from './vnpay.type';

/**
 * Validate if the date is match with format `yyyyMMddHHmmss` or not
 * @param date The date to be validated
 * @returns True if the date is valid, false otherwise
 */
export function isValidVnpayDateFormat(date: number): boolean {
  const dateString = date.toString();
  const regex = /^\d{4}(0[1-9]|1[0-2])(0[1-9]|[12][0-9]|3[01])([01][0-9]|2[0-3])[0-5][0-9][0-5][0-9]$/;
  return regex.test(dateString);
}
export function formatVnpayDate(date: Date, format = 'yyyyMMddHHmmss'): number {
  const pad = (n: number) => (n < 10 ? `0${n}` : n).toString();
  const year = date.getFullYear();
  const month = pad(date.getMonth() + 1);
  const day = pad(date.getDate());
  const hour = pad(date.getHours());
  const minute = pad(date.getMinutes());
  const second = pad(date.getSeconds());

  return Number(
    format
      .replace('yyyy', year.toString())
      .replace('MM', month)
      .replace('dd', day)
      .replace('HH', hour)
      .replace('mm', minute)
      .replace('ss', second),
  );
}

export function generateExpiredDate(createdDate: number): number {
  if (!isValidVnpayDateFormat(createdDate)) {
    throw new Error('Invalid date format');
  }

  //generate expired date after 10 minutes
  const expiredDate = parseAndAddMinutes(createdDate.toString(), 10, DATE_FORMAT.DATE_TIME_SECOND.NO_SPACE);
  return Number(expiredDate);
}

export function buildPaymentUrlSearchParams(data: Record<string, unknown>): URLSearchParams {
  const searchParams = new URLSearchParams();
  const sortedEntries = Object.entries(data).sort(([key1], [key2]) => key1.toString().localeCompare(key2.toString()));

  for (const [key, value] of sortedEntries) {
    // Skip empty value
    if (value === '' || value === undefined || value === null) {
      continue;
    }

    searchParams.append(key, value.toString());
  }
  return searchParams;
}

export const createPaymentUrl = ({
  data,
  config,
}: {
  data: (VNPayBuildUrlRequest & DefaultConfig) | Record<string, unknown>;
  config: Pick<VpnGlobalConfig, 'vnpayHost' | 'paymentEndpoint'>;
}): URL => {
  const redirectUrl = new URL(resolveUrlString(config.vnpayHost ?? VNPAY_SANDBOX_HOST, config.paymentEndpoint ?? VNPAY_ENDPOINT));

  buildPaymentUrlSearchParams(data).forEach((value, key) => {
    redirectUrl.searchParams.set(key, value);
  });

  return redirectUrl;
};

export function calculateSecureHash({
  bufferEncode = 'utf-8',
  data,
  hashAlgorithm,
  secureSecret,
}: {
  secureSecret: string;
  data: string;
  hashAlgorithm: HashAlgorithm;
  bufferEncode?: BufferEncoding;
}): string {
  return hashVnpay(secureSecret, Buffer.from(data, bufferEncode), hashAlgorithm);
}

export function verifySecureHash({
  data,
  hashAlgorithm,
  receivedHash,
  secureSecret,
}: {
  secureSecret: string;
  data: string;
  hashAlgorithm: HashAlgorithm;
  receivedHash: string;
}): boolean {
  const calculatedHash = calculateSecureHash({ secureSecret, data, hashAlgorithm });
  console.log(' ~ calculatedHash:', calculatedHash);
  return calculatedHash === receivedHash;
}

export function hashVnpay(secret: string, data: BinaryLike, algorithm: HashAlgorithm): string {
  return crypto.createHmac(algorithm, secret).update(data).digest('hex');
}

export function makeVNPayResponse(responseCode: string = '', locale: string = VnpLocale.VN) {
  const responseText: Record<VnpLocale, string> = VNPAY_RESPONSE_MAP.get(responseCode) ?? VNPAY_RESPONSE_MAP.get('default');

  return responseText[locale];
}
</file>

<file path="src/services/payment-gateway/vn-pay/shared/vnpay.type.ts">
import { HashAlgorithm, ProductCode, VnpCardType, VnpCurrCode, VnpLocale } from './vnpay.enum';

export const VNPAY_MODULE_OPTIONS = Symbol('VNPAY_MODULE_OPTIONS');

export type VnpMode = 'sandbox' | 'production';

export type VpnGlobalConfig = Omit<VNPayConfig, 'testMode' | 'enableLog' | 'loggerFn'> & {
  vnpayHost: string;
  vnp_Locale: VnpLocale;
  vnp_CurrCode: VnpCurrCode;
  vnp_Command: string;
  vnp_OrderType: ProductCode | string;
  vnp_Version: string;
};

export type DefaultConfig = Pick<VpnGlobalConfig, 'vnp_Version' | 'vnp_CurrCode' | 'vnp_Command' | 'vnp_OrderType'> & {
  vnp_TmnCode: string;
  vnp_Locale: VnpLocale;
};
export type VNPayConfig = {
  /**
   * Merchant tmn code
   */
  tmnCode: string;
  /**
   * Secure secret of merchant
   */
  secureSecret: string;
  /**
   * Version of VNPay API
   */
  vnp_Version?: string;
  /**
   * Currency code
   */
  vnp_CurrCode?: VnpCurrCode;
  /**
   * Language display on payment gateway
   */
  vnp_Locale?: VnpLocale;
  /**
   * API host url of VNPay
   * @default 'https://sandbox.vnpayment.vn'
   * @example 'https://sandbox.vnpayment.vn'
   */
  vnpayHost?: string;
  /**
   *  Payment endpoint of VNPay
   * @default 'paymentv2/vpcpay.html'
   * @example 'paymentv2/vpcpay.html'
   */
  paymentEndpoint?: string;
  /**
   * When using test mode, `vnpayHost` should be set to sandbox
   * @default false
   */
  mode?: VnpMode;
  /**
   * Hash algorithm
   * @default 'SHA512'
   */
  hashAlgorithm?: HashAlgorithm;
  /**
   * Disable it, then no logger will be used in any method
   *
   * Enable logging feature
   * @default false
   */
  enableLog?: boolean;
  /**
   * Method that allows you to customize the log
   * @param data Data to log, it can be change to each method
   * @returns
   */
  loggerFn?: (data: unknown) => void;
};

export type VNPayBuildUrlRequest = {
  /**
   * Amount of payment. Automatically calculated according to the unit of VNPay. (100 times the amount of the order in your database)
   */
  vnp_Amount: number;

  /**
   * Description of payment (Vietnamese, no accent)
   * @example Thanh toan don hang 12345
   */
  vnp_OrderInfo: string;

  /**
   * Reference code of transaction on merchant system. This code is unique to distinguish orders sent to VNPAY. Not duplicated in a day.
   * @example 123456
   */
  vnp_TxnRef: string;

  /**
   * IP address of customer who make transaction
   * @example 13.160.92.202
   */
  vnp_IpAddr: string;

  /**
   * URL thng bo kt qu giao dch khi Khch hng kt thc thanh ton.
   * URL to notify result of transaction when customer finish payment
   * @example https://domain.vn/VnPayReturn
   */
  vnp_ReturnUrl: string;

  /**
   * Transaction date format yyyyMMddHHmmss(Time zone GMT+7)
   *
   * If `vnp_CreateDate` is not in the correct format, it will be the current time
   * @example 20170829103111
   * @example
   * ```ts
   *  import { dateFormat } from 'vnpay';
   *
   *  // then
   *  vnp_CreateDate: dateFormat(new Date()),
   * ```
   */
  vnp_CreateDate?: number;

  /**
   * Time of expiration of payment, format yyyyMMddHHmmss(Time zone GMT+7)
   * @example 20170829103111
   * @example
   * ```ts
   *  import { dateFormat } from 'vnpay';
   *
   *  const tomorrow = new Date();
   *  tomorrow.setDate(tomorrow.getDate() + 1);
   *
   *  // then
   *  vnp_CreateDate: dateFormat(tomorrow),
   * ```
   */
  vnp_ExpireDate?: number;

  /**
   * Currency code using for payment. Currently only support VND
   * @example VND
   */
  vnp_CurrCode?: VpnGlobalConfig['vnp_CurrCode'];

  /**
   * Language display on payment gateway. Currently support Vietnamese (vn), English)
   * @example vn
   */
  vnp_Locale?: VpnGlobalConfig['vnp_Locale'];

  /**
   * Order type/ Product Code
   * @default 'other'
   */
  vnp_OrderType?: VpnGlobalConfig['vnp_OrderType'];

  /**
   * Bank code
   * @example NCB
   */
  vnp_BankCode?: string;
};

export type VnpayModuleOptions = VNPayConfig;

export type ReturnQueryFromVNPay = Pick<VNPayBuildUrlRequest, 'vnp_OrderInfo' | 'vnp_TxnRef'> & {
  /**
   * Payment amount
   */
  vnp_Amount: number | string;
  /**
   * Merchant tmn code
   */
  vnp_TmnCode?: string;
  /**
   * Bank code
   * @example NCB
   */
  vnp_BankCode?: string;
  /**
   * Transaction code at bank
   * @example NCB20170829152730
   */
  vnp_BankTranNo?: string;
  /**
   * Type of customer account/card used: `ATM`, `QRCODE`
   * @example ATM
   */
  vnp_CardType?: VnpCardType | string;
  /**
   * Payment time. Format: yyyyMMddHHmmss
   * @example 20170829152730
   */
  vnp_PayDate?: number | string;
  /**
   * Transaction code recorded in VNPAY system.
   * @example 20170829153052
   */
  vnp_TransactionNo?: number | string;
  /**
   * Response code of payment result. The response code 00 corresponds to the Successful result for all APIs.
   * @example 00
   * @see https://sandbox.vnpayment.vn/apis/docs/bang-ma-loi/
   */
  vnp_ResponseCode: number | string;
  /**
   *
   * Response code of payment result. Status of transaction at VNPAY payment gateway.
   *
   * -00: Payment transaction is successful at VNPAY
   *
   * -Other 00: Payment transaction is not successful at VNPAY
   *
   * @example 00
   * @see https://sandbox.vnpayment.vn/apis/docs/bang-ma-loi/
   */
  vnp_TransactionStatus?: number | string;
  /**
   * Security type code used to create checksum code. This code depends on the configuration of the merchant and the version of the api used.
   * The current version supports `SHA256`, `HMACSHA512`.
   * @example HMACSHA512
   */
  vnp_SecureHashType?: string;
  /**
   * Checksum to ensure that the transaction data is not changed during the transfer from merchant to VNPAY.
   * The creation of this code depends on the configuration of the merchant and the version of the api used. The current version supports `SHA256`, `HMACSHA512`.
   *
   */
  vnp_SecureHash?: string;
};
</file>

<file path="src/services/payment-gateway/vn-pay/vnpay.module.ts">
import { DynamicModule, Module } from '@nestjs/common';
import { VNPAY_MODULE_OPTIONS, VnpayModuleOptions } from './shared/vnpay.type';
import { VnpayService } from './vnpay.service';

@Module({})
export class VnpayModule {
  static register(options: VnpayModuleOptions): DynamicModule {
    return {
      module: VnpayModule,
      providers: [{ provide: VNPAY_MODULE_OPTIONS, useValue: options }, VnpayService],
      exports: [VnpayService],
    };
  }
}
</file>

<file path="src/services/payment-gateway/vn-pay/vnpay.service.ts">
import { Inject, Injectable, Logger } from '@nestjs/common';
import { AxiosError } from 'axios';
import { isNull } from 'lodash';
import { VNP_HASHSECRET, VNP_TMNCODE, VNP_VERSION, VNPAY_SANDBOX_HOST } from 'src/app.config';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { numberRegex } from 'src/shared/constants/common.constant';
import { DATE_FORMAT } from 'src/shared/constants/date.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { Result, SuccessOrFailResponse } from 'src/shared/generics/type.helper';
import { makeResult } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { leanObject } from 'src/shared/parsers/common.parser';
import { parseDateTimeNowFormat } from 'src/shared/parsers/datetime.parse';
import { VNP_DEFAULT_COMMAND, VNP_DEFAULT_CURR_CODE } from './shared/vnpay.constant';
import { HashAlgorithm, ProductCode, VnpCurrCode, VnpLocale } from './shared/vnpay.enum';
import {
  buildPaymentUrlSearchParams,
  calculateSecureHash,
  createPaymentUrl,
  generateExpiredDate,
  isValidVnpayDateFormat,
  makeVNPayResponse,
  verifySecureHash,
} from './shared/vnpay.helper';
import {
  DefaultConfig,
  ReturnQueryFromVNPay,
  VNPAY_MODULE_OPTIONS,
  VNPayBuildUrlRequest,
  VNPayConfig,
  VpnGlobalConfig,
} from './shared/vnpay.type';

@Injectable()
export class VnpayService {
  private readonly logger = new Logger(VnpayService.name);
  private HASH_ALGORITHM = HashAlgorithm.SHA512;
  private BUFFER_ENCODE: BufferEncoding = 'utf-8';
  private readonly globalDefaultConfig: VpnGlobalConfig;

  constructor(
    @Inject(VNPAY_MODULE_OPTIONS) private readonly config: VNPayConfig,
    private readonly transactionHost: TransactionHost,
  ) {
    if (isNull(this.config.mode) || this.config.mode === 'sandbox') {
      this.globalDefaultConfig.vnpayHost = VNPAY_SANDBOX_HOST;
    }

    this.globalDefaultConfig = {
      tmnCode: VNP_TMNCODE,
      vnp_Version: VNP_VERSION,
      vnpayHost: VNPAY_SANDBOX_HOST,
      secureSecret: VNP_HASHSECRET,
      vnp_Command: VNP_DEFAULT_COMMAND,
      vnp_CurrCode: VNP_DEFAULT_CURR_CODE as VnpCurrCode,
      vnp_Locale: VnpLocale.VN,
      vnp_OrderType: ProductCode.Other,
      ...config,
    };
  }

  /**
   */
  @Transactional(TRANSACTION_TIMEOUT)
  async create(paymentId: number, body: VNPayBuildUrlRequest) {
    const url = this.buildPaymentUrl(body);
    const searchParams = url
      .split('?')[1]
      .split('&')
      .reduce((acc, item) => {
        const [key, value] = item.split('=');
        return { ...acc, [key]: value };
      }, {}) as VNPayBuildUrlRequest;
    console.log(' ~ VnpayService ~ create ~ searchParams:', searchParams);

    const { vnp_TxnRef, vnp_CreateDate, vnp_Amount, vnp_BankCode, vnp_OrderInfo, ...remain } = searchParams;

    await this.transactionHost.tx.vnpayProvider.upsert({
      where: { paymentId },
      update: {
        vnp_Amount: vnp_Amount,
        vnp_BankCode: vnp_BankCode,
        vnp_OrderInfo: vnp_OrderInfo,
        vnp_CreatedDate: vnp_CreateDate,
        vnp_TxnRef: vnp_TxnRef,
        metadata: remain,
      },
      create: {
        vnp_Amount: vnp_Amount,
        vnp_BankCode: vnp_BankCode,
        vnp_OrderInfo: vnp_OrderInfo,
        vnp_CreatedDate: vnp_CreateDate,
        vnp_TxnRef: vnp_TxnRef,
        metadata: remain,
        Payment: connectRelation(paymentId),
      },
    });

    return url;
  }

  /**
   * Ly cu hnh mc nh ca VNPay
   * @en Get default config of VNPay
   */
  public get defaultConfig(): DefaultConfig {
    return {
      vnp_TmnCode: this.globalDefaultConfig.tmnCode,
      vnp_Version: this.globalDefaultConfig.vnp_Version,
      vnp_CurrCode: this.globalDefaultConfig.vnp_CurrCode,
      vnp_Locale: this.globalDefaultConfig.vnp_Locale,
      vnp_Command: this.globalDefaultConfig.vnp_Command,
      vnp_OrderType: this.globalDefaultConfig.vnp_OrderType,
    };
  }

  async getBankList(): Promise<Result<any, AxiosError>> {
    return makeResult(async () => {});
  }

  /**
   * Phng thc xy dng, to thnh url thanh ton ca VNPay
   * @en Build the payment url
   *
   * @param {BuildPaymentUrl} data - Payload that contains the information to build the payment url
   * @returns {string} The payment url string
   * @see https://sandbox.vnpayment.vn/apis/docs/thanh-toan-pay/pay.html#tao-url-thanh-toan
   */
  public buildPaymentUrl(data: VNPayBuildUrlRequest): string {
    const createDate = Number(parseDateTimeNowFormat(DATE_FORMAT.DATE_TIME_SECOND.NO_SPACE));

    if (data?.vnp_ExpireDate && !isValidVnpayDateFormat(data.vnp_ExpireDate)) {
      // Because the URL still works without vnp_ExpireDate, we keep it optional here.
      // TODO: make it required when VNPAY's `vnp_ExpireDate` is required
      throw new Error('Invalid vnp_ExpireDate format. use `formatDate` utility function to format it');
    }

    const expiredDate = data.vnp_ExpireDate || generateExpiredDate(Number(createDate));

    const dataToBuild = leanObject({
      ...this.defaultConfig,
      ...data,

      /**
       * Multiply by 100 to follow VNPay standard, see docs for more detail
       */
      vnp_CreateDate: createDate,
      vnp_ExpireDate: expiredDate,
      vnp_Amount: data.vnp_Amount * 100,
    });

    const redirectUrl = createPaymentUrl({
      config: this.globalDefaultConfig,
      data: dataToBuild,
    });

    const signed = calculateSecureHash({
      secureSecret: this.globalDefaultConfig.secureSecret,
      data: redirectUrl.search.slice(1).toString(),
      hashAlgorithm: this.HASH_ALGORITHM,
      bufferEncode: this.BUFFER_ENCODE,
    });
    console.log(' ~ VnpayService ~ buildPaymentUrl ~ signed:', signed);

    redirectUrl.searchParams.append('vnp_SecureHash', signed);

    return redirectUrl.toString();
  }

  public async verifyReturnUrl(
    paymentId: number,
    query: ReturnQueryFromVNPay,
  ): Promise<Result<{ message: string } & ReturnQueryFromVNPay, Error>> {
    const { vnp_SecureHash, vnp_SecureHashType, ...cloneQuery } = query;

    if (typeof cloneQuery?.vnp_Amount !== 'number') {
      const isValidAmount = numberRegex.test(cloneQuery?.vnp_Amount ?? '');
      if (!isValidAmount) {
        return SuccessOrFailResponse.Failure(new Error('Invalid vnp_Amount format'));
      }
      cloneQuery.vnp_Amount = Number(cloneQuery.vnp_Amount);
    }

    const searchParams = buildPaymentUrlSearchParams(cloneQuery);
    this.logger.log(' ~ VnpayService ~ searchParams:', searchParams);
    const isVerified = verifySecureHash({
      secureSecret: this.globalDefaultConfig.secureSecret,
      data: searchParams.toString(),
      hashAlgorithm: this.HASH_ALGORITHM,
      receivedHash: vnp_SecureHash,
    });

    if (!isVerified) this.logger.warn(` ~ VnpayService ~ isVerified ~ Payment with id ${paymentId} has been unverified`);

    const message = makeVNPayResponse(cloneQuery.vnp_ResponseCode?.toString() ?? '', this.globalDefaultConfig.vnp_Locale);
    this.logger.log(' ~ VnpayService ~ message:', message);

    await this.updatePaymentAfterVerify(paymentId, cloneQuery);

    return isVerified
      ? SuccessOrFailResponse.Success({
          ...cloneQuery,
          vnp_Amount: cloneQuery.vnp_Amount / 100,
          message,
        })
      : SuccessOrFailResponse.Failure(new Error("The payment is unverified. It's not safe to continue"));
  }

  async updatePaymentAfterVerify(paymentId: number, cloneQuery: ReturnQueryFromVNPay) {
    await this.transactionHost.tx.vnpayProvider.update({
      where: { paymentId },
      data: {
        vnp_PayDate: Number(cloneQuery.vnp_PayDate),
        vnp_TransactionStatus: cloneQuery.vnp_TransactionStatus as string,
        vnp_TransactionNo: cloneQuery.vnp_TransactionNo as string,
        metadata: cloneQuery,
      },
    });
  }
}
</file>

<file path="src/services/prisma/transactions/transaction-host.spec.ts">
import { Injectable } from '@nestjs/common';
import { Test } from '@nestjs/testing';
import { AccountType, Prisma } from '@prisma/client';
import { ClsModule } from 'nestjs-cls';
import { PrismaModule } from '../prisma.module';
import { PrismaService } from '../prisma.service';
import { TransactionHost } from './transaction-host';
import { Transactional } from './transactional.decorator';

@Injectable()
class AccountRepository {
  constructor(private readonly txHost: TransactionHost) {}

  async getAccountById(id: number) {
    return this.txHost.tx.account.findUnique({ where: { id } });
  }

  async createAccount(name: string) {
    const random = Math.floor(Math.random() * 1000);
    const account = this.txHost.tx.account.create({
      data: {
        email: `${name}-${random}@gmail.com`,
        password: '12345678',
        phoneNumber: '0822333444',
        accountType: AccountType.STUDENT,
      },
    });
    return account;
  }
}

@Injectable()
class AccountService {
  constructor(
    private readonly accountRepository: AccountRepository,
    private readonly txHost: TransactionHost,
    private readonly prismaService: PrismaService,
  ) {}

  @Transactional()
  async transactionWithDecorator() {
    const r1 = await this.accountRepository.createAccount('john');
    const r2 = await this.accountRepository.getAccountById(r1.id as number);
    return { r1, r2 };
  }

  /*
   * The isolationLevel option is set to Serializable,
   * which means that the transaction is fully isolated from other transactions,
   * preventing phenomena like dirty reads, non-repeatable reads, and phantom reads.
   */
  @Transactional({
    isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
  })
  async transactionWithDecoratorWithOptions() {
    const r1 = await this.accountRepository.createAccount('James');
    const r2 = await this.prismaService.account.findUnique({
      where: { id: r1.id },
    });
    const r3 = await this.accountRepository.getAccountById(r1.id);
    return { r1, r2, r3 };
  }

  async transactionWithFunctionWrapper() {
    return this.txHost.withTransaction(
      {
        isolationLevel: Prisma.TransactionIsolationLevel.Serializable,
      },
      async () => {
        const r1 = await this.accountRepository.createAccount('joe');
        const r2 = await this.prismaService.account.findUnique({
          where: { id: r1.id },
        });
        const r3 = await this.accountRepository.getAccountById(r1.id);
        return { r1, r2, r3 };
      },
    );
  }

  @Transactional()
  async transactionWithDecoratorError() {
    await this.accountRepository.createAccount('nobody');
    throw new Error('Rollback');
  }
}

describe('Transactional', () => {
  let callingService: AccountService;
  let prisma: PrismaService;

  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [
        PrismaModule,
        // Register the ClsModule,
        ClsModule.forRoot({
          global: true,
          middleware: {
            // automatically mount the
            // ClsMiddleware for all routes
            mount: true,
            // and use the setup method to
            // provide default store values.
          },
        }),
      ],
      providers: [AccountRepository, AccountService],
    }).compile();
    await moduleRef.init();
    callingService = moduleRef.get(AccountService);
    prisma = moduleRef.get(PrismaService);
  });

  describe('TransactionalDecorator', () => {
    it('should run a transaction with the default options with a decorator', async () => {
      const { r1, r2 } = await callingService.transactionWithDecorator();
      expect(r1).toEqual(r2);
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });

    it('should run a transaction with the specified options with a decorator', async () => {
      const { r1, r2, r3 } = await callingService.transactionWithDecoratorWithOptions();
      expect(r1).toEqual(r3);
      expect(r2).toBeNull();
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });
    it('should run a transaction with the specified options with a function wrapper', async () => {
      const { r1, r2, r3 } = await callingService.transactionWithFunctionWrapper();
      expect(r1).toEqual(r3);
      expect(r2).toBeNull();
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.arrayContaining([r1]));
    });

    it('should rollback a transaction on error', async () => {
      await expect(callingService.transactionWithDecoratorError()).rejects.toThrow(new Error('Rollback'));
      const users = await prisma.account.findMany();
      expect(users).toEqual(expect.not.arrayContaining([{ name: 'nobody' }]));
    });
  });
});
</file>

<file path="src/services/prisma/transactions/transaction-host.ts">
import { Injectable, Logger } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';
import { isNotEmpty } from 'class-validator';
import { ClsService } from 'nestjs-cls';
import { Propagation } from 'src/domains/notification/shared/transation.enum';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PrismaService } from '../prisma.service';
import { TRANSACTIONAL_INSTANCE } from './transaction.constant';
import { PrismaTransactionOptions } from './transaction.type';

@Injectable()
export class TransactionHost {
  private readonly logger = new Logger(TransactionHost.name);
  constructor(
    private readonly clsService: ClsService,
    private readonly _default: PrismaService,
  ) {}

  /**
   *  The instance of the transaction object.
   *
   * this may be a transaction reference, a database client, or something else.
   *
   * If no transaction is active, this will return the _default (PrismaService) instance.
   */
  get tx(): PrismaClient {
    if (!this.clsService.isActive()) {
      return this._default;
    }

    return this.clsService.get(TRANSACTIONAL_INSTANCE) || this._default;
  }

  /**
   *
   * The transaction instance will be accessible on the TransactionHost as `tx`.
   *
   * This is useful when you want to run a function in a transaction, but can't use the `@Transactional()` decorator.
   *
   * @param fn The function to run in a transaction.
   * @param propagation The propagation mode to use, @see{Propagation}.
   * @param options Transaction options
   * @returns Whatever the passed function returns
   */
  withTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(progation: Propagation, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(progation: Propagation, options: PrismaTransactionOptions, fn: (...args: any[]) => Promise<R>): Promise<R>;
  withTransaction<R>(firstParam: any, secondParam?: any, thirdParam?: (...args: any[]) => Promise<R>) {
    let propagation: string;
    let options: any;
    let fn: (...args: any[]) => Promise<R>;
    if (thirdParam) {
      propagation = firstParam;
      options = secondParam;
      fn = thirdParam;
    } else if (secondParam) {
      fn = secondParam;
      if (typeof firstParam === 'string') {
        propagation = firstParam;
      } else {
        options = firstParam;
      }
    } else {
      fn = firstParam;
    }
    propagation ??= Propagation.Required;
    options = { ...TRANSACTION_TIMEOUT, ...options };
    return this.runWithTransactionAndPropagation(propagation, options, fn);
  }

  runWithTransactionAndPropagation<R>(propagation: string, options: any, fn: (...args: any[]) => Promise<R>): Promise<R> {
    const fnName = fn.name || 'anonymous';
    switch (propagation) {
      case Propagation.Required:
        if (this.isTransactionActive()) {
          if (isNotEmpty(options)) {
            this.logger.warn(
              `Transaction options are ignored because a transaction is already active and the propagation mode is ${propagation} (for method ${fnName}).`,
            );
          }
          return fn();
        } else {
          return this.runWithTransaction(options, fn);
        }
      case Propagation.RequiresNew:
        return this.runWithTransaction(options, fn);
      default:
        throw new ActionFailedException(ActionFailed.UNKNOW_PROPAGATION_MODE, `Unknown propagation mode: ${propagation}`);
    }
  }

  /**
   * Run a function in a transaction.
   *
   * @param fn The function to run in a transaction.
   * @returns Whatever the passed function returns
   */
  runWithTransaction(options: any, fn: (...args: any[]) => Promise<any>) {
    return this.clsService.run({ ifNested: 'inherit' }, async () => {
      return await this._default.$transaction(async (tx: PrismaService) => {
        this.setTxInstance.bind(this)(tx);
        try {
          return await fn();
        } catch (error) {
          throw error;
        } finally {
          this.setTxInstance.bind(this)(undefined);
        }
      }, options);
    });
  }

  /**
   * Wrap a function call to run outside of a transaction.
   *
   * @param fn The function to run outside of a transaction.
   * @returns Whatever the passed function returns
   */
  withoutTransaction<R>(fn: (...args: any[]) => Promise<R>): Promise<R> {
    return this.clsService.run({ ifNested: 'inherit' }, () => {
      this.setTxInstance(undefined);
      return fn().finally(() => this.setTxInstance(undefined));
    });
  }

  isTransactionActive() {
    if (!this.clsService.isActive()) {
      return false;
    }
    const instance = this.clsService.get(TRANSACTIONAL_INSTANCE);
    return !!instance;
  }

  private setTxInstance(txInstance?: PrismaClient) {
    if (!txInstance) {
      this.clsService.set(TRANSACTIONAL_INSTANCE, undefined);
      return;
    }

    this.clsService.set(TRANSACTIONAL_INSTANCE, txInstance);
  }
}
</file>

<file path="src/services/prisma/transactions/transaction.constant.ts">
export const TRANSACTIONAL_INSTANCE = Symbol('TRANSACTIONAL_CLIENT');
</file>

<file path="src/services/prisma/transactions/transaction.symbol.ts">
export const TRANSACTIONAL_INSTANCE = Symbol('TRANSACTIONAL_CLIENT');
</file>

<file path="src/services/prisma/transactions/transaction.type.ts">
import { Prisma, PrismaClient } from '@prisma/client';

export type PrismaTransactionalClient = Parameters<Parameters<PrismaClient['$transaction']>[0]>[0];

// export type PrismaTransactionOptions = Parameters<PrismaClient['$transaction']>[1];

export type PrismaTransactionOptions = { timeout?: number; maxWait: number; isolationLevel?: Prisma.TransactionIsolationLevel };
</file>

<file path="src/services/prisma/transactions/transactional.decorator.ts">
import { Inject } from '@nestjs/common';
import { copyMethodMetadata } from 'nestjs-cls';
import { Propagation } from 'src/domains/notification/shared/transation.enum';
import { TransactionHost } from './transaction-host';
import { PrismaTransactionOptions } from './transaction.type';

export function Transactional(propagation?: Propagation): MethodDecorator;
export function Transactional(options?: PrismaTransactionOptions): MethodDecorator;
export function Transactional(propagation: Propagation, options?: PrismaTransactionOptions): MethodDecorator;
export function Transactional(firstParam?: any, seconParam?: any): MethodDecorator {
  let propagation: Propagation | undefined;
  let options: any;

  if (seconParam) {
    propagation = firstParam;
    options = seconParam;
  } else if (firstParam) {
    if (paramIsPropagationType(firstParam)) {
      propagation = firstParam;
    } else {
      options = firstParam;
    }
  }

  const injectTransactionHost = Inject(TransactionHost);

  return ((target: any, propertyKey: string | symbol, descriptor: TypedPropertyDescriptor<(...args: any) => Promise<any>>) => {
    if (!target.__transactionHost) {
      injectTransactionHost(target, '__transactionHost');
    }
    const original = descriptor.value;
    if (typeof original !== 'function') {
      throw new Error(
        `The @Transactional decorator can be only used on functions, but ${propertyKey.toString()} is not a function.`,
      );
    }
    descriptor.value = new Proxy(original, {
      apply: function (_, outerThis, args: any[]) {
        if (!outerThis['__transactionHost']) {
          throw new Error(`Failed to inject transaction host into ${target.constructor.name}`);
        }
        return (outerThis['__transactionHost'] as TransactionHost).withTransaction(
          propagation as Propagation,
          options as never,
          original.bind(outerThis, ...args),
        );
      },
    });
    copyMethodMetadata(original, descriptor.value);
  }) as MethodDecorator;
}

const paramIsPropagationType = (param: any): param is Propagation => {
  return typeof param === 'string' && Object.values(Propagation).includes(param as Propagation);
};
</file>

<file path="src/services/prisma/prisma-raw.service.ts">
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { PrismaClient } from '@prisma/client';

@Injectable()
export class PrismaRawService extends PrismaClient implements OnModuleInit {
  constructor() {
    super({
      log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    await this.$connect();
  }

  async gracefulShutdown(application: INestApplication) {
    this.$on('beforeExit' as never, async () => {
      await application.close();
    });
  }
}
</file>

<file path="src/services/prisma/prisma.module.ts">
import { Global, Module } from '@nestjs/common';
import { PrismaRawService } from './prisma-raw.service';
import { PrismaService } from './prisma.service';
import { TransactionHost } from './transactions/transaction-host';

@Global()
@Module({
  providers: [PrismaService, PrismaRawService, TransactionHost],
  exports: [PrismaService, PrismaRawService, TransactionHost],
})
export class PrismaModule {}
</file>

<file path="src/services/prisma/prisma.service.ts">
import { INestApplication, Injectable, OnModuleInit } from '@nestjs/common';
import { Prisma, PrismaClient } from '@prisma/client';
import { PRE_FILTER_OPERATIONS } from 'src/shared/constants/prisma.constant';
import { addCreationTimestamps, addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

const uniqueFieldsByModel: Record<string, string[]> = {};
const uniqueIndexFieldsByModel: Record<string, string[]> = {};

Prisma.dmmf.datamodel.models.forEach((model) => {
  // add unique fields derived from indexes
  const uniqueIndexFields: string[] = [];
  model.uniqueFields.forEach((field) => {
    uniqueIndexFields.push(field.join('_'));
  });
  uniqueIndexFieldsByModel[model.name] = uniqueIndexFields;

  // add id field and unique fields from @unique decorator
  const uniqueFields: string[] = [];
  model.fields.forEach((field) => {
    if (field.isId || field.isUnique) {
      uniqueFields.push(field.name);
    }
  });
  uniqueFieldsByModel[model.name] = uniqueFields;
});

@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  constructor() {
    super({
      // log: ['query', 'info', 'warn', 'error'],
    });
  }

  async onModuleInit() {
    await this.$connect();

    Object.assign(
      this,
      this.$extends({
        query: {
          $allModels: {
            async $allOperations({ operation, args, query, model }) {
              const prisma = new PrismaClient();
              // filter the active records
              const filteredWhereConditions = {
                ...(args as any).where,
                isActive: true,
              };

              // change the operation from delete action to update action
              switch (operation) {
                case 'delete':
                  return await prisma[model].update({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps({ isActive: false }),
                  });
                case 'deleteMany':
                  return await prisma[model].updateMany({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps({ isActive: false }),
                  });
                case 'create':
                  return query({
                    ...args,
                    data: addCreationTimestamps(args.data),
                  });
                case 'createMany':
                  return query({
                    ...args,
                    data: (args.data as unknown[]).map((item: unknown) => addCreationTimestamps(item)),
                  });
                case 'update':
                case 'updateMany':
                  return query({
                    ...args,
                    where: filteredWhereConditions,
                    data: addUpdationTimestamps(args.data),
                  });
                default:
                  if (PRE_FILTER_OPERATIONS.includes(operation)) {
                    const filterdArgs = {
                      ...args,
                      where: filteredWhereConditions,
                    } as unknown;
                    return query(filterdArgs);
                  }
                  return query(args);
              }
            },
          },
        },
      }),
    );
  }

  async gracefulShutdown(application: INestApplication) {
    this.$on('beforeExit' as never, async () => {
      await application.close();
    });
  }
}
</file>

<file path="src/services/storage/dto/storage.dto.ts">
export type StorageDTO = {
  size: number;
  url: string;
};
</file>

<file path="src/services/storage/shared/interfaces/file.interface.ts">
import { Readable } from 'node:stream';

export interface IFile {
  /** Name of the form field associated with this file. */
  fieldname: string;
  /** Name of the file on the uploader's computer. */
  originalname: string;
  /** Value of the `Content-Type` header for this file. */
  mimetype: string;
  /** Size of the file in bytes. */
  size: number;
  /**
   * A readable stream of this file. Only available to the `_handleFile`
   * callback for custom `StorageEngine`s.
   */
  stream: Readable;
  /** `DiskStorage` only: Directory to which this file has been uploaded. */
  destination: string;
  /** `DiskStorage` only: Name of this file within `destination`. */
  filename: string;
  /** `DiskStorage` only: Full path to the uploaded file. */
  path: string;
  /** `MemoryStorage` only: A Buffer containing the entire file. */
  buffer: Buffer;
}
</file>

<file path="src/services/storage/shared/interfaces/sharp.interface.ts">
import sharp from 'sharp';

export interface ISharpInputOptions {
  width?: number;
  height?: number;
  options?: sharp.SharpOptions;
}
</file>

<file path="src/services/storage/shared/interfaces/signed-upload-url.interface.ts">
export interface ISignedUploadUrlOptions {
  folder?: string;
  eager?: string;
}
</file>

<file path="src/services/storage/shared/types/cloudinary-config.types.ts">
import type { ConfigOptions, UploadApiErrorResponse, UploadApiResponse } from 'cloudinary';

export type CloudinaryModuleOptions = ConfigOptions;

export type CloudinaryResultResponse =
  | UploadApiResponse
  | UploadApiErrorResponse
  | PromiseLike<UploadApiResponse | UploadApiErrorResponse>;
</file>

<file path="src/services/storage/storage.module.ts">
import { Module, OnModuleInit } from '@nestjs/common';
import { StorageService } from './storage.service';
import { ConfigurableModuleClass } from './storgare.module-definition';

@Module({
  providers: [StorageService],
  exports: [StorageService],
})
export class StorageModule extends ConfigurableModuleClass implements OnModuleInit {
  constructor(private readonly storageService: StorageService) {
    super();
  }

  async onModuleInit() {
    await this.storageService.pingCloudinary();
  }
}
</file>

<file path="src/services/storage/storage.provider.ts">
import { ConfigOptions, v2 } from 'cloudinary';
import { CLD_API_KEY, CLD_API_SECRET, CLD_CLOUD_NAME } from 'src/app.config';
import { CLOUDINARY } from 'src/shared/constants/storage.constant';
export const CloudinaryProvider = {
  provide: CLOUDINARY,
  useFactory: (): ConfigOptions => {
    return v2.config({
      cloud_name: CLD_CLOUD_NAME,
      api_key: CLD_API_KEY,
      api_secret: CLD_API_SECRET,
    });
  },
};
</file>

<file path="src/services/storage/storage.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { StorageService } from './storage.service';

describe('StorageService', () => {
  let service: StorageService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [StorageService],
    }).compile();

    service = module.get<StorageService>(StorageService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/services/storage/storage.service.ts">
import { Inject, Injectable, Logger } from '@nestjs/common';
import { ResourceType, TransformationOptions, UploadApiErrorResponse, UploadApiOptions, UploadApiResponse, v2 } from 'cloudinary';
import sharp from 'sharp';
import { defaultCreateSignedUploadUrlOptions } from 'src/shared/constants/storage.constant';
import { Readable } from 'stream';
import { StorageDTO } from './dto/storage.dto';
import { ISharpInputOptions } from './shared/interfaces/sharp.interface';
import { ISignedUploadUrlOptions } from './shared/interfaces/signed-upload-url.interface';
import { CloudinaryModuleOptions } from './shared/types/cloudinary-config.types';
import { MODULE_OPTIONS_TOKEN } from './storgare.module-definition';

@Injectable()
export class StorageService {
  private logger = new Logger(StorageService.name);

  constructor(
    @Inject(MODULE_OPTIONS_TOKEN)
    private readonly options: CloudinaryModuleOptions,
  ) {
    v2.config(Object.assign({}, options));
  }

  async pingCloudinary() {
    try {
      const res = await v2.api.ping();
      this.logger.log(`Cloudinary ping response: ${res.status}`);
    } catch (e) {
      this.logger.warn('Cloudinary connection failed.');
      this.logger.error(e.error);
    }
  }

  /**
   * It takes a file, uploads it to cloudinary, and returns a promise
   * @param {IFile} file - IFile - This is the file object that is passed to the uploadFile method.
   * @param {UploadApiOptions} [options] - This is the options object that you can pass to the
   * uploader.upload_stream method.
   * @param {ISharpInputOptions} [sharpOptions] - This is an object that contains the options for sharp.
   * @returns {CloudinaryResultResponse},
   */
  async uploadFile(
    file: Express.Multer.File,
    options?: UploadApiOptions,
    sharpOptions?: ISharpInputOptions,
  ): Promise<UploadApiResponse | UploadApiErrorResponse> {
    return new Promise(async (resolve, reject) => {
      const upload = v2.uploader.upload_stream(options, async (error, result) => {
        if (error) {
          this.logger.error(error);
          return reject(error);
        } else {
          resolve(result);
        }
      });

      const stream: Readable = new Readable();
      stream._read = () => {};

      if (sharpOptions && file.mimetype.match(/^image/)) {
        const options = { width: 320, ...sharpOptions };
        const shrinkedImage = await sharp(file.buffer).resize(options).toBuffer();
        stream.push(shrinkedImage);
      } else {
        stream.push(file.buffer);
      }

      stream.push(null);
      stream.pipe(upload);
    });
  }

  /**
   * It returns a signed upload URL.
   * @see https://cloudinary.com/documentation/signatures#using_cloudinary_backend_sdks_to_generate_sha_authentication_signatures
   * @param {string} publicId - This is the public id of the file.
   * @param {ResourceType} resourceType - The type of the resource. See ./node_modules/cloudinary/types/index.d.ts
   * @param {ISignedUploadUrlOptions} [options] - This is an object that contains the options for signing.
   * @returns string
   */
  async createSignedUploadUrl(publicId: string, resourceType: ResourceType, options?: ISignedUploadUrlOptions) {
    options = { ...defaultCreateSignedUploadUrlOptions, ...options };

    const url = `https://api.cloudinary.com/v1_1/${this.options.cloud_name}/${resourceType}/upload`;
    const timestamp = Math.round(new Date().getTime() / 1000);

    const signature = v2.utils.api_sign_request(
      {
        timestamp,
        public_id: publicId,
        // eager: options.eager,
      },
      this.options.api_secret,
    );

    return {
      url,
      publicId,
      api_key: this.options.api_key,
      timestamp,
      eager: options.eager,
      folder: options.folder,
      signature,
    };
  }

  async checkFileExist(publicId: string): Promise<boolean> {
    try {
      const res = await v2.api.resource(publicId);
      return true;
    } catch (error) {
      this.logger.error(error);
      return false;
    }
  }

  async getSignedUrl(publicId: string, options?: TransformationOptions) {
    const isExisted = await this.checkFileExist(publicId);

    if (!isExisted) return null;
    return v2.utils.url(publicId, options);
  }

  async getStorageFile(publicId: string): Promise<StorageDTO | null> {
    try {
      // This will throw error when key not exists
      const file = await v2.api.resource(publicId);
      const url = v2.utils.url(publicId);
      return { size: file.bytes, url };
    } catch (error) {
      this.logger.error(error);
      return null;
    }
  }
  async deleteFile(publicId: string) {
    const isExisted = await this.checkFileExist(publicId);
    if (!isExisted) return false;

    await v2.uploader.destroy(publicId);
    return true;
  }

  async deleteManyFiles(publicIds: string[]) {
    type FileStatus = { publicId: string; isDeleted: boolean };
    const deletedFiles = await Promise.all(
      publicIds.map(
        (publicId) =>
          new Promise<{ publicId: string; isDeleted: boolean }>(async (res) => {
            const isDeleted = await this.deleteFile(publicId);
            res({ publicId, isDeleted });
          }),
      ),
    );

    const getResult = (condition: (f: FileStatus) => boolean) => deletedFiles.filter(condition).map((f) => f.publicId);
    return {
      deletedKeys: getResult((f) => f.isDeleted),
      deletedFailedKeys: getResult((f) => !f.isDeleted),
    };
  }
}
</file>

<file path="src/services/storage/storgare.module-definition.ts">
import { ConfigurableModuleBuilder } from '@nestjs/common';
import { CloudinaryModuleOptions } from './shared/types/cloudinary-config.types';

export const { ConfigurableModuleClass, MODULE_OPTIONS_TOKEN } = new ConfigurableModuleBuilder<CloudinaryModuleOptions>({
  moduleName: 'StorageModule',
})
  .setExtras(
    {
      isGlobal: true,
    },
    (definition, extras) => ({
      ...definition,
      global: extras.isGlobal,
    }),
  )
  .setClassMethodName('forRoot')
  .build();
</file>

<file path="src/services/common.module.ts">
import { Module } from '@nestjs/common';
import { CLD_API_KEY, CLD_API_SECRET, CLD_CLOUD_NAME } from 'src/app.config';
import { AxiosModule } from './axios/axios.module';
import { EmailModule } from './email/email.module';
import { EventNestModule } from './event-emitter/event-emitter.module';
import { FcmModule } from './fcm/fcm.module';
import { GetstreamModule } from './getstream/getstream.module';
import { PrismaModule } from './prisma/prisma.module';
import { StorageModule } from './storage/storage.module';

@Module({
  imports: [
    /* Third-party Services */
    StorageModule.forRootAsync({
      useFactory: async () => ({
        cloud_name: CLD_CLOUD_NAME,
        api_key: CLD_API_KEY,
        api_secret: CLD_API_SECRET,
      }),
    }),
    PrismaModule,
    GetstreamModule,
    AxiosModule,
    FcmModule,
    EventNestModule,
    EmailModule,
  ],
})
export class CommonModule {}
</file>

<file path="src/shared/constants/audio-room.constant.ts">
export enum AudioRoomActivity {
  JOIN = 'JOIN',
  LEAVE = 'LEAVE',
}

export const AUDIO_ROOM_CONSTANT = {
  DEFAULT_VALUE_LEFT_AT: 0,
};
</file>

<file path="src/shared/constants/auth.constant.ts">
export const AUTH_CONSTANT = {
  OTP_CODE_LENGTH: 6, // 615123
  OTP_NEXT_SEND_TIMEOUT: 60, // 60 seconds
  OTP_EXPIRATION_TIMEOUT: 3 * 60, // 3 minutes
  OTP_SMS_MESSAGE: (otp: string) => `BK Sharing, register code is ${otp}`,
};
</file>

<file path="src/shared/constants/category.constant.ts">
export const MAX_CATEGORY_LEVEL = 2;
export const CATEGORY_DEFAULT_LEVEL = 1;
</file>

<file path="src/shared/constants/chat-message.constant.ts">
export enum SOCKET_DOMAINS {
  //   HOST_CMS = '',
  //   HOST_ECM = '*',
  LOCAL_FE = 'http://localhost:3000',
}

export enum SOCKET_CHAT_MESSAGE_EVENT {
  SEND_MESSAGE = 'send-message',
  JOIN_ROOM = 'join-room',
  READ_MESSAGE = 'read-message',
  NEW_MESSAGE = 'newMessage',
}

export const NUMBER_OF_MESSAGE_DEFAULT = 0;
export const NUMBER_MESSAGE_INCREMENT_DEFAULT = 1;
export const NUMBER_PARTICIPANT_INCREMENT_DEFAULT = 1;
export const NUMBER_OF_PARTICIPANT_DEFAULT = 1;
</file>

<file path="src/shared/constants/common.constant.ts">
export const COMMON_CONSTANT = {
  ARRAY_MAX_SIZE: 10,
  ARRAY_MIN_SIZE: 1,
  DEFAULT_INCREMENT: 1,
  DEFAULT_DECREMENT: 1,
  ZERO_VALUE: 0,
};

export const AXIOS_CONFIG = Symbol('AXIOS_CONFIG');

export const numberRegex = /^[0-9]+$/;

export const ACCOUNT_NOT_ACTIVE = false;
</file>

<file path="src/shared/constants/course.constant.ts">
import { CourseStatus } from '@prisma/client';

export const COURSE_PUBLIC_STATUS: CourseStatus[] = [CourseStatus.STOPPED, CourseStatus.APPROVED];

export const COURSE_UPDATE_STATUS: CourseStatus[] = [
  CourseStatus.PENDING,
  CourseStatus.STOPPED,
  CourseStatus.ARCHIVED,
  CourseStatus.DRAFT,
];
</file>

<file path="src/shared/constants/dashboard.constant.ts">
import { PaymentStatus, SubscriptionStatus } from '@prisma/client';

export const StatisticSubsriptionStatus: SubscriptionStatus[] = [
  SubscriptionStatus.ACTIVE,
  SubscriptionStatus.EXPIRED,
  SubscriptionStatus.CANCELED,
];

export const StatisticPaymentStatus: PaymentStatus[] = [PaymentStatus.DONE, PaymentStatus.EXPIRED, PaymentStatus.CANCELED];
</file>

<file path="src/shared/constants/date.constant.ts">
export const DATE_FORMAT = {
  YEAR_MONTH: {
    HYPHEN: 'YYYY-MM',
    DOT: 'YYYY.MM',
  },
  DATE: {
    STICKY: 'YYYYMMDD',
    HYPHEN: 'YYYY-MM-DD',
    UNDERSCORE: 'YYYY_MM_DD',
    SLASH: 'YYYY/MM/DD',
    DOT: 'YYYY.MM.DD',
    STRING: 'MMMM DD, YYYY',
    TEXT: 'YYYY MM DD',
    NO_SPACE: 'YYYYMMDD',
  },
  DATE_TIME: {
    HYPHEN: 'YYYY-MM-DD hh:mm',
    SLASH: 'YYYY/MM/DD hh:mm',
    DOT: 'YYYY.MM.DD hh:mm',
    DOWNLOAD: 'YYYY-MM-DD_hh:mm',
  },
  DATE_TIME_SECOND: {
    HYPHEN: 'YYYY-MM-DD hh:mm:ss',
    HYPHEN_V1: 'YYYY-MM-DD HH:mm:ss',
    SLASH: 'YYYY/MM/DD hh:mm:ss',
    DOT: 'YYYY.MM.DD hh:mm:ss',
    DOWNLOAD: 'YYYY-MM-DD_hh:mm:ss',
    NO_SPACE: 'YYYYMMDDHHmmss',
    ISO8601: 'YYYY-MM-DDThh:mm:ss',
    ISO8601_BEGIN: 'YYYY-MM-DDT00:00:00',
    ISO8601_END: 'YYYY-MM-DDT23:59:59',
  },
  TIME: {
    _12H: 'A hh:mm',
    _12H_PICKER: 'hh:mm A',
    _24H: 'H:m',
  },
  MONTH_YEAR: 'MM-YYYY',
};

export const NO_MONTHS_OF_YEAR = 12;
export const EXCEL_DATE_FORMAT = DATE_FORMAT.DATE.HYPHEN;

export const DAY_OF_WEEK = {
  0: 'SUNDAY',
  1: 'MONDAY',
  2: 'TUESDAY',
  3: 'WEDNESDAY',
  4: 'THURSDAY',
  5: 'FRIDAY',
  6: 'SATURDAY',
};
</file>

<file path="src/shared/constants/event.constant.ts">
export enum AudioCallChannel {
  LEAVE_CALL = 'call.session_participant_left',
}
</file>

<file path="src/shared/constants/notification.constant.ts">
import { AccountSuspensionType, CourseSuspensionType, NotificationType } from '@prisma/client';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';

export const NOTIFICATION_MESSAGES = new Map<NotificationType, Record<string, string>>([
  [NotificationType.COURSE_CREATED, { title: 'New Course Created', content: 'A new course has been created successfully.' }],
  [NotificationType.COURSE_UPDATED, { title: 'Course Updated', content: 'A course has been updated successfully.' }],
  [NotificationType.COURSE_DELETED, { title: 'Course Deleted', content: 'A course has been deleted from the platform.' }],
  [NotificationType.COURSE_APPROVED, { title: 'Course Approved', content: 'Your course has been approved successfully.' }],
  [NotificationType.COURSE_REJECTED, { title: 'Course Rejected', content: 'Your course has been rejected.' }],
  [
    NotificationType.COURSE_SUSPENDED_WARNING,
    { title: 'Course Suspension Warn', content: 'Please review your course content for ensuring the quality.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_3_DAYS,
    { title: 'Course Suspended', content: 'Your course has been suspended for 3 days.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_7_DAYS,
    { title: 'Course Suspended', content: 'Your course has been suspended for 7 days.' },
  ],
  [
    NotificationType.COURSE_SUSPENDED_PERMANENTLY,
    { title: 'Course Suspended', content: 'Your course has been suspended permanently.' },
  ],
  [
    NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_COURSE_SUSPENSION,
    { title: 'Subscription Canceled', content: 'Your subscription has been canceled because the course has been suspended.' },
  ],
  [
    NotificationType.SUBSCRIPTION_CANCELED_BECAUSE_OF_MENTOR_SUSPENSION,
    { title: 'Subscription Canceled', content: 'Your subscription has been canceled by the mentor.' },
  ],
  [
    NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_COURSE_SUSPENSION,
    {
      title: 'Subscription Refunded',
      content: 'Your subscription has been refunded because the course has been suspended. We will try refunding within a week',
    },
  ],
  [
    NotificationType.SUBSCRIPTION_REFUND_BECAUSE_OF_MENTOR_SUSPENSION,
    {
      title: 'Subscription Refunded',
      content: 'Your subscription has been refunded by the mentor. We will try refunding within a week',
    },
  ],
  [
    NotificationType.MENTOR_REGISTERD,
    { title: 'Mentor Registered', content: 'A new mentor has been registered waiting for the consideration.' },
  ],
  [NotificationType.MENTOR_APPROVED, { title: 'Mentor Approved', content: 'Your mentor request has been approved.' }],
  [NotificationType.MENTOR_REJECTED, { title: 'Mentor Rejected', content: 'Your mentor request has been rejected.' }],
  [NotificationType.AUDIO_CALL_CREATED, { title: 'Audio Call Created', content: 'You have a new audio call' }],
  [
    NotificationType.SUBSCRIPTION_CREATED,
    { title: 'Subscription Request', content: 'A new subscription request has been made for your course.' },
  ],
  [
    NotificationType.SUBSCRIPTION_APPROVED,
    { title: 'Subscription Approved', content: 'Your subscription request has been approved successfully.' },
  ],
  [
    NotificationType.SUBSCRIPTION_REJECTED,
    { title: 'Subscription Rejected', content: 'Your subscription request has been rejected.' },
  ],
  [NotificationType.SUBSCRIPTION_EXPIRED, { title: 'Subscription Expired', content: 'This subscription has been expired.' }],
  [NotificationType.PAYMENT_SUCCESS, { title: 'Payment Successful', content: 'The subscription is paid successfully' }],
  [
    NotificationType.PAYMENT_FAILED,
    { title: 'Payment Failed', content: 'There was an issue processing your payment. Please try again.' },
  ],
  [
    NotificationType.DISCOUNT_AVAILABLE,
    { title: 'New Discount Available', content: "A new discount is now available. Don't miss out!" },
  ],
  [NotificationType.ADMIN_APPROVAL, { title: 'Admin Approval Required', content: 'Your request is awaiting admin approval.' }],
  [NotificationType.GENERAL_NOTIFICATION, { title: 'Notification', content: 'You have a new notification.' }],
  [NotificationType.COURSE_REPORTED, { title: 'Course Reported', content: 'One course has been reported.' }],
  [NotificationType.MENTOR_REPORTED, { title: 'Mentor Reported', content: 'One mentor has been reported.' }],
  [NotificationType.FEEDBACK_REPORTED, { title: 'Feedback Reported', content: 'One feedback has been reported.' }],
  [
    NotificationType.REPORT_RESOLVED,
    { title: 'Report Resolved', content: 'Your report has been resolved. Please check the resolution.' },
  ],
  [
    NotificationType.REPORT_REJECTED,
    { title: 'Report Rejected', content: 'Your report has been rejected. Please check the resolution.' },
  ],
  [
    NotificationType.FEEDBACK_CONTAIN_INAPPROPRIATE_CONTENT,
    {
      title: 'Your feedback has been reported by author of the course',
      content: 'Your feedback has been removed because of violation or inappropriate content.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_3_DAYS,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended for 3 days due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_7_DAYS,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended for 7 days due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_PERMANENTLY,
    {
      title: 'Account Suspended',
      content: 'Your account has been suspended permanently due to violation of terms and conditions.',
    },
  ],
  [
    NotificationType.ACCOUNT_SUSPENDED_WARNING,
    {
      title: 'Account Suspension Warning',
      content: 'Your account has been reported for violation of terms and conditions. Please review your activities.',
    },
  ],
]);

export const getNotificationMessage = (type: NotificationType) => {
  if (!NOTIFICATION_MESSAGES.has(type)) {
    throw new ActionFailedException(ActionFailed.NOTIFICATION_TYPE_NOT_FOUND, 'Notification type not found.');
  }
  return NOTIFICATION_MESSAGES.get(type);
};

export const NOTIFICATION_SUSPENSION_ACCOUNT_MAPPER = new Map<AccountSuspensionType, NotificationType>([
  [AccountSuspensionType.ACCOUNT_NOT_SUSPENDED, NotificationType.ACCOUNT_SUSPENDED_WARNING],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_3_DAYS, NotificationType.ACCOUNT_SUSPENDED_3_DAYS],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_7_DAYS, NotificationType.ACCOUNT_SUSPENDED_7_DAYS],
  [AccountSuspensionType.ACCOUNT_SUSPENDED_PERMANENTLY, NotificationType.ACCOUNT_SUSPENDED_PERMANENTLY],
]);

export const NOTIFICATION_SUSPENSION_COURSE_MAPPER = new Map<CourseSuspensionType, NotificationType>([
  [CourseSuspensionType.COURSE_NOT_SUSPENDED, NotificationType.COURSE_SUSPENDED_WARNING],
  [CourseSuspensionType.COURSE_SUSPENDED_3_DAYS, NotificationType.COURSE_SUSPENDED_3_DAYS],
  [CourseSuspensionType.COURSE_SUSPENDED_7_DAYS, NotificationType.COURSE_SUSPENDED_7_DAYS],
  [CourseSuspensionType.COURSE_SUSPENDED_PERMANENTLY, NotificationType.COURSE_SUSPENDED_PERMANENTLY],
]);

export const EMAIL_NOTIFICATION = {
  ACCOUNT_REGISTERED: {
    subject: 'BK SHARING - Welcome to BK Sharing',
    text: 'Welcome to BK Sharing. Your account has been created successfully. Please verify your email address.',
  },
  ACCOUNT_RESET_PASSWORD: {
    subject: 'BK SHARING - Reset Password',
    text: 'You have requested to reset your password. Please click on the link to reset your password.',
  },
};

export const EMAIL_TEMPLATES = {
  EMAIL_VERIFICATION: './authentication-email-verification',
  RESET_PASSWORD: './reset-password-verification',
};

export const EMAIL_PATH = {
  EMAIL_VERIFICATION: 'email-verification/',
  RESET_PASSWORD: 'reset-password-verification/',
};
</file>

<file path="src/shared/constants/payment.constant.ts">
export const ReturnPaymentStatus = {
  SUCCESSFUL_STATUS: '00',
  EXPIRED_STATUS: '11',
};
</file>

<file path="src/shared/constants/prisma.constant.ts">
import { defaultSortAsc, defaultSortDesc } from '../helpers/query.helper';

export const PRE_FILTER_OPERATIONS = ['findMany', 'findFirst', 'findFirstOrThrow', 'findUnique', 'findUniqueOrThrow', 'count'];
export const TRANSACTION_TIMEOUT = { timeout: 10000 * 60 * 3, maxWait: 100000 };
export const IS_ACTIVE_NESTED = { isActive: true };
export const IS_INACTIVE_NESTED = { isActive: false };
export const ORDER_CREATED_AT_DESC = { orderBy: defaultSortDesc };
export const ORDER_CREATED_AT_ASC = { orderBy: defaultSortAsc };
</file>

<file path="src/shared/constants/report.constant.ts">
import { NotificationType, ReportType } from '@prisma/client';

export const ReportNotificationMap = new Map<ReportType, NotificationType>([
  [ReportType.COURSE_UNQUALIFIED, NotificationType.COURSE_REPORTED],
  [ReportType.FEEDBACK_INAPPROPRIATE, NotificationType.FEEDBACK_REPORTED],
  [ReportType.MENTOR_ISSUES, NotificationType.MENTOR_REPORTED],
]);

export const REPORT_SUBSCRIPTION_TYPE: ReportType[] = [ReportType.COURSE_UNQUALIFIED, ReportType.MENTOR_ISSUES];
export const REPORT_FEEDBACK_TYPE: ReportType[] = [ReportType.FEEDBACK_INAPPROPRIATE];

export enum ReportSubscriptionPushnishment {
  MENTOR_SUSPENSION = 'MENTOR_SUSPENSION',
  COURSE_SUSPENSION = 'COURSE_SUSPENSION',
}

export const REPORT_DURATION_TIME_QUERY = 3 * 30 * 24 * 60 * 60;
</file>

<file path="src/shared/constants/storage.constant.ts">
import { ISignedUploadUrlOptions } from 'src/services/storage/shared/interfaces/signed-upload-url.interface';

export const CLOUDINARY = Symbol('CLOUDINARY');

export const defaultCreateSignedUploadUrlOptions: Partial<ISignedUploadUrlOptions> = {
  folder: undefined,
  eager: undefined,
};

export const CLD_UPLOAD_IMAGE_OPTIONS = {
  access_mode: 'public',
  folder: 'images',
  use_filename: true,
};

export enum CLD_FOLDER {
  IMAGES = 'images',
  VIDEOS = 'videos',
  CVs = 'CVs',
  FILES = 'files',
}

export const IMAGE_TYPE = 'image';
</file>

<file path="src/shared/constants/subscription.constant.ts">
import { SubscriptionStatus } from '@prisma/client';

export const SUBSCRIPTION_NOT_CANCELED_STATUS: SubscriptionStatus[] = [
  SubscriptionStatus.CANCELED,
  SubscriptionStatus.REJECTED,
  SubscriptionStatus.EXPIRED,
  SubscriptionStatus.ENDED,
];

export const SUBSCRIPTION_ACTIVE_STATUS: SubscriptionStatus[] = [
  SubscriptionStatus.ACTIVE,
  SubscriptionStatus.PENDING,
  SubscriptionStatus.ACCEPTED,
];

export const SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO: SubscriptionStatus[] = [
  SubscriptionStatus.ACCEPTED,
  SubscriptionStatus.ACTIVE,
];

// 3 days
// export const MIN_NEW_SUBSCRIPTION_DURATION = 60 * 60 * 24 * 3 * 1000;
export const MIN_NEW_SUBSCRIPTION_DURATION = 0;

// 2 days
export const EXPIRED_PENDING_SUBSCRIPTION = 60 * 60 * 24 * 2 * 1000;

// 1 days
// export const EXPIRED_SUBSCRIPTION_AFTER_APPROVED = 60 * 60 * 24 * 1000;
export const EXPIRED_SUBSCRIPTION_AFTER_APPROVED = 60 * 60 * 24 * 1000;
</file>

<file path="src/shared/enums/common.enum.ts">
export enum SYMBOL {
  PLUS = '+',
  MINUS = '-',
  TIMES = '*',
  DIVIDE = '/',
  COMMA = ',',
  DOT = '.',
}

export enum DateRangeFilter {
  ALL = 'ALL',
  TODAY = 'TODAY',
  ONE_WEEK = '1_WEEK',
  ONE_MONTH = '1_MONTH',
  THREE_MONTHS = '3_MONTHS',
  SIX_MONTHS = '6_MONTHS',
  ONE_YEAR = '1_YEAR',
}
</file>

<file path="src/shared/enums/query.enum.ts">
export enum SortOrder {
  ASC = 'asc',
  DESC = 'desc',
}
</file>

<file path="src/shared/exceptions/action-failed.exception.ts">
import { ConflictException } from '@nestjs/common';

export enum ActionFailed {
  DATE_TIME_INVALID = 'DATE_TIME_INVALID',
  AUTH_ACCOUNT_FORBIDDEN = 'AUTH_ACCOUNT_FORBIDDEN',
  AUTH_TOKEN_INVALID = 'AUTH_TOKEN_INVALID',
  UNKNOW_PROPAGATION_MODE = 'UNKNOW_PROPAGATION_MODE',
  ACCOUNT_NOT_FOUND = 'ACCOUNT_NOT_FOUND',
  ACCOUNT_INVALID_ROLE = 'ACCOUNT_INVALID_ROLE',
  ACCOUNT_EMAIL_EXISTED = 'ACCOUNT_EMAIL_EXISTED',
  ACCOUNT_PHONE_NUMBER_EXISTED = 'ACCOUNT_PHONE_NUMBER_EXISTED',
  ACCOUNT_NOT_VERIFIED = 'ACCOUNT_NOT_VERIFIED',
  ACCOUNT_SUSPENDED = 'ACCOUNT_SUSPENDED',
  ACCOUNT_EMAIL_NOT_FOUND = 'ACCOUNT_EMAIL_NOT_FOUND',
  CLASS_TYPE_NOT_FOUND = 'CLASS_TYPE_NOT_FOUND',
  INCORRECT_PASSWORD = 'INCORRECT_PASSWORD',
  AUTH_PHONE_EXISTED = 'AUTH_PHONE_EXISTED',
  AUTH_EMAIL_EXISTED = 'AUTH_EMAIL_EXISTED',
  AUTH_PHONE_NUMBER_NOT_REGISTERED = 'AUTH_PHONE_NUMBER_NOT_REGISTERED',
  AUTH_ACHIEVEMENT_INVALID_TYPE = 'AUTH_ACHIEVEMENT_INVALID_TYPE',
  AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED = 'AUTH_MENTOR_ACHIEVEMENT_CURRENT_DUPLICATED',
  CATEGORY_NOT_FOUND = 'CATEGORY_NOT_FOUND',
  CATEGORY_LEVEL_EXCEED_MAXIMUM = 'CATEGORY_LEVEL_EXCEED_MAXIMUM',
  CATEGORY_PARENT_SHOULD_NOT_RECOMMENDED = 'CATEGORY_PARENT_SHOULD_NOT_RECOMMENDED',
  CATEGORY_ORDINAL_OVERLAP = 'CATEGORY_ORDINAL_OVERLAP',
  CATEGORY_PARENT_DELETE_FAILED = 'CATEGORY_PARENT_DELETE_FAILED',
  CATEGORY_HAS_CHILD_CATEGORIES = 'CATEGORY_HAS_CHILD_CATEGORIES',
  IMAGE_ENABLE_QUANTITY_NOT_MATCH = 'IMAGE_ENABLE_QUANTITY_NOT_MATCH',
  AUDIO_CALL_STARTS_AT_INVALID = 'AUDIO_CALL_STARTS_AT_INVALID',
  MENTOR_NOT_FOUND = 'MENTOR_NOT_FOUND',
  MENTOR_INTERVIEW_ACCEPTED = 'MENTOR_INTERVIEW_ACCEPTED',
  MENTOR_INTERVIEW_EXISTED = 'MENTOR_INTERVIEW_EXISTED',
  MENTOR_CANNOT_UPDATE_RESULT = 'MENTOR_CANNOT_UPDATE_RESULT',
  MENTOR_NOT_BELONG_TO_THIS_ACCOUNT = 'MENTOR_NOT_BELONG_TO_THIS_ACCOUNT',
  MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND = 'MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND',
  MENTOR_NOT_YET_ACCEPTED = 'MENTOR_NOT_YET_ACCEPTED',
  MENTOR_SCHEDULE_OVERLAP = 'MENTOR_SCHEDULE_OVERLAP',
  MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR = 'MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR',
  MENTOR_SCHEDULE_END_TIME_BEFORE_START_TIME = 'MENTOR_SCHEDULE_END_TIME_BEFORE_START_TIME',
  MENTOR_SCHEDULE_NOT_FOUND = 'MENTOR_SCHEDULE_NOT_FOUND',
  CALL_INVALID = 'CALL_INVALID',
  CALL_NOT_FOUND = 'CALL_NOT_FOUND',
  CALL_AUDIO_CAN_NOT_START = 'CALL_AUDIO_CAN_NOT_START',
  CALL_AUDIO_NOT_HAVE_PERMISSION = 'CALL_AUDIO_NOT_HAVE_PERMISSION',
  CALL_AUDIO_CAN_NOT_JOIN = 'CALL_AUDIO_CAN_NOT_JOIN',
  CALL_AUDIO_CAN_NOT_LEAVE = 'CALL_AUDIO_CAN_NOT_LEAVE',
  CALL_AUDIO_CAN_NOT_CANCEL = 'CALL_AUDIO_CAN_NOT_CANCEL',
  CALL_PARTICIPANT_JOINED = 'CALL_PARTICIPANT_JOINED',
  CALL_PARTICIPANT_NOT_FOUND = 'CALL_PARTICIPANT_NOT_FOUND',
  COURSE_NOT_FOUND = 'COURSE_NOT_FOUND',
  COURSE_NOT_BELONG_TO_THIS_ACCOUNT = 'COURSE_NOT_BELONG_TO_THIS_ACCOUNT',
  COURSE_CANNOT_VIEW_DETAIL = 'COURSE_CANNOT_VIEW_DETAIL',
  COURSE_SECTION_NOT_FOUND_IN_COURSE = 'COURSE_SECTION_NOT_FOUND_IN_COURSE',
  COURSE_STATUS_CANNOT_UPDATE = 'COURSE_STATUS_CANNOT_UPDATE',
  COURSE_NOT_AVAILABLE = 'COURSE_NOT_AVAILABLE',
  COURSE_HAS_ACTIVE_SUBSCRIPTION = 'COURSE_HAS_ACTIVE_SUBSCRIPTION',
  SUBSCRIPTION_NOT_BELONG_TO_USER = 'SUBSCRIPTION_NOT_BELONG_TO_USER',
  SUBSCRIPTION_NOT_AVAILABLE = 'SUBSCRIPTION_NOT_AVAILABLE',
  SUBSCRIPTION_NOT_MAKE_PAYMENT = 'SUBSCRIPTION_NOT_MAKE_PAYMENT',
  SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW = 'SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW',
  SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE = 'SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE',
  SUBSCRIPTION_NOT_CANCEL = 'SUBSCRIPTION_NOT_CANCEL',
  SUBSCRIPTION_ALREADY_ACTIVE = 'SUBSCRIPTION_ALREADY_ACTIVE',
  SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS = 'SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS',
  SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT = 'SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT',
  SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE = 'SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE',
  PAYMENT_NOT_AVAILABLE = 'PAYMENT_NOT_AVAILABLE',
  MENTOR_SCHEDULE_NOT_AVAILABLE = 'MENTOR_SCHEDULE_NOT_AVAILABLE',
  MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK = 'MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK',
  MENTOR_SCHEDULE_IS_BOOKED = 'MENTOR_SCHEDULE_IS_BOOKED',
  CHAT_ROOM_NOT_INCLUDE_USER = 'CHAT_ROOM_NOT_INCLUDE_USER',
  NOTIFICATION_TYPE_NOT_FOUND = 'NOTIFICATION_TYPE_NOT_FOUND',
  NOTIFICATION_INVALID_RELATION_TYPE = 'NOTIFICATION_INVALID_RELATION_TYPE',
  FEEDBACK_NOT_ENOUGH_PERMISSION = 'FEEDBACK_NOT_ENOUGH_PERMISSION',
  FEEDBACK_STUDENT_MUST_TAKE_THE_COURSE_OF_MENTOR = 'FEEDBACK_STUDENT_MUST_TAKE_THE_COURSE_OF_MENTOR',
  FEEDBACK_NOT_FOUND = 'FEEDBACK_NOT_FOUND',
  FEEDBACK_NOT_BELONG_TO_REVIEWER = 'FEEDBACK_NOT_BELONG_TO_REVIEWER',
  FEEDBACK_ALREADY_EXISTS = 'FEEDBACK_ALREADY_EXISTS',
  FEEDBACK_REQUIRE_COURSE_OR_MENTOR_ID = 'FEEDBACK_REQUIRE_COURSE_OR_MENTOR_ID',
  REPORT_INVALID_TYPE = 'REPORT_INVALID_TYPE',
  REPORT_NOT_FOUND = 'REPORT_NOT_FOUND',
  REPORT_FEEDBACK_NOT_FOUND = 'REPORT_FEEDBACK_NOT_FOUND',
  REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO = 'REPORT_QUANTITY_MUST_BE_GREATER_THAN_OR_EQUAL_TO_ZERO',
  REPORT_INVALID_PUSHNISHMENT = 'REPORT_INVALID_PUSHNISHMENT',
}

export class ActionFailedException extends ConflictException {
  constructor(action: ActionFailed, message?: string, attachment?: object) {
    super({ action, message, attachment });
    super.name = ActionFailedException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/asset-file-not-existed.exception.ts">
import { ConflictException } from '@nestjs/common';

export class AssetFileNotExisted extends ConflictException {
  constructor(fileId?: number | number[]) {
    const message = `File id(s) = ${typeof fileId === 'number' ? fileId : fileId.join(', ')} doesn't exist`;
    super(message);
    super.name = AssetFileNotExisted.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/database-connnection.exception.ts">
import { InternalServerErrorException } from '@nestjs/common';

export class DatabaseConnectionException extends InternalServerErrorException {
  constructor(message: string) {
    const errorMessage = `Database connection error: ${message}`;
    super(errorMessage);
    super.name = DatabaseConnectionException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/entity-not-found.exception.ts">
import { NotFoundException } from '@nestjs/common';
import { capitalize } from 'lodash';

export class EntityNotFoundException extends NotFoundException {
  constructor(entityName?: string, errorMsg?: string) {
    let message = entityName ? `${capitalize(entityName)} not found.` : 'Entity not found';
    if (errorMsg) message = errorMsg;
    super(message);
    super.name = EntityNotFoundException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/key-duplication.exception.ts">
import { ConflictException } from '@nestjs/common';

export class KeyDuplicationException extends ConflictException {
  constructor(keyName: string, entityName?: string) {
    const message = `Key ${entityName} in model [${keyName}] is duplicated`;
    super(message);
    super.name = KeyDuplicationException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/prisma-client-validation.exception.ts">
import { UnprocessableEntityException } from '@nestjs/common';

export class PrismaClientValidationException extends UnprocessableEntityException {
  constructor(message?: string) {
    message = message;
    super(message);
    super.name = PrismaClientValidationException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/relation-violation.request.ts">
import { ConflictException } from '@nestjs/common';

export class RelationViolationException extends ConflictException {
  constructor(relationName: string, modelA: string, modelB: string) {
    const errorMessage = `The change you are trying to make would violate the required relation ${relationName} between the ${modelA} and ${modelB} models.`;
    super(errorMessage);
    super.name = RelationViolationException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/toss-payment-validate.exception.ts">
export class ValidationException extends Error {
  constructor(message: string) {
    super(message);
    this.name = 'ValidationException';
  }
}
</file>

<file path="src/shared/exceptions/unknown-prisma.exception.ts">
import { ConflictException } from '@nestjs/common';

export class UnknownPrismaException extends ConflictException {
  constructor(message: string) {
    const errorMessage = `An unknown error occurred with Prisma: ${message}`;
    super(errorMessage);
    super.name = UnknownPrismaException.name;
    super.message = errorMessage;
  }
}
</file>

<file path="src/shared/exceptions/write-fail-exception.ts">
import { ConflictException } from '@nestjs/common';

export class WriteFailedException extends ConflictException {
  constructor(action: 'create' | 'update' | 'delete', errorMessage: string) {
    const message = `Can't perform ${action} because ${errorMessage}`;
    super(message);
    super.name = WriteFailedException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/exceptions/write-relation-not-found.exception.ts">
import { ConflictException } from '@nestjs/common';
import { capitalize, startCase, toLower } from 'lodash';

export class WriteRelationNotFoundException extends ConflictException {
  constructor(action?: 'create' | 'update' | 'delete', conflictEntityName: string = 'entity', realCause?: string) {
    const entityName = startCase(toLower(conflictEntityName));
    let message = action ? `${capitalize(action)} action` : 'Action';
    message += ` can't execute due to not found ${entityName} or related to ${entityName}.`;
    message += realCause ? ` Detail: ${realCause}` : '';
    super(message);
    super.name = WriteRelationNotFoundException.name;
    super.message = message;
  }
}
</file>

<file path="src/shared/generics/base.response.ts">
import { Nullable } from './type.helper';

export class BaseResponse<T> {
  data: Nullable<T | null>;
  message: string;

  private constructor(data: Nullable<T>, message: string) {
    this.data = data;
    this.message = message;
  }

  public static of<T>(data: T): BaseResponse<T> {
    return new BaseResponse(data, 'OK');
  }

  public static error<T>(error: any): BaseResponse<Nullable<T>> {
    return new BaseResponse(null, error);
  }

  public static ok<T>(): BaseResponse<Nullable<T>> {
    return new BaseResponse(null, 'OK');
  }
}

export type Success<T> = { success: true; data: T };
export type Failure<E> = { success: false; error: E };
export type Result<T, E> = Success<T> | Failure<E>;
</file>

<file path="src/shared/generics/pagination.request.ts">
import { Transform } from 'class-transformer';
import { IsNumber, IsOptional, Min } from 'class-validator';

export class PaginationREQ {
  @IsNumber()
  @IsOptional()
  @Min(1)
  @Transform(({ value }) => value && parseInt(value))
  pageSize?: number;

  @IsNumber()
  @IsOptional()
  @Transform(({ value }) => value && parseInt(value))
  @Min(1)
  pageNumber?: number;
}
</file>

<file path="src/shared/generics/pagination.response.ts">
import { Nullable } from './type.helper';

export class PaginationResponse<T> {
  data: Nullable<T | null>;
  total: any;

  private constructor(data: Nullable<T>, total: number) {
    this.data = data;
    this.total = total;
  }

  public static of<T>(data: T[]): PaginationResponse<T[]> {
    return new PaginationResponse(data, data.length);
  }

  public static ofWithTotal<T>(data: T[], total: number): PaginationResponse<T[]> {
    return new PaginationResponse(data, total);
  }

  public static ok<T>(): PaginationResponse<T[]> {
    return new PaginationResponse(null, null);
  }
}
</file>

<file path="src/shared/generics/toss-payment-result.response.ts">
export type Success<T> = { success: true; _tag: 'Success'; data: T };
export type Failure<E> = { success: false; _tag: 'Failure'; error: E };
export type Result<T, E> = Success<T> | Failure<E>;
</file>

<file path="src/shared/generics/type.helper.ts">
/* Nil */
export type Nil<T> = T | null | undefined;
export type NilFields<T> = {
  [K in keyof T]?: T[K] | null | undefined;
};
export type WithNilFields<T, Fields extends keyof T> = {
  [K in keyof T]: K extends Fields ? T[K] | null | undefined : T[K];
};
export type WithNonNilFields<T, Fields extends keyof T> = {
  [K in Fields]-?: T[K]; // Ensure the keys in Fields are non-nullable and required
} & {
  [K in Exclude<keyof T, Fields>]?: T[K] | null | undefined; // Make all other keys nullable and optional
};

/* Nullable */
export type Nullable<T> = T | null;
export type NullableFields<T> = {
  [K in keyof T]?: T[K] | null;
};
export type WithNullableFields<T, Fields extends keyof T> = {
  [K in keyof T]: K extends Fields ? T[K] | null : T[K];
};
export type WithNonNullableFields<T, Fields extends keyof T> = {
  [K in Fields]-?: T[K]; // Ensure the keys in Fields are non-nullable and required
} & {
  [K in Exclude<keyof T, Fields>]?: T[K] | null; // Make all other keys nullable and optional
};

/* Deep Nullable */
export type DeepNullableBy<T, Fields extends keyof T> = {
  [K in keyof T]?: K extends Fields ? DeepNullableBy<T[K], any> | null : T[K];
};
export type DeepNullable<T> = {
  [K in keyof T]: DeepNullable<T[K]> | null;
};

export type DeepPartialBy<T, Fields extends keyof T> = {
  [K in keyof T]?: K extends Fields ? DeepPartialBy<T[K], any> : T[K];
};
export type WithOptional<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;
export type ExcelSheetValue<T> = { [key in keyof T]: { name: string; width?: number } };

export type ExcelSheetExtendValue<T> = {
  [K in keyof T]: T[K] extends Array<infer E>
    ? {
        [P in keyof E as `${K & string}${Extract<P, number>}`]: {
          name: `${Extract<P, number>}`;
          width?: number;
          idx: number;
        };
      }
    : { name: string; width?: number; idx: number };
};

export type Mutable<T> = {
  -readonly [P in keyof T]: T[P];
};

export type Success<T> = { success: true; _tag: 'Success'; data: T };
export type Failure<E> = { success: false; _tag: 'Failure'; error: E };
export type Result<T, E> = Success<T> | Failure<E>;

export const SuccessOrFailResponse = Object.freeze({
  Success: <T, E>(data: T): Result<T, E> => ({ success: true, _tag: 'Success', data }),
  Failure: <T, E>(error: E): Result<T, E> => ({ success: false, _tag: 'Failure', error }),
});
</file>

<file path="src/shared/helpers/add-timestamp.helper.ts">
import { Nil } from '../generics/type.helper';

export const addCreationTimestamps = (obj: Nil<any>) => {
  return {
    ...obj,
    createdAt: new Date().valueOf(),
    updatedAt: new Date().valueOf(),
  };
};

export const addUpdationTimestamps = (obj: Nil<any>) => {
  return {
    ...obj,
    updatedAt: new Date().valueOf(),
  };
};
</file>

<file path="src/shared/helpers/category.helper.ts">
import { Nil } from '../generics/type.helper';

export function generateSlug(str?: Nil<string>): string | undefined {
  if (!str) return undefined;
  return str.toLowerCase().replace(/ /g, '-');
}
</file>

<file path="src/shared/helpers/common.helper.ts">
import { AxiosError } from 'axios';
import { Result, SuccessOrFailResponse } from '../generics/type.helper';
import { parseHourMinFromString } from '../parsers/datetime.parse';

export const nowEpoch = () => new Date().valueOf();
export const runFunctionWithCondition = (condition: boolean, fn: (...args: any[]) => any | Promise<any>) => {
  if (condition) {
    fn();
  }
};

export const makeResult = async <T>(execution: () => Promise<T>): Promise<Result<T, AxiosError>> => {
  try {
    return SuccessOrFailResponse.Success(await execution());
  } catch (error) {
    if (error instanceof AxiosError) {
      return SuccessOrFailResponse.Failure<T, AxiosError>(error);
    }
    throw error;
  }
};

export const resolveUrlString = (host: string, path: string) => {
  let trimmedHost = host.trim();
  let trimmedPath = path.trim();

  while (trimmedHost.endsWith('/') && trimmedPath.startsWith('\\')) {
    trimmedHost = trimmedHost.slice(0, -1);
  }

  while (trimmedPath.startsWith('/') && trimmedPath.startsWith('\\')) {
    trimmedPath = trimmedPath.slice(1);
  }

  return `${trimmedHost}/${trimmedPath}`;
};

export const checkHourMinStartOverlap = (start1: string, end1: string, start2: string = null, end2: string = null) => {
  const start1Date = parseHourMinFromString(start1);
  const end1Date = parseHourMinFromString(end1);
  const start2Date = parseHourMinFromString(start2);
  const end2Date = parseHourMinFromString(end2);

  if (start1Date >= end1Date || start2Date >= end2Date) {
    return true;
  } else if (start1Date >= start2Date && start1Date < end2Date) {
    return true;
  } else if (end1Date > start2Date && end1Date <= end2Date) {
    return true;
  }

  return false;
};
</file>

<file path="src/shared/helpers/date-range.helper.ts">
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { DateRangeFilter } from '../enums/common.enum';
import { getDiffOfTwoDays, getMillisecondsFromCurrentDate } from '../parsers/datetime.parse';

export const filterByDateRange = (dateRange: DateRangeFilter) => {
  switch (dateRange) {
    case DateRangeFilter.TODAY:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ days: 0, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_WEEK:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ days: 7, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_MONTH:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 1, fromBeginning: true }) },
      };
    case DateRangeFilter.THREE_MONTHS:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 3, fromBeginning: true }) },
      };
    case DateRangeFilter.SIX_MONTHS:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ months: 6, fromBeginning: true }) },
      };
    case DateRangeFilter.ONE_YEAR:
      return {
        createdAt: { gte: getMillisecondsFromCurrentDate({ years: 1, fromBeginning: true }) },
      };
    default:
      return {};
  }
};

export const getDiffDaysOfDateRange = (dateRange: DateRangeFilter) => {
  let diff: any;
  switch (dateRange) {
    case DateRangeFilter.TODAY:
      return 0;
    case DateRangeFilter.ONE_WEEK:
      return 7;
    case DateRangeFilter.ONE_MONTH:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 1 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.THREE_MONTHS:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 3 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.SIX_MONTHS:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ months: 6 }), nowEpoch());
      return diff.days;
    case DateRangeFilter.ONE_YEAR:
      diff = getDiffOfTwoDays(getMillisecondsFromCurrentDate({ years: 1 }), nowEpoch());
      return diff.days;
  }
};
</file>

<file path="src/shared/helpers/function.helper.ts">
export const asyncSome = async <T>(arr: T[], predicate: (e: T) => Promise<boolean>): Promise<boolean> => {
  for (const e of arr) {
    if (await predicate(e)) return true;
  }

  return false;
};
</file>

<file path="src/shared/helpers/pagination.helper.ts">
export class QueryPagingHelper {
  static queryPaging({ pageSize, pageNumber }: { pageSize?: number; pageNumber?: number }): {
    take?: number;
    skip?: number;
  } {
    if (!pageNumber || !pageSize) return {};
    return {
      skip: (pageNumber - 1) * pageSize,
      take: pageSize,
    };
  }
}
</file>

<file path="src/shared/helpers/path.helper.ts">
import { resolve } from 'path';

export const resolvePathFromRoot = (...paths: string[]): string => {
  return resolve(process.cwd(), ...paths);
};
</file>

<file path="src/shared/helpers/prisma.helper.ts">
import { isNil } from 'lodash';

export const removeRelation = () => ({ disconnect: true });
export const connectRelation = (value: number) => (isNil(value) ? undefined : { connect: { id: value } });
</file>

<file path="src/shared/helpers/query.helper.ts">
import { SortOrder } from '../enums/query.enum';

export const defaultSortDesc: Record<string, SortOrder> = {
  createdAt: SortOrder.DESC,
};

export const defaultSortAsc: Record<string, SortOrder> = {
  createdAt: SortOrder.ASC,
};
</file>

<file path="src/shared/helpers/response.helper.ts">
import { ActionFailedException } from '../exceptions/action-failed.exception';
import { Result as ResultType } from '../generics/base.response';

export const Result = Object.freeze({
  Success: <T, E>(data: T): ResultType<T, E> => ({ success: true, data }),
  Failure: <T, E>(error: E): ResultType<T, E> => ({ success: false, error }),
});

export const makeResult = async <T>(execution: () => Promise<T>): Promise<ResultType<T, ActionFailedException>> => {
  try {
    return Result.Success(await execution());
  } catch (error) {
    if (error instanceof ActionFailedException) {
      return Result.Failure<T, ActionFailedException>(error);
    }
    throw error;
  }
};
</file>

<file path="src/shared/messages/error-messages.ts">
export enum AccountErrorMessages {
  MSG01 = 'Account not found',
  MSG02 = 'Email existed',
  MSG03 = 'Phone number existed',
  MSG04 = 'Current password is incorrect',
}

export enum MentorErrorMessages {
  MSG01 = 'Please end the current interview before update result of mentor',
  MSG02 = 'This account is not belong to this mentor',
  MSG03 = 'Profile achievement not found',
  MSG04 = 'Mentor not found',
}
export enum CategoryErrorMessages {
  MSG01 = "Category level can't exceed 2",
  MSG02 = "Category root level can't be recommended",
  MSG03 = 'Duplicate category ordinal',
  MSG04 = 'Cannot delete parent category with children',
  MSG05 = 'Some categories not found',
}

export enum AudioCallErrorMessages {
  MSG01 = 'Call is invalid',
  MSG02 = 'Account don not have permission to start call',
  MSG03 = 'Account don not have permission to end call',
  MSG04 = 'Call was finished or cancelled',
  MSG05 = 'Account is in the other call',
  MSG06 = 'Account not included in the call or joined call',
  MSG07 = 'Subscription is still active',
  MSG08 = 'Account has been already in the call',
}

export enum CourseErrorMessages {
  MSG01 = 'Course not found',
  MSG02 = 'Invalid course status to update',
}

export enum SubscriptionErrorMessages {}
</file>

<file path="src/shared/parsers/common.parser.ts">
import { Decimal } from '@prisma/client/runtime/library';
import { IsArray } from 'class-validator';
import { isNil, omitBy } from 'lodash';
import { Nil } from '../generics/type.helper';
import { isBlank } from '../validators/query.validator';
import { notEmptyOrNull, orNull } from './io.parser';

export const parseEpoch = (value: Nil<bigint>) => orNull(value && String(value));
// export const parseSearchString = (value?: string) => value && value.trim().split(' ').join(' & ');
export const parsePrismaSearch = (key: string, value?: string) => {
  return {
    OR: [
      // notEmptyOrNull(leanObject({ [key]: { search: parseSearchString(value) } })),
      notEmptyOrNull(leanObject(value ? { [key]: { contains: value, mode: 'insensitive' } } : undefined)),
    ].filter((v) => !!v),
  };
};

export function leanObject(myObject: any) {
  if (typeof myObject !== 'object' || IsArray(myObject)) return myObject;
  const returnObject = {};
  for (const key2 of Object.keys(myObject)) {
    const afterClean = leanObject(myObject[key2]);
    returnObject[key2] = isBlank(afterClean) ? null : afterClean;
  }

  return omitBy(returnObject, isNil);
}

export const parseDecimalNumber = (value?: number | string | Decimal, fixed = 2): number => {
  if (isNil(value)) return 0;
  const roundedValue = parseFloat(Number(value).toFixed(fixed));
  return isNaN(roundedValue) ? 0 : roundedValue;
};
</file>

<file path="src/shared/parsers/datetime.parse.ts">
import dayjs, { Dayjs } from 'dayjs';
import customParseFormat from 'dayjs/plugin/customParseFormat';
import duration from 'dayjs/plugin/duration';
import relativeTime from 'dayjs/plugin/relativeTime';
import timezone from 'dayjs/plugin/timezone';
import uct from 'dayjs/plugin/utc';
import { DATE_FORMAT } from '../constants/date.constant';
import { Nil } from '../generics/type.helper';
import { orNullWithCondition } from './io.parser';

dayjs.extend(customParseFormat);
dayjs.extend(relativeTime);
dayjs.extend(duration);
dayjs.extend(uct);
dayjs.extend(timezone);

dayjs.tz.setDefault('Asia/Ho_Chi_Minh');

export const parseDatetimeISO8601 = (date: Nil<string>, defaultValue = undefined) => {
  const dateAfterParse = parseDateMonthYear(date, 'start');
  return !dateAfterParse ? defaultValue : dayjs(dateAfterParse).format(DATE_FORMAT.DATE_TIME_SECOND.ISO8601);
};

export const parseAndAddMinutes = (datetimeStr: Nil<string>, minutesToAdd: number = 0, format?: string) => {
  const formatOrDefault = format ? format : DATE_FORMAT.DATE_TIME_SECOND.ISO8601;
  // Parse the datetime string into a dayjs object
  const parsedDatetime = datetimeStr ? dayjs(datetimeStr, formatOrDefault).tz() : dayjs().tz();

  // Add the specified number of minutes
  const updatedDatetime = parsedDatetime.add(minutesToAdd, 'minute');

  // Format it back to the original format
  return updatedDatetime.format(formatOrDefault);
};

export const parsePrismaDate = (date: Nil<string>) => (date ? parseDatetimeISO8601(date) + 'Z' : date);

export const parseDateToEpoch = (date: Nil<Date | string>) => (date ? dayjs(date).valueOf() : date);

export const parseQueryDate = (date: Nil<Dayjs>, defaultValue: any = null) =>
  date ? date.format(DATE_FORMAT.DATE.HYPHEN) : defaultValue;

const parseApplyMonth = (month: number) => String(month).padStart(2, '0');

export const parseDateMonthYear = (date: Nil<string>, position: 'start' | 'end') => {
  const parsedDate = date ? fromDateMonthYear(date.split('/')[0], date.split('/')[1], date.split('/')[2])(position) : undefined;

  return parsedDate;
};

export const parsePadDate = (value: string | number) => String(value).padStart(2, '0');

export const fromDateMonthYear =
  (date: string | number, month: number | string, year: number | string) => (position: 'start' | 'end') => {
    const dateAfterParse = dayjs(`${year}-${parseApplyMonth(+month)}-${parsePadDate(date)}T00:00:00.000Z`).utc();
    if (position === 'start') return dateAfterParse.startOf('date');
    else return dateAfterParse.endOf('date');
  };

export const fromDateTimeMonthYear = (
  time: string | number,
  date: string | number,
  month: number | string,
  year: number | string,
) => {
  const dateAfterParse = dayjs(`${year}-${parseApplyMonth(+month)}-${parsePadDate(date)}T${parsePadDate(time)}:00.000Z`).utc();
  return dateAfterParse;
};

//parse date time in this format DD/MM/YY HH:MM:SS to Epoch dont use dayjs
export const parseDateTimeRequestToEpoch = (date: Nil<string>) => {
  if (!date) return undefined;
  const [day, month, year, hour, minute, second] = date.split(/[\/ :]/).map((value) => parseInt(value));
  const dateAfterParse = new Date(year, month - 1, day, hour, minute, second);
  return dateAfterParse.getTime();
};

export const parseDateTimeToEpochV2 = (date: Nil<string>) => {
  if (!date) return undefined;
  //2024-12-07T23:00:00.000Z
  const [year, month, day, hour, minute, second] = date.split(/[-T:.]/).map((value) => parseInt(value));

  const dateAfterParse = new Date(year, month - 1, day, hour, minute, second);
  return dateAfterParse.getTime();
};

export const checkDateIsBeforeNow = (date: string) => {
  const now = dayjs().tz().valueOf();
  const epoch = dayjs(date).tz().valueOf();

  return epoch < now;
};

export const parsePrismaDateToEpoch = (date: Date | string) => orNullWithCondition(!!date, dayjs(date).valueOf().toString());

export const parseDateTimeNowFormat = (format: string) => dayjs().format(format);

export const parseHourMinFromString = (hourMin: string) => dayjs(`2021-01-01T${hourMin}`).tz().format('HH:mm');

export const parseEpochToDate = (epoch: Nil<number>) => {
  if (!epoch) return undefined;
  return dayjs(epoch).tz().format(DATE_FORMAT.DATE_TIME_SECOND.HYPHEN_V1);
};

export const parseDateToHyphen = (date: Nil<string>) => {
  if (!date) return undefined;
  const [day, month, year] = date.split('/').map((value) => parseInt(value));

  return dayjs(`${year}-${month}-${day}`).format(DATE_FORMAT.DATE.HYPHEN);
};

//Get MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY
export const getDayOfWeek = (date: string) => dayjs(date).day();

export const getMillisecondsFromCurrentDate = ({
  days = 0,
  months = 0,
  years = 0,
  fromBeginning = false,
  fromEnding = false,
}: {
  days?: number;
  months?: number;
  years?: number;
  fromBeginning?: boolean;
  fromEnding?: boolean;
}) => {
  const date = new Date();
  date.setDate(date.getDate() - days);
  date.setMonth(date.getMonth() - months);
  date.setFullYear(date.getFullYear() - years);
  if (fromBeginning) date.setHours(0, 0, 0, 0);
  if (fromEnding) date.setHours(23, 59, 59, 999);
  return date.valueOf();
};

export const getDiffOfTwoDays = (startDay: string | number | Date, endDay: string | number | Date) => {
  const from = dayjs(startDay).tz();
  const end = dayjs(endDay).tz();

  const duration = dayjs.duration(end.diff(from));

  const years = Math.floor(duration.asYears());
  const months = Math.floor(duration.asMonths());
  const days = Math.floor(duration.asDays());
  const hours = Math.floor(duration.asHours());
  const minutes = Math.floor(duration.asMinutes());
  const seconds = Math.floor(duration.asSeconds());

  return { years, months, days, hours, minutes, seconds };
};
</file>

<file path="src/shared/parsers/io.parser.ts">
import { isEmpty, isNil } from 'lodash';
import { Nil } from '../generics/type.helper';

export const orEmptyString = (value?: any) => value || '';
export const orUndefined = (value?: any) => value || undefined;
export const orNull = (value?: any) => value || null;
export const orFalse = (value?: any) => value || false;
export const orDefault = (value?: any, defaultValue: any = null) => (isNil(value) ? defaultValue : value);
export const safeString = (value?: string | number | null, defaultValue = '') => (!isNil(value) ? `${value}` : defaultValue);
export const stringOrUndefined = (value: string | number | null | undefined | boolean) =>
  !isNil(value) ? `${value}` : undefined;
export const notEmptyOrNull = (value?: any) => (isEmpty(value) ? null : value);
export const stringOrNull = (value?: string | number | null) => (value ? `${value}` : null);
export const numberOrNull = (value?: Nil<string | number>) =>
  !isNil(value) ? (typeof value === 'string' ? parseInt(value) : value) : null;
export const numberOrUndefined = (value?: Nil<string | number>) =>
  !isNil(value) ? (typeof value === 'string' ? parseInt(value) : value) : undefined;
export const numberOrZero = (value?: Nil<string | number>) => (!value ? 0 : typeof value === 'string' ? parseInt(value) : value);
export const booleanToNumber = (value: boolean) => (value ? 1 : 0);
export const parseImage = (url: Nil<string>) => url || 'https://www.sikkimexpress.com/assets/frontend/images/no-image.png';
export const formatMoney = (money: number) => new Intl.NumberFormat('en-EN').format(money);
export const formatPhone = (phoneNumber?: string | null) => {
  if (!phoneNumber) return '';
  const cleaned = phoneNumber.replace(/\D/g, ''); // Remove any non-numeric characters from the input string
  const pattern = /^(.{3})(.{4})(.*)$/; // Define the format pattern
  const formatted = cleaned.replace(pattern, '$1-$2-$3'); // Apply the pattern and format the phone number accordingly
  return formatted;
};

export function deepFreeze<T>(object: T): T {
  Object.keys(object).forEach((prop) => {
    if (typeof object[prop] === 'object' && !Object.isFrozen(object[prop])) deepFreeze(object[prop]);
  });
  return Object.freeze(object);
}

export const orUndefinedWithCondition = (condition?: boolean, value?: any) => (condition ? orUndefined(value) : undefined);
export const orNullWithCondition = (condition?: boolean, value?: any) => (condition ? orNull(value) : null);

export const parseRoomChatId = (roomId: number) => {
  return `room_${roomId}`;
};
</file>

<file path="src/shared/request-validator/account.validator.ts">
import { IsEmail, IsLowercase, IsNotEmpty, IsNumberString, IsString, Length, Matches, MaxLength } from 'class-validator';
import { AUTH_CONSTANT } from '../constants/auth.constant';

export function PhoneNumberValidator() {
  return function (object: object, propertyName: string) {
    IsNumberString()(object, propertyName);
    Length(8, 12)(object, propertyName);
  };
}

export function UsernameValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    Length(1, 20, { message: 'username should be between 1 and 20 characters' })(object, propertyName);
    Matches(/^[a-z][a-z0-9]{0,19}$/, {
      message: 'username should start with a lowercase English letter and can contain lowercase letters and numbers only',
    })(object, propertyName);
    IsLowercase({ message: 'username should be in lowercase' })(object, propertyName);
    IsNotEmpty({ message: 'username is required' })(object, propertyName);
  };
}

export function PasswordValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    Length(6, 20, { message: 'password should be between 6 and 20 characters' })(object, propertyName);
    Matches(/^(?=.*[a-zA-Z])(?=.*[0-9])[a-zA-Z0-9!@#$%^&*()_+{}\[\]:;<>,.?~\\/-]*$/, {
      message: 'password should contain a combination of English letters and numbers with optional special characters',
      each: true,
    })(object, propertyName);
  };
}

export function EmailValidator() {
  return function (object: object, propertyName: string) {
    IsString({ message: 'email must be a string' })(object, propertyName);
    IsEmail()(object, propertyName);
  };
}

export function NameValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    IsNotEmpty()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}

export function OtpValidator() {
  return function (object: object, propertyName: string) {
    IsNumberString()(object, propertyName);
    Length(AUTH_CONSTANT.OTP_CODE_LENGTH)(object, propertyName);
  };
}

export function AddressBaseValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}

export function AddressDetailValidator() {
  return function (object: object, propertyName: string) {
    IsString()(object, propertyName);
    MaxLength(255)(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/array-not-duplicated.request-validator.ts">
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';
import { uniq } from 'lodash';

export function ArrayNotDuplicated<T>(classType: T | (new () => T), field?: keyof T, validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'ArrayNotDuplicated',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [classType, field],
      options: validationOptions,
      validator: {
        validate(value: any[], args: ValidationArguments) {
          if (!Array.isArray(value) || !value.length) return true;
          const [type, field] = args.constraints;

          if (typeof type === 'function') {
            // Handle class type
            if (field) {
              const fieldValues = value.map((item) => item[field]);
              return uniq(fieldValues).length === fieldValues.length;
            }
            return uniq(value).length === value.length;
          } else if (typeof type === 'object') {
            // Handle enum or object type
            if (field && !Object.keys(type).includes(field as string)) {
              return false;
            }
            if (field) {
              const fieldValues = value.map((item) => item[field]);
              return uniq(fieldValues).length === fieldValues.length;
            }
            return uniq(value).length === value.length;
          }
          return false;
        },
        defaultMessage(args: ValidationArguments) {
          return `${args.property} must not contain duplicated items`;
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/boolean.request-validator.ts">
import { Transform } from 'class-transformer';
import { IsBoolean } from 'class-validator';

export function BooleanValidator() {
  return function (object: object, propertyName: string) {
    IsBoolean()(object, propertyName);
    Transform(({ value }) => value && Boolean(value.toString() === 'true'))(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/date-time.request.validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function DateTimeValidator(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'DateTimeValidator',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be in the format DD/MM/YYYY HH:MM:SS`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[1-9]|[12]\d|3[01])\/(0[1-9]|1[0-2])\/\d{4} (0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/hour-min-format.validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function HourMinValidator(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'HourMinValidator',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be in the format HH:MM`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/id.validator.ts">
import { IsNumber } from 'class-validator';

export function IdValidator() {
  return function (object: object, propertyName: string) {
    IsNumber()(object, propertyName);
  };
}
</file>

<file path="src/shared/request-validator/month-year-compare.request-validator.ts">
import { ValidationArguments, ValidationOptions, registerDecorator } from 'class-validator';
import { parseDateMonthYear } from '../parsers/datetime.parse';

export function DateMonthYearCompare(
  validationOptions?: ValidationOptions & {
    startField: string;
  },
) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'DateMonthYearCompare',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: any, args: ValidationArguments) {
          const endDate = value && parseDateMonthYear(value, 'end');
          const startStringDate = (args.object as any)[validationOptions.startField];
          const startDate = startStringDate && parseDateMonthYear(startStringDate, 'start');
          if (!endDate || !startDate) return true;
          return startDate.valueOf() < endDate.valueOf();
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        defaultMessage(validationArguments?: ValidationArguments) {
          return (validationOptions?.message as string) || `${validationOptions.startField} must less than ${propertyName}`;
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/only-date.request-validator.ts">
import { registerDecorator, ValidationOptions } from 'class-validator';

export function OnlyDate(validationOptions?: ValidationOptions) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'OnlyDate',
      target: object.constructor,
      propertyName: propertyName,
      constraints: [],
      options: {
        message: `${propertyName} must be date format eg: 30/10/2020`,
        ...validationOptions,
      },
      validator: {
        validate(value: any) {
          const regex = /^(0[1-9]|[12]\d|3[01])\/(0[1-9]|1[0-2])\/[12]\d{3}$/;
          return typeof value === 'string' && regex.test(value);
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/query-array.validate.ts">
import { registerDecorator, ValidationArguments, ValidationOptions } from 'class-validator';
import { isNil, isNull, isUndefined } from 'lodash';

export function QueryArrayValidate(
  validationOptions?: ValidationOptions & {
    fieldType: 'number' | 'string';
    minSize?: number;
    maxSize?: number;
  },
) {
  return function (object: object, propertyName: string) {
    registerDecorator({
      name: 'QueryArrayValidate',
      target: object.constructor,
      propertyName: propertyName,
      options: validationOptions,
      validator: {
        validate(value: string[] | number[], args: ValidationArguments) {
          if (isUndefined(value)) return true;
          if (isNull(value)) return false;
          if (!isNil(validationOptions.minSize) && value.length < validationOptions.minSize) return false;
          if (!isNil(validationOptions.maxSize) && value.length > validationOptions.maxSize) return false;
          return true;
        },
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        defaultMessage(validationArguments?: ValidationArguments) {
          return (
            (validationOptions?.message as string) ||
            `${validationArguments.property} must be array format, eg: [1,2,3] or [name_1, name_2]`
          );
        },
      },
    });
  };
}
</file>

<file path="src/shared/request-validator/query-array.validator.ts">
import { Transform } from 'class-transformer';
import { QueryArrayValidate } from './query-array.validate';

export function QueryArray(options: { fieldType: 'number' | 'string'; minSize?: number; maxSize?: number }) {
  return function (object: object, propertyName: string) {
    QueryArrayValidate(options)(object, propertyName);
    Transform(({ value }) => {
      if (!value) return undefined;
      const numberRegex = /^\[\s*\d+(\s*,\s*\d+)*\s*\]$/;
      const stringRegex = /^\[\s*\w+(\s*,\s*\w+)*\s*\]$/;

      // Check if the transformation might have already been applied
      if (Array.isArray(value)) {
        console.log('Transformation previously applied, skipping.');
        return value;
      }

      if (options.fieldType === 'number' && !numberRegex.test(value)) return null;
      else if (options.fieldType === 'string' && !stringRegex.test(value)) return null;
      const param = String(value).replace('[', '').replace(']', '');
      const items = param.split(',').map((v) => v.trim());
      return items.map((i) => {
        return options.fieldType === 'number' ? Number.parseInt(i) : i;
      });
    })(object, propertyName);
  };
}
</file>

<file path="src/shared/types/payload-prisma.ts">
import { Prisma } from '@prisma/client';

export type CourseGetPayload = Prisma.CourseGetPayload<{
  include: {
    Creator: true;
    Category: true;
    Image: true;
    Sections: true;
    MentorSchedules: true;
    _count: { select: { Sections: true; Subscriptions: true } };
  };
}>;

export type CourseSectionGetPayload = Prisma.CourseSectionGetPayload<{
  include: { Course: true; SectionAttachments: true };
}>;
</file>

<file path="src/shared/validators/query.validator.ts">
import { isBoolean, isEmpty, isNumber } from 'lodash';

/*
  isBlank(undefined)
  // => true

  isBlank(null)
  // => true

  isBlank('')
  // => true

  isBlank([])
  // => true

  isBlank({})
  // => true

  isBlank(NaN)
  // => true

  isBlank(0)
  // => false
*/
export function isBlank(value: any) {
  return isEmpty(value) && !isNumber(value) && !isBoolean(value);
}
</file>

<file path="src/app.config.ts">
import { config } from 'dotenv';
config();

export const CREDENTIALS = process.env.CREDENTIALS === 'true';

export const {
  PORT,
  ORIGIN,
  DATABASE_URL,
  NODE_ENV,
  APP_SECRET,
  HOST,
  JWT_SECRET_KEY,
  JWT_ACCESS_TOKEN_EXPIRE_HOURS,
  API_DOMAIN,
  API_VERSION,
  /* CLD CONFIG */
  CLD_API_KEY,
  CLD_API_SECRET,
  CLD_CLOUD_NAME,
  /* GETSTREAM.IO CONFIG */
  GETSTREAM_API_KEY,
  GETSTREAM_API_SECRET,
  GETSTREAM_WEBHOOK_URL,
  /* VNPAY CONFIG*/
  VNP_TMNCODE,
  VNP_HASHSECRET,
  VNP_COMMAND,
  VNPAY_SANDBOX_HOST,
  VNPAY_ENDPOINT,
  VNPAY_RETURN_URL,
  VNPAY_TEST_MODE,
  VNPAY_MODE,
  VNP_VERSION,
  /* FIREBASE */
  FIREBASE_CLOUD_MESSAGE_CERTIFICATION,
  /* EMAIL */
  EMAIL_SERVICE,
  EMAIL_HOST,
  EMAIL_PORT,
  EMAIL_USER,
  EMAIL_PASSWORD,
  EMAIL_FROM,
  EMAIL_VERIFY_URL,
} = process.env;
</file>

<file path="src/app.module.ts">
import { Module } from '@nestjs/common';
import { EventEmitterModule } from '@nestjs/event-emitter';
import { ScheduleModule } from '@nestjs/schedule';
import { ClsModule } from 'nestjs-cls';
import { AccountModule } from './domains/accounts/accounts.module';
import { AudioCallModule } from './domains/audio-call/audio-call.module';
import { AuthModule } from './domains/auth/auth.module';
import { CategoryModule } from './domains/category/category.module';
import { ChatMessageModule } from './domains/chat-message/chat-message.module';
import { CourseModule } from './domains/course/course.module';
import { DashboardModule } from './domains/dashboard/dashboard.module';
import { FeedbackModule } from './domains/feedback/feedback.module';
import { FileModule } from './domains/file/file.module';
import { ImageModule } from './domains/image/image.module';
import { MentorModule } from './domains/mentor/mentor.module';
import { NotificationModule } from './domains/notification/notification.module';
import { PaymentModule } from './domains/payment/payment.module';
import { ReportModule } from './domains/report/report.module';
import { StudentModule } from './domains/student/student.module';
import { SubscriptionModule } from './domains/subscription/subscription.module';
import { UtilityModule } from './domains/utility/utility.module';
import { CommonModule } from './services/common.module';
import { VnpayModule } from './services/payment-gateway/vn-pay/vnpay.module';

@Module({
  imports: [
    // Register the ClsModule,
    ScheduleModule.forRoot(),
    ClsModule.forRoot({
      global: true,
      middleware: {
        // automatically mount the
        // ClsMiddleware for all routes
        mount: true,
        // and use the setup method to
        // provide default store values.
        setup: (cls, req) => {
          cls.set('userId', req.headers['x-user-id']);
        },
      },
    }),
    EventEmitterModule.forRoot({
      wildcard: false,
      delimiter: '.',
      newListener: false,
      removeListener: false,
      maxListeners: 10,
      verboseMemoryLeak: false,
      ignoreErrors: false,
    }),
    CommonModule,
    UtilityModule,
    FileModule,
    ImageModule,
    /* API Service */
    VnpayModule,
    CategoryModule,
    AccountModule,
    AuthModule,
    CourseModule,
    StudentModule,
    MentorModule,
    AudioCallModule,
    PaymentModule,
    SubscriptionModule,
    ChatMessageModule,
    NotificationModule,
    FeedbackModule,
    DashboardModule,
    ReportModule,
  ],
})
export class AppModule {}
</file>

<file path="src/main.ts">
import { Logger } from '@nestjs/common';
import { NestFactory } from '@nestjs/core';
import { NestExpressApplication } from '@nestjs/platform-express';
import bodyParser from 'body-parser';
import chalk from 'chalk';
import compression from 'compression';
import cookieParser from 'cookie-parser';
import { cleanEnv, port, str } from 'envalid';
import helmet from 'helmet';
import morgan from 'morgan';

import { APP_SECRET, CREDENTIALS, HOST, NODE_ENV, ORIGIN, PORT } from './app.config';
import { AppModule } from './app.module';
import { LoggingInterceptor } from './interceptors/logging.interceptor';
import { PrismaExceptionInterceptor } from './interceptors/prisma-exception.interceptor';
import { HttpExceptionMiddleware } from './middlewares/http-exception.middlewave';
import { ValidationCustomPipe } from './pipes/validation-custom.pipe';
import { setupSwagger } from './swagger';

async function bootstrap(): Promise<void> {
  try {
    validateEnv();

    const app = await NestFactory.create<NestExpressApplication>(AppModule, {
      logger: ['error', 'warn', 'log', 'verbose'],
      cors: {
        origin: ORIGIN,
        credentials: CREDENTIALS,
      },
    });

    Logger.log(` Environment: ${chalk.hex('#33d32e').bold(`${NODE_ENV}`)}`);

    app.use(helmet());
    app.use(compression());
    app.use(morgan('combined'));
    app.use(cookieParser(APP_SECRET));
    app.use(bodyParser.json({ limit: '50mb' }));
    app.use(
      bodyParser.urlencoded({
        limit: '50mb',
        extended: true,
        parameterLimit: 50000,
      }),
    );
    // app.use(
    //   rateLimit({
    //     windowMs: 1000 * 60 * 60,
    //     max: 1000, // 1000 requests per windowMs
    //     message: '  Too many request created from this IP, please try again after an hour',
    //   }),
    // );

    app.useGlobalInterceptors(new LoggingInterceptor());
    app.useGlobalInterceptors(new PrismaExceptionInterceptor());
    app.useGlobalPipes(ValidationCustomPipe.compactVersion());
    app.useGlobalFilters(new HttpExceptionMiddleware());
    app.setGlobalPrefix('api/v1');

    // Swagger
    setupSwagger(app);

    await app.listen(PORT || 3000);

    if (NODE_ENV !== 'production') {
      Logger.log(` Server ready at http://${chalk.hex('#e5ff00').bold(`${HOST}`)}:${chalk.hex('#ff6e26').bold(`${PORT}`)}`);
    } else {
      Logger.log(` Server is listening on port ${chalk.hex('#87e8de').bold(`${PORT}`)}`);
    }
    Logger.log(
      ` Swagger ready at http://${chalk.hex('#e5ff00').bold(`${HOST}`)}:${chalk.hex('#ff6e26').bold(`${PORT}`)}/documentation`,
    );
  } catch (error) {
    Logger.error(`  Error starting server, ${error}`);
    process.exit();
  }
}

function validateEnv() {
  cleanEnv(process.env, {
    DATABASE_URL: str(),
    PORT: port(),
  });
}

bootstrap().catch((e) => {
  Logger.error(`  Error starting server, ${e}`);
  throw e;
});
</file>

<file path="src/swagger.ts">
import { type INestApplication } from '@nestjs/common';
import { DocumentBuilder, SwaggerModule } from '@nestjs/swagger';

import { API_VERSION } from './app.config';

export function setupSwagger(app: INestApplication): void {
  const documentBuilder = new DocumentBuilder().setTitle('API').setDescription(`
### REST

Routes is following REST standard (Richardson level 3)

<details><summary>Detailed specification</summary>
<p>

**List:**
  - \`GET /<resources>/\`
    - Get the list of **<resources>** as admin
  - \`GET /user/<user_id>/<resources>/\`
    - Get the list of **<resources>** for a given **<user_id>**
    - Output a **403** if logged user is not **<user_id>**

**Detail:**
  - \`GET /<resources>/<resource_id>\`
    - Get the detail for **<resources>** of id **<resource_id>**
    - Output a **404** if not found
  - \`GET /user/<user_id>/<resources>/<resource_id>\`
    - Get the list of **<resources>** for a given **user_id**
    - Output a **404** if not found
    - Output a **403** if:
      - Logged user is not **<user_id>**
      - The **<user_id>** have no access to **<resource_id>**

**Creation / Edition / Replacement / Suppression:**
  - \`<METHOD>\` is:
    - **POST** for creation
    - **PATCH** for update (one or more fields)
    - **PUT** for replacement (all fields, not used)
    - **DELETE** for suppression (all fields, not used)
  - \`<METHOD> /<resources>/<resource_id>\`
    - Create **<resources>** with id **<resource_id>** as admin
    - Output a **400** if **<resource_id>** conflicts with existing **<resources>**
  - \`<METHOD> /user/<user_id>/<resources>/<resource_id>\`
    - Create **<resources>** with id **<resource_id>** as a given **user_id**
    - Output a **409** if **<resource_id>** conflicts with existing **<resources>**
    - Output a **403** if:
      - Logged user is not **<user_id>**
      - The **<user_id>** have no access to **<resource_id>**
</p>
</details>
    `);
  // .addBearerAuth();

  if (API_VERSION) {
    documentBuilder.setVersion(process.env.API_VERSION);
  }

  const document = SwaggerModule.createDocument(app, documentBuilder.build());
  SwaggerModule.setup('documentation', app, document, {
    swaggerOptions: {
      persistAuthorization: false,
    },
  });
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
