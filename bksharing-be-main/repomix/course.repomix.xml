This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T17:56:27.855Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  domains/
    course/
      admin/
        request/
          course-approve.request.ts
        response/
          course-admin-detail.response.ts
          course-admin-list.response.ts
        course-admin.controller.spec.ts
        course-admin.controller.ts
        course-admin.module.ts
        course-admin.service.spec.ts
        course-admin.service.ts
      client/
        request/
          course-client-create.request.ts
          course-client-update.request.ts
          course-section-client-update.request.ts
        response/
          course-client-detail.response.ts
          course-client-list.response.ts
          course-section-client.response.ts
        course-client.controller.spec.ts
        course-client.controller.ts
        course-client.module.ts
        course-client.service.spec.ts
        course-client.service.ts
      dto/
        course-section.dto.ts
      factory/
        list/
          course-admin-list.request.ts
          course-client-list.request.ts
        course-list.factory.ts
      shared/
        helper/
          course-detail-query.helper.ts
          course-list-query.helper.ts
          course-section.helper.ts
          course-update-query.helper.ts
        course-base-list.request.ts
        enums.ts
        types.ts
      course.module.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/domains/course/admin/request/course-approve.request.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class CourseApproveREQ {
  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/course/admin/response/course-admin-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseAdminDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  image: ImageRESP;

  static fromEntity(course: CourseGetPayload, sections: CourseSectionDTO[], image: ImageRESP): CourseAdminDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/admin/response/course-admin-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';

export class CourseAdminListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: {
    id: number;
    name: string;
  };
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseAdminListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: {
        id: e.Creator.id,
        name: e.Creator.name,
      },
    };
  }
}
</file>

<file path="src/domains/course/admin/course-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminController', () => {
  let controller: CourseAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseAdminController],
      providers: [CourseAdminService],
    }).compile();

    controller = module.get<CourseAdminController>(CourseAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseAdminService } from './course-admin.service';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminDetailRESP } from './response/course-admin-detail.response';

@Controller('admin/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class CourseAdminController {
  constructor(private readonly courseAdminService: CourseAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseAdminListREQ) {
    const { dtos, count } = await this.courseAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { course, sectionDtos, image } = await this.courseAdminService.detail(id);

    const response = CourseAdminDetailRESP.fromEntity(course, sectionDtos, image);
    return BaseResponse.of(response);
  }

  @Patch(':id/approve')
  async approve(@Param('id', ParseIntPipe) id: number, @Body() body: CourseApproveREQ) {
    const course = await this.courseAdminService.approve(id, body);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/admin/course-admin.module.ts">
import { Module } from '@nestjs/common';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminController } from './course-admin.controller';
import { CourseAdminService } from './course-admin.service';

@Module({
  controllers: [CourseAdminController],
  providers: [CourseAdminService, CourseListFactory],
})
export class CourseAdminModule {}
</file>

<file path="src/domains/course/admin/course-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseAdminService } from './course-admin.service';

describe('CourseAdminService', () => {
  let service: CourseAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseAdminService],
    }).compile();

    service = module.get<CourseAdminService>(CourseAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/admin/course-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { CourseStatus, NotificationRelationType, NotificationType } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseErrorMessages } from 'src/shared/messages/error-messages';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseAdminListREQ } from '../factory/list/course-admin-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseApproveREQ } from './request/course-approve.request';
import { CourseAdminListRESP } from './response/course-admin-list.response';

@Injectable()
export class CourseAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly courseListFactory: CourseListFactory,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  async list(user: AuthUserDTO, query: CourseAdminListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.ADMIN, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
    const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
          _avg: { courseRating: true },
        });

        return CourseAdminListRESP.fromEntity(course, thumbnail, {
          noOfFeedbacks,
          noOfSubscriptions: course._count.Subscriptions,
          rateOfCourse: ratingOfCourse._avg.courseRating,
        });
      }),
    );

    return { dtos, count };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    const image = await this.imageService.getImageOriginal(course.imageId);

    return { course, sectionDtos, image };
  }

  async approve(id: number, body: CourseApproveREQ) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    if (course.status !== CourseStatus.PENDING) {
      throw new ActionFailedException(ActionFailed.COURSE_STATUS_CANNOT_UPDATE, CourseErrorMessages.MSG02);
    }

    const updatedCourse = await this.transactionHost.tx.course.update({
      where: { id: course.id },
      data: { status: body.isApproved ? CourseStatus.APPROVED : CourseStatus.REJECTED },
      select: { id: true, creatorId: true },
    });

    //Notification: Send notification to course owner
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      updatedCourse.creatorId,
      body.isApproved ? NotificationType.COURSE_APPROVED : NotificationType.COURSE_REJECTED,
    );

    runFunctionWithCondition(!!updatedCourse, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedCourse;
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/client/request/course-client-create.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import {
  ArrayMaxSize,
  ArrayMinSize,
  IsArray,
  IsEnum,
  IsNumber,
  IsOptional,
  IsString,
  Max,
  MaxLength,
  Min,
} from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseClientCreateREQ {
  @NameValidator()
  name: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @IsNumber()
  @Min(1)
  @Max(10)
  totalDuration: number;

  @Min(0)
  @IsNumber()
  price: number;

  @IdValidator()
  categoryId: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @BooleanValidator()
  isPublic: boolean;

  @IsEnum([CourseStatus.DRAFT, CourseStatus.PENDING])
  status: CourseStatus;

  @IsArray()
  @Type(() => String)
  prerequisites: string[];

  @IsArray()
  @Type(() => String)
  @ArrayNotDuplicated(String)
  objectives: string[];

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences: TargetAudience[];

  @IsArray()
  @IsOptional()
  @Type(() => CourseSectionDTO)
  sections?: CourseSectionDTO[] = [];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;

  static toCreateInput(user: AuthUserDTO, body: CourseClientCreateREQ): Prisma.CourseCreateArgs {
    return {
      data: {
        name: body.name,
        status: body.status,
        description: body.description,
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        totalDuration: body.totalDuration,
        price: body.price,
        startDate: parsePrismaDate(body.startDate),
        endDate: parsePrismaDate(body.endDate),
        Creator: connectRelation(user.accountId),
        Category: connectRelation(body.categoryId),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/client/request/course-client-update.request.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class CourseClientUpdateREQ {
  @NameValidator()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description?: string;

  @IsNumber()
  @IsOptional()
  totalDuration?: number;

  @Min(0)
  @IsNumber()
  @IsOptional()
  price?: number;

  @IdValidator()
  @IsOptional()
  categoryId?: number;

  @IdValidator()
  @IsOptional()
  imageId?: number;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsOptional()
  @IsEnum([CourseStatus.PENDING, CourseStatus.STOPPED, CourseStatus.ARCHIVED, CourseStatus.DRAFT])
  status?: CourseStatus;

  @IsNumber()
  @IsOptional()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  litmitOfStudents?: number;

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  prerequisites?: string[];

  @IsArray()
  @Type(() => String)
  @IsOptional()
  @ArrayNotDuplicated(String)
  objectives: string[] = [];

  @IsArray()
  @IsOptional()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @OnlyDate()
  @IsOptional()
  startDate?: string;

  @OnlyDate()
  @IsOptional()
  @DateMonthYearCompare({ startField: 'startDate' })
  endDate?: string;
}
</file>

<file path="src/domains/course/client/request/course-section-client-update.request.ts">
import { PartialType } from '@nestjs/swagger';
import { Type } from 'class-transformer';
import { ArrayMinSize, IsArray, IsOptional } from 'class-validator';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionUpdateDTO extends PartialType(CourseSectionDTO) {}

export class CourseSectionAddREQ extends CourseSectionDTO {}

export class CourseSectionRemoveREQ {
  @IsArray()
  @IsOptional()
  @Type(() => Number)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  removeSectionIds: number[] = [];
}
</file>

<file path="src/domains/course/client/response/course-client-detail.response.ts">
import { CourseStatus, TargetAudience } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../../dto/course-section.dto';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientDetailRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  price: number;
  isPublic: boolean;
  startDate: string;
  endDate: string;
  litmitOfStudents: number;
  category: {
    id: number;
    name: string;
  };
  createdAt: Date;
  objectives: string[];
  targetAudiences: TargetAudience[];
  prerequisites: string[];
  sections: CourseSectionDTO[];
  mentor: CourseMentorDetailRESP;
  image: ImageRESP;

  static fromEntity(
    course: CourseGetPayload,
    sections: CourseSectionDTO[],
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
  ): CourseClientDetailRESP {
    return {
      id: course.id,
      name: course.name,
      status: course.status,
      description: course.description,
      totalDuration: course.totalDuration,
      price: parseDecimalNumber(course.price),
      isPublic: course.isPublic,
      startDate: parsePrismaDateToEpoch(course.startDate),
      endDate: parsePrismaDateToEpoch(course.endDate),
      objectives: course.objectives,
      targetAudiences: course.targetAudiences,
      prerequisites: course.prerequisites,
      litmitOfStudents: course.litmitOfStudents,
      sections: sections,
      image: orNull(image),
      category: {
        id: course.Category?.id,
        name: course.Category?.name,
      },
      mentor: mentor,
      createdAt: parseEpoch(course.createdAt),
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-client-list.response.ts">
import { CourseStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseGetPayload } from 'src/shared/types/payload-prisma';
import { CourseMentorDetailRESP } from '../../shared/types';

export class CourseClientListRESP {
  id: number;
  name: string;
  status: CourseStatus;
  description: string;
  totalDuration: number;
  startDate: string;
  endDate: string;
  objectives: string[];
  targetAudiences: string[];
  prerequisite: string[];
  countOfSections: number;
  price: number;
  createdAt: string;
  noOfSubscriptions?: number; // paid subscriptions
  noOfFeedbacks?: number;
  rateOfCourse?: number;
  category: {
    id: number;
    name: string;
    slug: string;
  };
  mentor: CourseMentorDetailRESP;
  image?: ImageRESP;

  static fromEntity(
    e: CourseGetPayload,
    image: ImageRESP,
    mentor: CourseMentorDetailRESP,
    data?: {
      noOfSubscriptions?: number;
      noOfFeedbacks?: number;
      rateOfCourse?: number;
    },
  ): CourseClientListRESP {
    return {
      id: e.id,
      name: e.name,
      status: e.status,
      description: e.description,
      price: parseDecimalNumber(e.price),
      totalDuration: e.totalDuration,
      startDate: String(parseDateToEpoch(e.startDate)),
      endDate: orUndefinedWithCondition(!!e.endDate, String(parseDateToEpoch(e.endDate))),
      objectives: e.objectives,
      targetAudiences: e.targetAudiences,
      prerequisite: e.prerequisites,
      countOfSections: e._count.Sections,
      image: image,
      createdAt: parseEpoch(e.createdAt),
      noOfSubscriptions: data?.noOfSubscriptions ?? 0,
      noOfFeedbacks: data?.noOfFeedbacks ?? 0,
      rateOfCourse: data?.rateOfCourse ?? 0,
      category: {
        id: e.Category.id,
        name: e.Category.name,
        slug: e.Category.slug,
      },
      mentor: mentor,
    };
  }
}
</file>

<file path="src/domains/course/client/response/course-section-client.response.ts">
import { FileRESP } from 'src/domains/file/response/file.response';
import { orNull } from 'src/shared/parsers/io.parser';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionClientRESP {
  id: number;
  title: string;
  description: string;
  isPublic: boolean;
  files: FileRESP[];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionClientRESP {
    return {
      id: e.id,
      title: e.title,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/client/course-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

describe('CourseClientController', () => {
  let controller: CourseClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [CourseClientController],
      providers: [CourseClientService],
    }).compile();

    controller = module.get<CourseClientController>(CourseClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthService } from 'src/domains/auth/auth.service';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseClientService } from './course-client.service';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionUpdateDTO } from './request/course-section-client-update.request';

@Controller('client/courses')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR, AccountType.STUDENT)
export class CourseClientController {
  constructor(
    private readonly courseClientService: CourseClientService,
    private readonly authService: AuthService,
  ) {}

  @Get()
  @Public()
  async list(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const { dtos, count } = await this.courseClientService.list(query);

    return PaginationResponse.ofWithTotal(dtos, count);
  }

  @Get('students')
  @Roles(AccountType.STUDENT)
  async getAllCoursesLearnedByStudent(@Req() req: AuthRequestDTO, @Query() query: CourseClientListREQ) {
    const dtos = await this.courseClientService.listCoursesLearnedByAccountId(req.user, query);

    return BaseResponse.of(dtos);
  }

  @Post()
  @Roles(AccountType.MENTOR)
  async create(@Req() req: AuthRequestDTO, @Body() body: CourseClientCreateREQ) {
    const course = await this.courseClientService.create(req.user, body);

    return BaseResponse.of(course);
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const jwtToken = req.headers['authorization']?.slice(7);
    const accountId = this.authService.getAccountIdFromToken(jwtToken);

    const course = await this.courseClientService.getPublicCourseDetail(id, accountId);

    return BaseResponse.of(course);
  }

  @Patch(':id')
  @Roles(AccountType.MENTOR)
  async update(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number, @Body() body: CourseClientUpdateREQ) {
    const course = await this.courseClientService.update(id, req.user, body);

    return BaseResponse.of(course);
  }

  @Delete(':id')
  @Roles(AccountType.MENTOR)
  async delete(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.courseClientService.delete(id, req.user);

    return BaseResponse.ok();
  }

  @Post(':courseId/sections')
  @Roles(AccountType.MENTOR)
  async createSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: CourseSectionDTO,
  ) {
    const course = await this.courseClientService.createSectionByCourseId(courseId, body, req.user);

    return BaseResponse.of(course);
  }

  @Patch(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async updateSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
    @Body() body: CourseSectionUpdateDTO,
  ) {
    const course = await this.courseClientService.updateSectionByCourseId(courseId, sectionId, body, req.user);

    return BaseResponse.of(course);
  }

  @Delete(':courseId/sections/:sectionId')
  @Roles(AccountType.MENTOR)
  async deleteSection(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Param('sectionId', ParseIntPipe) sectionId: number,
  ) {
    const course = await this.courseClientService.deleteSectionByCourseId(courseId, sectionId, req.user);

    return BaseResponse.of(course);
  }
}
</file>

<file path="src/domains/course/client/course-client.module.ts">
import { Module } from '@nestjs/common';
import { AuthModule } from 'src/domains/auth/auth.module';
import { CommonModule } from 'src/services/common.module';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientController } from './course-client.controller';
import { CourseClientService } from './course-client.service';

@Module({
  imports: [CommonModule, AuthModule],
  controllers: [CourseClientController],
  providers: [CourseClientService, CourseListFactory],
  exports: [CourseClientService],
})
export class CourseClientModule {}
</file>

<file path="src/domains/course/client/course-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { CourseClientService } from './course-client.service';

describe('CourseClientService', () => {
  let service: CourseClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [CourseClientService],
    }).compile();

    service = module.get<CourseClientService>(CourseClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/course/client/course-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AccountType,
  CourseStatus,
  MentorStatus,
  NotificationRelationType,
  NotificationType,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { COURSE_PUBLIC_STATUS } from 'src/shared/constants/course.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { CourseGetPayload, CourseSectionGetPayload } from 'src/shared/types/payload-prisma';
import { CourseSectionDTO } from '../dto/course-section.dto';
import { CourseListFactory } from '../factory/course-list.factory';
import { CourseClientListREQ } from '../factory/list/course-client-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseDetailQueryHelper } from '../shared/helper/course-detail-query.helper';
import { CourseListQueryHelper } from '../shared/helper/course-list-query.helper';
import { CourseSectionHelper } from '../shared/helper/course-section.helper';
import { CourseUpdateHelper } from '../shared/helper/course-update-query.helper';
import { CourseClientCreateREQ } from './request/course-client-create.request';
import { CourseClientUpdateREQ } from './request/course-client-update.request';
import { CourseSectionAddREQ, CourseSectionUpdateDTO } from './request/course-section-client-update.request';
import { CourseClientDetailRESP } from './response/course-client-detail.response';
import { CourseClientListRESP } from './response/course-client-list.response';

@Injectable()
export class CourseClientService {
  private readonly logger: Logger = new Logger(CourseClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
    private readonly courseListFactory: CourseListFactory,
  ) {}

  async list(query: CourseClientListREQ) {
    query.courseStatus = CourseStatus.APPROVED;
    const courses = await this.transactionHost.tx.course.findMany(CourseListQueryHelper.toFindMany(query));
    const count = await this.transactionHost.tx.course.count({
      where: { ...CourseListQueryHelper.toQueryCondition(query), isPublic: true, status: CourseStatus.APPROVED },
    });

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          { noOfSubscriptions: course._count.Subscriptions, noOfFeedbacks, rateOfCourse: await this.getRateOfCourse(course.id) },
        );
      }),
    );

    return { dtos, count };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async delete(id: number, user: AuthUserDTO) {
    //Check course belong to user
    let course: CourseGetPayload;
    try {
      course = (await this.transactionHost.tx.course.findUniqueOrThrow({
        where: { id: id, creatorId: user.accountId },
        select: {
          id: true,
          Sections: { select: { id: true, ...IS_ACTIVE_NESTED } },
          MentorSchedules: { select: { id: true, ...IS_ACTIVE_NESTED } },
        },
      })) as CourseGetPayload;
    } catch (error) {
      this.logger.error(error);
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    //Check if any subscription is active so throw error
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { courseId: id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
      select: { id: true },
    });

    if (!isEmpty(subscriptions)) throw new ActionFailedException(ActionFailed.COURSE_HAS_ACTIVE_SUBSCRIPTION);

    const sectionIds = await this.transactionHost.tx.courseSection.deleteMany({ where: { courseId: id } });
    if (!isEmpty(sectionIds)) {
      await Promise.all([
        //Delete course sections
        course.Sections.map(async (section) => {
          await this.transactionHost.tx.sectionAttachment.deleteMany({ where: { sectionId: section.id } });
        }),
        //Delete course schedules
        course.MentorSchedules.map(async (schedule) => {
          await this.transactionHost.tx.mentorSchedule.delete({ where: { id: schedule.id } });
        }),
      ]);
    }
    //Delete course
    await this.transactionHost.tx.course.delete({ where: { id } });
  }

  async listCoursesLearnedByAccountId(user: AuthUserDTO, query: CourseClientListREQ) {
    const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
    const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfSubscriptions: course._count.Subscriptions,
            noOfFeedbacks,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  // async getAllCoursesByAccount(user: AuthUserDTO, query: CourseClientListREQ) {
  //   const factory = this.courseListFactory.getClass(CourseListDTOType.CLIENT, query);
  //   const courses = await this.transactionHost.tx.course.findMany(factory.toFindManyByAccount(user, query));
  //   const count = await this.transactionHost.tx.course.count({ where: CourseListQueryHelper.toQueryCondition(query) });

  //   const dtos = await Promise.all(
  //     courses.map(async (course: CourseGetPayload) => {
  //       const thumbnail = await this.imageService.getImageOriginal(course.imageId);
  //       return CourseClientListRESP.fromEntity(course, thumbnail);
  //     }),
  //   );

  //   return { dtos, count };
  // }

  async getPublicCourseDetail(id: number, accountId: number) {
    const { course, sectionDtos } = await this.detail(id);
    const isCoursePublic = COURSE_PUBLIC_STATUS.includes(course.status) && course.isPublic;

    if (!isCoursePublic && course.creatorId !== accountId) {
      throw new ActionFailedException(ActionFailed.COURSE_CANNOT_VIEW_DETAIL);
    }

    //TODO: Check if  course not public but student subcribed

    const image = await this.imageService.getImageOriginal(course.imageId);

    const { mentor, thumbnail } = await this.getMentorByAccountId(course.creatorId);

    return CourseClientDetailRESP.fromEntity(course, sectionDtos, image, {
      id: mentor.id,
      accountId: mentor.accountId,
      name: mentor.Account.name,
      thumbnail: thumbnail,
    });
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);

    return { mentor, thumbnail };
  }

  async detail(id: number) {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow(
      CourseDetailQueryHelper.toFindUnique(id),
    )) as CourseGetPayload;

    const sectionDtos = await Promise.all(
      course.Sections.map(async (section: CourseSectionGetPayload) => {
        const files = await this.transactionHost.tx.sectionAttachment.findMany({
          where: { sectionId: section.id },
          select: { fileId: true },
        });

        const fileIds = files.map((item) => item.fileId);
        await this.fileService.checkAttachmentUploadedOrThrow(fileIds);

        return CourseSectionDTO.fromEntity(section, await this.getAttachmentFiles(fileIds));
      }),
    );

    return { course, sectionDtos };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async update(id: number, user: AuthUserDTO, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update course */
    const updatedCourse = await this.transactionHost.tx.course.update(CourseUpdateHelper.toUpdate(id, body));

    await this.imageService.linkImageToCourse(id, body.imageId);

    /* 3. TODO: Update notification to admin, and student subcribed */

    return updatedCourse;
  }

  async getAllbyCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ) {
    const courses = await this.transactionHost.tx.course.findMany(
      CourseListQueryHelper.toListByCreatorId(creatorId, isOwner, query),
    );

    const dtos = await Promise.all(
      courses.map(async (course: CourseGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(course.imageId);
        const { mentor, thumbnail: mentorAvt } = await this.getMentorByAccountId(course.Creator.id);
        const noOfFeedbacks = await this.transactionHost.tx.feedback.count({
          where: { Subscription: { courseId: course.id, ...IS_ACTIVE_NESTED } },
        });

        return CourseClientListRESP.fromEntity(
          course,
          thumbnail,
          {
            id: mentor.id,
            accountId: mentor.accountId,
            name: mentor.Account.name,
            thumbnail: mentorAvt,
          },
          {
            noOfFeedbacks,
            noOfSubscriptions: course._count.Subscriptions,
            rateOfCourse: await this.getRateOfCourse(course.id),
          },
        );
      }),
    );

    return dtos;
  }

  private async getRateOfCourse(courseId: number) {
    const ratingOfCourse = await this.transactionHost.tx.feedback.aggregate({
      where: { Subscription: { courseId, ...IS_ACTIVE_NESTED } },
      _avg: { courseRating: true },
    });

    return ratingOfCourse._avg.courseRating;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, body: CourseClientCreateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { accountId: user.accountId },
      select: { id: true, status: true },
    });

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    if (body.categoryId) await this.checkExistedCategory(body.categoryId);

    const course = await this.transactionHost.tx.course.create(CourseClientCreateREQ.toCreateInput(user, body));
    await this.imageService.linkImageToCourse(course.id, body.imageId);

    /* create course sections  */
    //TODO: Handle files in each
    for (const section of body.sections) {
      await this.createSection(course.id, section);
    }

    //Notification: send Notification to admin
    const admin = await this.transactionHost.tx.account.findFirst({
      where: { accountType: AccountType.ADMIN },
      select: { id: true },
    });

    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: course.id, type: NotificationRelationType.COURSE },
      admin.id,
      NotificationType.COURSE_CREATED,
    );

    runFunctionWithCondition(!!course, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return course;
  }

  // ==================== METHOD ====================
  private async createSection(courseId: number, section: CourseSectionDTO) {
    if (!courseId) return;

    if (!isEmpty(section.files)) {
      const fileIds = section.files.map((item) => item.fileId);
      await this.checkFiles(fileIds);
    }

    const ordinal = await this.transactionHost.tx.courseSection.aggregate(CourseSectionHelper.toFindMaxOrdinal(courseId));
    const maxOrdinal = ordinal._max.ordinal || 0;

    const courseSection = await this.transactionHost.tx.courseSection.create({
      data: CourseSectionHelper.toCreateInput(courseId, section, maxOrdinal),
      select: { id: true },
    });

    return courseSection;
  }

  private async checkExistedCategory(categoryId: number) {
    const category = await this.transactionHost.tx.category.findFirst({
      where: { id: categoryId },
      select: { id: true, parentCategoryId: true },
    });

    if (!category) throw new ActionFailedException(ActionFailed.CATEGORY_NOT_FOUND);

    return category;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateStatus(id: number, body: CourseClientUpdateREQ) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow(CourseDetailQueryHelper.toFindUnique(id));

    await this.transactionHost.tx.course.update({
      where: { id },
      data: { status: body.status },
    });

    return course.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async createSectionByCourseId(courseId: number, body: CourseSectionAddREQ, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.createSection(courseId, body);

    return { courseId: course.id, sectionId: section.id };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateSectionByCourseId(courseId: number, sectionId: number, body: CourseSectionUpdateDTO, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);

    /* 2. update section */
    const section = await this.transactionHost.tx.courseSection.update({
      where: { id: sectionId, courseId },
      data: CourseSectionHelper.toUpdateInput(body),
      select: { id: true },
    });

    const fileIds = body.files.map((item) => item.fileId);
    await this.updateSectionAttachments(sectionId, fileIds);

    return { courseId: course.id, sectionId: section.id };
  }

  async updateSectionAttachments(sectionId: number, fileIds: number[]) {
    if (isEmpty(fileIds)) return;

    const attachments = await this.transactionHost.tx.sectionAttachment.findMany({
      where: { sectionId },
      select: { fileId: true },
    });

    const existedFileIds = attachments.map((item) => item.fileId);
    const notSectionFileIds = fileIds.filter((id) => !existedFileIds.includes(id));
    if (!isEmpty(notSectionFileIds)) {
      await this.checkFiles(notSectionFileIds);
      await this.transactionHost.tx.sectionAttachment.createMany({
        data: notSectionFileIds.map((fileId) => addCreationTimestamps({ sectionId, fileId })),
      });
    }

    for (const file of existedFileIds) {
      if (!fileIds.includes(file)) {
        const numberOfRecords = await this.transactionHost.tx.$executeRaw`DELETE FROM section_attachments WHERE file_id=${file}`;
        runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.delete(file));
      }
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async deleteSectionByCourseId(courseId: number, sectionId: number, user: AuthUserDTO) {
    const course = await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, creatorId: true, Sections: { where: { id: sectionId } } },
    });

    /* 1. Check course belong to user  */
    await this.checkCourseCreator(user.accountId, course.creatorId);
    const sectionIds = course.Sections.map((section) => section.id);

    if (isEmpty(sectionIds) || !sectionIds.includes(sectionId))
      throw new ActionFailedException(ActionFailed.COURSE_SECTION_NOT_FOUND_IN_COURSE);

    const section = await this.transactionHost.tx.courseSection.findFirst({
      where: { id: sectionId, courseId },
      select: { id: true, SectionAttachments: { select: { fileId: true } } },
    });

    /* 2. delete section attachments */
    const fileIds = section.SectionAttachments.map((item) => item.fileId);

    if (!isEmpty(fileIds)) {
      const numberOfRecords = await this.transactionHost.tx
        .$executeRaw`DELETE FROM section_attachments WHERE section_id=${sectionId}`;

      runFunctionWithCondition(numberOfRecords > 0, async () => await this.fileService.checkAttachmentUploadedOrThrow(fileIds));
    }

    /* 3. delete course sections */
    await this.transactionHost.tx.courseSection.delete({
      where: { id: sectionId, courseId: courseId },
    });

    return { courseId: course.id, sectionId: section.id };
  }

  // async updateTotalDuration(courseId: number) {
  //   const totalDuration = await this.transactionHost.tx.courseSection.aggregate({
  //     where: { courseId, ...IS_ACTIVE_NESTED },
  //     _sum: { duration: true },
  //   });

  //   await this.transactionHost.tx.course.update({
  //     where: { id: courseId },
  //     data: { totalDuration: totalDuration._sum.duration },
  //   });
  // }

  @Transactional(TRANSACTION_TIMEOUT)
  async checkFiles(fileIds: number[]) {
    await this.fileService.checkAttachmentUploadedOrThrow(fileIds);
    // await this.fileService.checkFileLinked(fileIds);

    /* Create and link file */
    await this.fileService.enableUploaded(fileIds);
  }

  async checkCourseCreator(accountId: number, creatorId: number) {
    if (accountId !== creatorId) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
  }

  async getAttachmentFiles(fileIds: number[]): Promise<FileRESP[]> {
    return Promise.all(fileIds.map(async (fileId) => await this.fileService.detail(fileId)));
  }
}
</file>

<file path="src/domains/course/dto/course-section.dto.ts">
import { Type } from 'class-transformer';
import { ArrayMaxSize, IsArray, IsNumber, IsOptional, IsString, MaxLength } from 'class-validator';
import { FileRESP } from 'src/domains/file/response/file.response';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { orNull } from 'src/shared/parsers/io.parser';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { CourseSectionGetPayload } from 'src/shared/types/payload-prisma';

export class CourseSectionAttachmentDTO {
  @IdValidator()
  fileId: number;

  @IsOptional()
  @BooleanValidator()
  isPublic: boolean = false;
}

export class CourseSectionDTO {
  @IdValidator()
  @IsOptional()
  id?: number;

  @NameValidator()
  title: string;

  @IsNumber()
  @IsOptional()
  ordinal?: number;

  @IsString()
  @IsOptional()
  @MaxLength(1000)
  description: string;

  @BooleanValidator()
  isPublic: boolean = false;

  @IsArray()
  @Type(() => CourseSectionAttachmentDTO)
  @IsOptional()
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  files?: CourseSectionAttachmentDTO[] = [];

  static fromEntity(e: CourseSectionGetPayload, files?: FileRESP[]): CourseSectionDTO {
    return {
      id: e.id,
      title: e.title,
      ordinal: e.ordinal,
      description: e.description,
      isPublic: e.isPublic,
      files: orNull(files),
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-admin-list.request.ts">
import { PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseAdminListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseAdminListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: condition,
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        status: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/list/course-client-list.request.ts">
import { AccountStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { CourseBaseListREQ } from '../../shared/course-base-list.request';
import { CourseListQueryHelper } from '../../shared/helper/course-list-query.helper';

export class CourseClientListREQ extends CourseBaseListREQ {
  constructor(data: Partial<CourseClientListREQ>) {
    super();
    Object.assign(this, data);
  }

  toFindManyByAccount(user: AuthUserDTO, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const filterByAccount = CourseListQueryHelper.toFilterByAccountType(user);
    const condition = { ...CourseListQueryHelper.toQueryCondition(query), ...filterByAccount };
    const orderBy = CourseListQueryHelper.toOrderBy(query);

    return {
      where: { ...condition, Creator: { status: { not: AccountStatus.SUSPENSIVE } } },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/factory/course-list.factory.ts">
import { Injectable } from '@nestjs/common';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { CourseBaseListREQ } from '../shared/course-base-list.request';
import { CourseListDTOType } from '../shared/enums';
import { CourseAdminListREQ } from './list/course-admin-list.request';
import { CourseClientListREQ } from './list/course-client-list.request';

@Injectable()
export class CourseListFactory {
  getClass<T extends CourseBaseListREQ>(classType: CourseListDTOType, data: T): CourseBaseListREQ {
    switch (classType) {
      case CourseListDTOType.CLIENT:
        return new CourseClientListREQ(data);
      case CourseListDTOType.ADMIN:
        return new CourseAdminListREQ(data);
      default:
        throw new ActionFailedException(ActionFailed.CLASS_TYPE_NOT_FOUND);
    }
  }
}
</file>

<file path="src/domains/course/shared/helper/course-detail-query.helper.ts">
import { Prisma } from '@prisma/client';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';

export class CourseDetailQueryHelper {
  static toFindUnique(id: number): Prisma.CourseFindUniqueOrThrowArgs {
    // const isCourseOwner = user.accountType === AccountType.MENTOR;

    // const creator = orUndefinedWithCondition(isCourseOwner, {
    //   creatorId: user.accountId,
    // });

    return {
      where: { id },
      select: {
        id: true,
        name: true,
        status: true,
        description: true,
        totalDuration: true,
        price: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        litmitOfStudents: true,
        creatorId: true,
        categoryId: true,
        createdAt: true,
        imageId: true,
        Category: {
          select: { id: true, name: true },
        },
        Sections: {
          where: { ...IS_ACTIVE_NESTED },
          orderBy: { ordinal: 'asc' },
          select: { id: true, title: true, description: true, ordinal: true, isPublic: true },
        },
        Creator: { select: { id: true, name: true } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-list-query.helper.ts">
import { AccountStatus, AccountType, CourseStatus, PaymentStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { IS_ACTIVE_NESTED } from 'src/shared/constants/prisma.constant';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientListREQ } from '../../factory/list/course-client-list.request';
import { CourseBaseListREQ } from '../course-base-list.request';
import { CourseSortableFields } from '../enums';

export class CourseListQueryHelper {
  static toFilterByAccountType = (user: AuthUserDTO): Prisma.CourseWhereInput => {
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.STUDENT:
        return {
          status: CourseStatus.APPROVED,
          Subscriptions: { some: { Account: { id: user.accountId, accountType: AccountType.STUDENT }, ...IS_ACTIVE_NESTED } },
        };
      case AccountType.MENTOR:
        return {
          OR: [
            { Creator: { id: user.accountId, accountType: AccountType.MENTOR } },
            { isPublic: true, status: CourseStatus.APPROVED },
          ],
        };
      default:
        return { isPublic: true, status: CourseStatus.APPROVED };
    }
  };

  static toQueryCondition = (query: CourseBaseListREQ): Prisma.CourseWhereInput => {
    const creatorName = orUndefinedWithCondition(!!query.creatorName, { Creator: parsePrismaSearch('name', query.creatorName) });
    const courseName = orUndefinedWithCondition(!!query.courseName, parsePrismaSearch('name', query.courseName));
    const targetAudiences = orUndefinedWithCondition(!!query.targetAudiences, {
      targetAudiences: { hasEvery: query.targetAudiences },
    });
    const categoryIds = orUndefinedWithCondition(!!query.categoryIds, {
      Category: { id: { in: query.categoryIds } },
    });

    return leanObject({
      status: query.courseStatus,
      ...courseName,
      ...creatorName,
      ...targetAudiences,
      ...categoryIds,
    });
  };

  static toOrderBy = (query: CourseBaseListREQ): Prisma.CourseOrderByWithRelationInput => {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case CourseSortableFields.CREATOR_NAME:
        return { Creator: { name: query.sortOrder } };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  };

  static toListByCreatorId(creatorId: number, isOwner: boolean, query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const condition = isOwner ? this.toQueryCondition(query) : { status: CourseStatus.APPROVED };

    return {
      where: { Creator: { id: creatorId }, ...condition },
      orderBy: defaultSortDesc,
      select: {
        id: true,
        name: true,
        status: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        createdAt: true,
        imageId: true,

        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }

  static toFindMany(query: CourseClientListREQ): Prisma.CourseFindManyArgs {
    const orderBy = CourseListQueryHelper.toOrderBy(query);
    const condition = CourseListQueryHelper.toQueryCondition(query);

    return {
      where: {
        ...condition,
        isPublic: true,
        status: CourseStatus.APPROVED,
        Creator: {
          status: { not: AccountStatus.SUSPENSIVE },
        },
      },
      orderBy,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        name: true,
        description: true,
        price: true,
        totalDuration: true,
        isPublic: true,
        startDate: true,
        endDate: true,
        objectives: true,
        targetAudiences: true,
        prerequisites: true,
        imageId: true,
        createdAt: true,
        Category: { select: { id: true, name: true } },
        Creator: { select: { id: true, name: true, email: true, avatarId: true } },
        _count: { select: { Sections: true, Subscriptions: { where: { Payment: { status: PaymentStatus.DONE } } } } },
      },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-section.helper.ts">
import { Prisma } from '@prisma/client';
import { isEmpty } from 'lodash';
import { addCreationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseSectionUpdateDTO } from '../../client/request/course-section-client-update.request';
import { CourseSectionDTO } from '../../dto/course-section.dto';

export class CourseSectionHelper {
  static toCreateInput(courseId: number, body: CourseSectionDTO, maxOrdinal: number): Prisma.CourseSectionCreateInput {
    //TODO: Add fileData
    const fileData = orUndefinedWithCondition(!isEmpty(body.files), {
      SectionAttachments: {
        createMany: {
          data: body.files.map((item) => addCreationTimestamps({ fileId: item.fileId, isPublic: item.isPublic })),
        },
      },
    });

    return {
      title: body.title,
      ordinal: maxOrdinal + 1,
      description: body.description,
      isPublic: body.isPublic,
      Course: connectRelation(courseId),
      ...fileData,
    };
  }

  static toUpdateInput(body: CourseSectionUpdateDTO): Prisma.CourseSectionUpdateInput {
    return {
      title: body.title,
      description: body.description,
      isPublic: body.isPublic,
    };
  }

  static toFindMaxOrdinal(courseId: number): Prisma.CourseSectionAggregateArgs {
    return {
      where: { courseId },
      _max: { ordinal: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/helper/course-update-query.helper.ts">
import { Prisma } from '@prisma/client';
import { connectRelation, removeRelation } from 'src/shared/helpers/prisma.helper';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { CourseClientUpdateREQ } from '../../client/request/course-client-update.request';

export class CourseUpdateHelper {
  static toUpdate(id: number, body: CourseClientUpdateREQ): Prisma.CourseUpdateArgs {
    return {
      where: { id },
      data: {
        name: body.name,
        description: body.description,
        price: body.price,
        isPublic: body.isPublic,
        startDate: parsePrismaDate(body.startDate),
        status: body.status,
        endDate: parsePrismaDate(body.endDate),
        objectives: body.objectives,
        targetAudiences: body.targetAudiences,
        prerequisites: body.prerequisites,
        litmitOfStudents: body.litmitOfStudents,
        Category: connectRelation(body.categoryId),
        ...orUndefinedWithCondition(!!body.imageId, { Image: removeRelation() }),
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/course/shared/course-base-list.request.ts">
import { CourseStatus, Prisma, TargetAudience } from '@prisma/client';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsOptional, ValidateIf } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { ArrayNotDuplicated } from 'src/shared/request-validator/array-not-duplicated.request-validator';
import { QueryArray } from 'src/shared/request-validator/query-array.validator';
import { CourseSortableFields } from './enums';

export abstract class CourseBaseListREQ extends PaginationREQ {
  @IsOptional()
  @NameValidator()
  courseName?: string;

  @IsOptional()
  @IsEnum(CourseStatus)
  courseStatus?: CourseStatus;

  @IsArray()
  @ArrayNotDuplicated(TargetAudience)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  @ArrayMaxSize(4)
  @IsOptional()
  @IsEnum(TargetAudience, { each: true })
  targetAudiences?: TargetAudience[];

  @IsOptional()
  @ArrayNotDuplicated(Number)
  @QueryArray({ fieldType: 'number', minSize: COMMON_CONSTANT.ARRAY_MIN_SIZE })
  categoryIds?: number[];

  @NameValidator()
  @IsOptional()
  creatorName?: string;

  @IsOptional()
  @IsEnum(CourseSortableFields)
  sortBy?: CourseSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  sortOrder: SortOrder = SortOrder.ASC;

  abstract toFindManyByAccount<T extends CourseBaseListREQ>(user: AuthUserDTO, query: T): Prisma.CourseFindManyArgs;
}
</file>

<file path="src/domains/course/shared/enums.ts">
export enum CourseSortableFields {
  CREATOR_NAME = 'creatorName',
  COURSE_NAME = 'name',
  COURSE_STATUS = 'status',
  COURSE_TYPE = 'courseType',
}

export enum CourseListDTOType {
  CLIENT = 'client',
  ADMIN = 'admin',
}
</file>

<file path="src/domains/course/shared/types.ts">
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { CourseSectionDTO } from '../dto/course-section.dto';
export enum TargetAudienceLevel {
  BEGINNER = 'BEGINNER',
  INTERMEDIATE = 'INTERMEDIATE',
  ADVANCED = 'ADVANCED',
  EXPERT = 'EXPERT',
}

export type CourseSectionUpdateDTO = {
  id: number;
} & CourseSectionDTO;

export type CourseMentorDetailRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
</file>

<file path="src/domains/course/course.module.ts">
import { Module } from '@nestjs/common';
import { CourseAdminModule } from './admin/course-admin.module';
import { CourseClientModule } from './client/course-client.module';

@Module({
  imports: [CourseClientModule, CourseAdminModule],
  exports: [CourseClientModule],
})
export class CourseModule {}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
