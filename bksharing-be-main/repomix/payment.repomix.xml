This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T18:03:35.185Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  domains/
    payment/
      client/
        payment-client.controller.spec.ts
        payment-client.controller.ts
        payment-client.module.ts
        payment-client.service.spec.ts
        payment-client.service.ts
      dto/
        payment-continue.request.ts
        payment-create.request.ts
      payment.module.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/domains/payment/client/payment-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientController', () => {
  let controller: PaymentClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [PaymentClientController],
      providers: [PaymentClientService],
    }).compile();

    controller = module.get<PaymentClientController>(PaymentClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.controller.ts">
import { Body, Controller, Post, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaymentCreateREQ } from '../dto/payment-create.request';
import { PaymentClientService } from './payment-client.service';

@Controller('client/payments')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class PaymentClientController {
  constructor(private readonly paymentClientService: PaymentClientService) {}

  @Post()
  async createPayment(@Req() req: AuthRequestDTO, @Body() body: PaymentCreateREQ): Promise<any> {
    const ipAddr = req.headers['x-forwarded-for'] || req.socket.remoteAddress;

    const payment = await this.paymentClientService.create(body, ipAddr as string);

    return BaseResponse.of(payment);
  }

  @Post('verify')
  async verify(@Body() body: ReturnQueryFromVNPay & { paymentId: number }): Promise<any> {
    const { paymentId, ...returnUrl } = body;
    const result = await this.paymentClientService.verify(paymentId, returnUrl);

    return BaseResponse.of(result);
  }
}
</file>

<file path="src/domains/payment/client/payment-client.module.ts">
import { Module } from '@nestjs/common';
import { VNP_HASHSECRET, VNP_TMNCODE } from 'src/app.config';
import { VnpayModule } from 'src/services/payment-gateway/vn-pay/vnpay.module';
import { PaymentClientController } from './payment-client.controller';
import { PaymentClientService } from './payment-client.service';

@Module({
  imports: [
    VnpayModule.register({
      tmnCode: VNP_TMNCODE,
      secureSecret: VNP_HASHSECRET,
    }),
  ],
  controllers: [PaymentClientController],
  providers: [PaymentClientService],
  exports: [PaymentClientService],
})
export class PaymentClientModule {}
</file>

<file path="src/domains/payment/client/payment-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { PaymentClientService } from './payment-client.service';

describe('PaymentClientService', () => {
  let service: PaymentClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [PaymentClientService],
    }).compile();

    service = module.get<PaymentClientService>(PaymentClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/payment/client/payment-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomType,
  NotificationRelationType,
  NotificationType,
  ParticipantAudioRoomRole,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { SubscriptionMakePaymentHelper } from 'src/domains/subscription/helper/subscription-make-payment.helper';
import { SubscriptionGetPlayload } from 'src/domains/subscription/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { ReturnQueryFromVNPay } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { VnpayService } from 'src/services/payment-gateway/vn-pay/vnpay.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { ReturnPaymentStatus } from 'src/shared/constants/payment.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { EXPIRED_SUBSCRIPTION_AFTER_APPROVED } from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { Result } from 'src/shared/generics/type.helper';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { PaymentContinueREQ } from '../dto/payment-continue.request';
import { PaymentCreateREQ } from '../dto/payment-create.request';

@Injectable()
export class PaymentClientService {
  private logger = new Logger(PaymentClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly vnpayService: VnpayService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async create(body: PaymentCreateREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.create({
      data: {
        status: PaymentStatus.IN_PROGRESS,
        price: parseDecimalNumber(body.amount),
        Subscription: connectRelation(body.subscriptionId),
      },
      select: {
        id: true,
        status: true,
      },
    });

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async continue(body: PaymentContinueREQ, ipAddr: string): Promise<any> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { subscriptionId: body.subscriptionId },
      select: { id: true, status: true },
    });

    if (payment.status !== PaymentStatus.IN_PROGRESS) {
      throw new ActionFailedException(ActionFailed.PAYMENT_NOT_AVAILABLE);
    }

    const url = await this.vnpayService.create(payment.id, PaymentCreateREQ.toVnpayRequest(body, ipAddr));

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async verify(paymentId: number, query: ReturnQueryFromVNPay): Promise<Result<ReturnQueryFromVNPay, Error>> {
    const payment = await this.transactionHost.tx.payment.findUniqueOrThrow({
      where: { id: paymentId },
      select: { subscriptionId: true },
    });

    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: payment.subscriptionId },
      select: {
        id: true,
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        accountId: true,
        Course: { select: { id: true, creatorId: true } },
      },
    });

    const now = nowEpoch();

    if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    if (now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
      this.logger.log(
        '🚀 ~ PaymentClientService ~ verify ~ EXPIRED_SUBSCRIPTION_AFTER_APPROVED: ',
        EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
      );

      this.logger.warn(
        `🚀 ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
    }

    const result = await this.vnpayService.verifyReturnUrl(paymentId, query);

    if (result.success == false) {
      this.logger.error('🚀 ~ PaymentClientService ~ verify ~ fail result:', result);
      this.logger.warn('🚀 ~ PaymentClientService ~ verify ~ fail query from third party');
      // await this.transactionHost.tx.payment.update({
      //   where: { id: paymentId },
      //   data: {
      //     status: PaymentStatus.CANCELED,
      //     Subscription: { update: { status: SubscriptionStatus.CANCELED } },
      //   },
      // });

      return result;
    }

    switch (result.data.vnp_ResponseCode) {
      case ReturnPaymentStatus.SUCCESSFUL_STATUS:
        const { payment } = await this.updatePaymentStatus(paymentId, PaymentStatus.DONE, SubscriptionStatus.ACTIVE);

        const payload = NotificationHelper.makeAppNotificationPayload(
          { id: payment.id, type: NotificationRelationType.PAYMENT },
          subscription.Course.creatorId,
          NotificationType.PAYMENT_SUCCESS,
        );

        runFunctionWithCondition(!!subscription, () => {
          this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
        });

        break;
      // case ReturnPaymentStatus.EXPIRED_STATUS:
      // await this.updatePaymentStatus(paymentId, PaymentStatus.EXPIRED, SubscriptionStatus.EXPIRED);
      // break;
      default:
        break;
    }

    return result;
  }

  async updatePaymentStatus(paymentId: number, status: PaymentStatus, subscriptionStatus: SubscriptionStatus) {
    const payment = await this.transactionHost.tx.payment.update({
      where: { id: paymentId },
      data: { status },
      select: {
        id: true,
        Subscription: {
          select: { id: true, accountId: true, courseAccessStartAt: true, Course: { select: { name: true, creatorId: true } } },
        },
      },
    });

    let cid: string;
    let callId: number;
    if (subscriptionStatus === SubscriptionStatus.ACTIVE) {
      callId = await this.createAudioCall(payment.Subscription as SubscriptionGetPlayload);
      cid = await this.generateCid(callId);
    }

    (await this.transactionHost.tx.subscription.update(
      SubscriptionMakePaymentHelper.toActivate(payment.Subscription.id, subscriptionStatus, callId),
    )) as SubscriptionGetPlayload;

    return { payment, cid };
  }

  private async createAudioCall(subscription: SubscriptionGetPlayload): Promise<number> {
    const audioCallCreateData: AudioCallAdminCreateREQ = {
      title: `${subscription.Course.name}`,
      status: RoomStatus.SCHEDULED,
      type: AudioRoomType.AUDIOROOM,
      members: [{ accountId: subscription.accountId, role: ParticipantAudioRoomRole.USER }],
      startsAt: SubscriptionMakePaymentHelper.parseAudioCallStartsAt(Number(subscription.courseAccessStartAt)),
    };

    const call = await this.transactionHost.tx.audioRoom.create(
      AudioCallAdminCreateREQ.toCreateMemberInput(subscription.Course.creatorId, audioCallCreateData),
    );

    return call.id;
  }

  // Function to generate CID
  private async generateCid(callId: number): Promise<string> {
    const cid = `${new Date().getTime()}-${callId}-${randomUUID()}`;

    await this.transactionHost.tx.audioRoom.update({
      where: { id: callId },
      data: { cid: cid },
      select: { id: true },
    });
    return cid;
  }
}
</file>

<file path="src/domains/payment/dto/payment-continue.request.ts">
import { PaymentCreateREQ } from './payment-create.request';

export class PaymentContinueREQ extends PaymentCreateREQ {}
</file>

<file path="src/domains/payment/dto/payment-create.request.ts">
import { IsEnum, IsNumber, IsOptional, IsString, MaxLength, Min } from 'class-validator';
import { VNPAY_RETURN_URL } from 'src/app.config';
import { BankCode } from 'src/services/payment-gateway/vn-pay/shared/vnpay.enum';
import { VNPayBuildUrlRequest } from 'src/services/payment-gateway/vn-pay/shared/vnpay.type';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class PaymentCreateREQ {
  @IdValidator()
  subscriptionId: number;

  @IsNumber()
  @Min(COMMON_CONSTANT.ZERO_VALUE)
  amount: number;

  @IsEnum(BankCode)
  @IsOptional()
  bankCode?: BankCode;

  @IsString()
  @MaxLength(255)
  description: string;

  static toVnpayRequest(body: PaymentCreateREQ, ipAddr: string): VNPayBuildUrlRequest {
    return {
      vnp_Amount: body.amount,
      vnp_BankCode: body.bankCode,
      vnp_OrderInfo: body.description,
      vnp_IpAddr: ipAddr,
      vnp_ReturnUrl: VNPAY_RETURN_URL,
      vnp_TxnRef: `${body.subscriptionId}-${nowEpoch()}`,
    };
  }
}
</file>

<file path="src/domains/payment/payment.module.ts">
import { Module } from '@nestjs/common';
import { PaymentClientModule } from './client/payment-client.module';

@Module({
  imports: [PaymentClientModule],
})
export class PaymentModule {}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myśliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
