This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T17:59:23.978Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  domains/
    mentor/
      admin/
        dto/
          mentor-admin-detail.dto.ts
          mentor-client-detail.dto.ts
        request/
          mentor-admin-approve.request.ts
          mentor-admin-interview.request.ts
          mentor-admin-list.request.ts
          mentor-client-list.request.ts
        response/
          mentor-admin-detail.response.ts
          mentor-admin-interview.response.ts
          mentor-admin-list.response.ts
          mentor-client-detail.response.ts
          mentor-client-list.response.ts
        mentor-admin.controller.spec.ts
        mentor-admin.controller.ts
        mentor-admin.module.ts
        mentor-admin.service.spec.ts
        mentor-admin.service.ts
      client/
        request/
          mentor-client-achievement-create.request.ts
          mentor-client-achievement-update.request.ts
          mentor-client-course-list.request.ts
          mentor-client-schedule-create.request.ts
          mentor-client-schedule-list.request.ts
          mentor-client-schedule-update.request.ts
          mentor-client-update.request.ts
        response /
          mentor-schedule-list.response.ts
        mentor-client.controller.spec.ts
        mentor-client.controller.ts
        mentor-client.module.ts
        mentor-client.service.spec.ts
        mentor-client.service.ts
        mentor-schedule.service.ts
      shared/
        enums.ts
        types.ts
      mentor.module.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/domains/mentor/admin/dto/mentor-admin-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorAdminDetailDTO {
  static toFindUnique(mentorId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        accpetedAt: true,
        createdAt: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            phoneNumber: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/dto/mentor-client-detail.dto.ts">
import { Prisma } from '@prisma/client';

export class MentorClientDetailDTO {
  static toFindByAccountId(accountId: number): Prisma.MentorFindUniqueOrThrowArgs {
    return {
      where: { accountId: accountId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindFirst(mentorId: number): Prisma.MentorFindFirstOrThrowArgs {
    return {
      where: { id: mentorId },
      select: {
        id: true,
        accountId: true,
        status: true,
        fileId: true,
        Account: {
          select: {
            name: true,
            email: true,
            dob: true,
            gender: true,
            avatarId: true,
            bio: true,
          },
        },
      },
    };
  }

  static toFindManyAchievements(mentorId: number): Prisma.ProfileAchievementFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        name: true,
        major: true,
        position: true,
        isCurrent: true,
        organization: true,
        startDate: true,
        endDate: true,
        type: true,
        description: true,
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-approve.request.ts">
import { MentorStatus, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class MentorAdminApproveREQ {
  @BooleanValidator()
  isApproved: boolean;

  static toApprove(id: number, body: MentorAdminApproveREQ, user: AuthUserDTO): Prisma.MentorUpdateArgs {
    return {
      where: { id },
      data: {
        status: body.isApproved ? MentorStatus.ACCEPTED : MentorStatus.REJECTED,
        Acceptant: connectRelation(user.accountId),
        accpetedAt: nowEpoch(),
      },
      select: { id: true, accountId: true },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-interview.request.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { IsString } from 'class-validator';
import { AudioCallAdminCreateREQ } from 'src/domains/audio-call/admin/request/audio-call-admin-create.request';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';

export class MentorAdminInterviewREQ {
  @IsString()
  title: string;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  static toAudioRoomCreateREQ(mentorId: number, body: MentorAdminInterviewREQ): AudioCallAdminCreateREQ {
    return {
      title: body.title,
      type: AudioRoomType.INTERVIEW,
      startsAt: body.startsAt,
      status: RoomStatus.SCHEDULED,
      members: [
        {
          accountId: mentorId,
          role: 'USER',
        },
      ],
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-admin-list.request.ts">
import { AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorAdminListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorAdminListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorAdminListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorAdminListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        status: true,
        accpetedAt: true,
        accountId: true,
        fileId: true,
        Account: { select: { name: true, email: true, phoneNumber: true, avatarId: true } },
        createdAt: true,
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/request/mentor-client-list.request.ts">
import { AccountStatus, AccountType, MentorStatus, Prisma } from '@prisma/client';
import { IsEnum, IsOptional, IsString, ValidateIf } from 'class-validator';
import { SortOrder } from 'src/shared/enums/query.enum';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { MentorAdminListSortableFields } from '../../shared/enums';

export class MentorClientListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  name?: string;

  @IsString()
  @IsOptional()
  email?: string;

  @IsString()
  @IsOptional()
  phoneNumber?: string;

  @IsEnum(MentorStatus)
  @IsOptional()
  status?: MentorStatus;

  @IsEnum(MentorAdminListSortableFields)
  @IsOptional()
  sortBy?: MentorAdminListSortableFields;

  @IsEnum(SortOrder)
  @ValidateIf((o) => o.sortBy)
  @IsOptional()
  sortOrder: SortOrder = SortOrder.DESC;

  static toQueryCondition(query: MentorClientListREQ): Prisma.MentorWhereInput {
    const nameSearch = orUndefinedWithCondition(!!query.name, parsePrismaSearch('name', query.name));
    const emailSearch = orUndefinedWithCondition(!!query.email, parsePrismaSearch('email', query.email));

    const phoneNumberSearch = orUndefinedWithCondition(!!query.phoneNumber, parsePrismaSearch('phoneNumber', query.phoneNumber));

    return leanObject({
      Account: {
        ...nameSearch,
        ...emailSearch,
        ...phoneNumberSearch,
        accountType: AccountType.MENTOR,
      },
      status: query.status,
    });
  }

  static toOrderBy(query: MentorClientListREQ): Prisma.MentorOrderByWithRelationInput {
    if (!query.sortBy) return defaultSortDesc;

    switch (query.sortBy) {
      case MentorAdminListSortableFields.NAME:
        return {
          Account: {
            name: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.EMAIL:
        return {
          Account: {
            email: query.sortOrder,
          },
        };
      case MentorAdminListSortableFields.PHONE_NUMBER:
        return {
          Account: {
            phoneNumber: query.sortOrder,
          },
        };
      default:
        return { [query.sortBy]: query.sortOrder };
    }
  }

  static toFindMany(query: MentorClientListREQ): Prisma.MentorFindManyArgs {
    const condition = this.toQueryCondition(query);
    const orderBy = this.toOrderBy(query);

    return {
      where: { ...condition, Account: { status: { not: AccountStatus.SUSPENSIVE } } },
      ...QueryPagingHelper.queryPaging(query),
      orderBy: orderBy,
      select: {
        id: true,
        accountId: true,
        Account: { select: { name: true, avatarId: true, bio: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-detail.response.ts">
import { AchievementType } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          organization: e.organization,
          description: e.description,
          position: e.position,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: e.organization,
          description: e.description,
          major: e.major,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: e.name,
          organization: e.organization,
          description: e.description,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorAdminDetailRESP {
  id: number;
  accountId: number;
  status: string;
  gender: string;
  dob: string;
  accpetedAt: string;
  createdAt: string;
  name: string;
  email: string;
  phoneNumber: string;
  cv: FileRESP;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    cv: FileRESP,
    thumbnail?: ImageRESP,
  ): MentorAdminDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      status: e.status,
      gender: e.Account.gender,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      accpetedAt: parseEpoch(e.accpetedAt),
      createdAt: parseEpoch(e.createdAt),
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      cv: cv,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-interview.response.ts">
import { AudioRoomParticipantDTO } from 'src/domains/audio-call/admin/dto/participant-dto';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { parseEpoch } from 'src/shared/parsers/common.parser';

export class MentorAdminInterviewRESP {
  creatorId: number;
  cid: string;
  startsAt: string;
  members: AudioRoomParticipantDTO[];

  static fromEntity(e: AudioRoomGetPayload, cid: string): MentorAdminInterviewRESP {
    return {
      creatorId: e.creatorId,
      cid: cid,
      startsAt: parseEpoch(e.startsAt),
      members: e.Participants.map((m) => ({
        accountId: m.accountId,
        role: m.role,
      })),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-admin-list.response.ts">
import { MentorStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { MentorGetPayload } from '../../shared/types';

export class MentorAdminListRESP {
  id: number;
  accountId: number;
  name: string;
  email: string;
  phoneNumber: string;
  registeredAt: string;
  status: MentorStatus;
  avatar?: ImageRESP;
  cv?: FileRESP;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumnail?: ImageRESP,
    cv?: FileRESP,
  ): MentorAdminListRESP {
    return {
      id: e.id,
      status: e.status,
      accountId: e.accountId,
      name: e.Account.name,
      email: e.Account.email,
      phoneNumber: e.Account.phoneNumber,
      registeredAt: parseEpoch(e.createdAt),
      avatar: thumnail,
      cv: cv,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-detail.response.ts">
import { AchievementType, MentorStatus } from '@prisma/client';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { MentorGetPayload, ProfileAchievementGetPayload } from '../../shared/types';

export class MentorAchievementRESP {
  id: number;
  name?: string;
  organization: string;
  description: string;
  startDate: string;
  isCurrent: boolean;
  endDate: string | null;
  type: AchievementType;
  position?: string;
  major?: string;

  static filterAchievementType(e: ProfileAchievementGetPayload): MentorAchievementRESP {
    switch (e.type) {
      case AchievementType.EXPERIENCE:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          position: e.position,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          id: e.id,
          organization: e.organization,
          description: e.description,
          major: e.major,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          id: e.id,
          name: e.name,
          organization: e.organization,
          description: e.description,
          isCurrent: e.isCurrent,
          startDate: String(parsePrismaDateToEpoch(e.startDate)),
          endDate: e.endDate ? String(parsePrismaDateToEpoch(e.endDate)) : null,
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
export class MentorClientDetailRESP {
  id: number;
  accountId: number;
  bio?: string;
  name: string;
  gender: string;
  dob: string;
  status: MentorStatus;
  thumbnail?: ImageRESP;
  achievements: MentorAchievementRESP[];

  static fromEntity(
    e: MentorGetPayload,
    achievements: ProfileAchievementGetPayload[],
    thumbnail?: ImageRESP,
  ): MentorClientDetailRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      gender: e.Account.gender,
      status: e.status,
      dob: String(parsePrismaDateToEpoch(e.Account.dob)),
      bio: e.Account.bio,
      name: e.Account.name,
      thumbnail: thumbnail,
      achievements: achievements.map((achievement) => MentorAchievementRESP.filterAchievementType(achievement)),
    };
  }
}
</file>

<file path="src/domains/mentor/admin/response/mentor-client-list.response.ts">
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorGetPayload } from '../../shared/types';

export class MentorClientListRESP {
  id: number;
  accountId: number;
  name: string;
  thumbnail?: ImageRESP;
  bio?: string;
  noOfSubscriptions?: number;
  rateOfMentor?: number;

  static fromEntity(
    e: MentorGetPayload,
    data: {
      noOfSubscriptions?: number;
      rateOfMentor?: number;
    },
    thumbnail?: ImageRESP,
  ): MentorClientListRESP {
    return {
      id: e.id,
      accountId: e.accountId,
      name: e.Account.name,
      bio: e.Account.bio,
      thumbnail,
      noOfSubscriptions: data.noOfSubscriptions ?? 0,
      rateOfMentor: data.rateOfMentor ?? 0,
    };
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminController', () => {
  let controller: MentorAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorAdminController],
      providers: [MentorAdminService],
    }).compile();

    controller = module.get<MentorAdminController>(MentorAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorAdminService } from './mentor-admin.service';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminDetailRESP } from './response/mentor-admin-detail.response';
import { MentorAdminInterviewRESP } from './response/mentor-admin-interview.response';

@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
@Controller('admin/mentors')
export class MentorAdminController {
  constructor(private readonly mentorAdminService: MentorAdminService) {}

  @Get()
  async list(@Query() query: MentorAdminListREQ) {
    const response = await this.mentorAdminService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorAdminService.detail(mentorId);

    return BaseResponse.of(
      MentorAdminDetailRESP.fromEntity(response.mentor, response.achievements, response.cv, response.thumbnail),
    );
  }

  @Post(':id/audio-call')
  async interviewMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminInterviewREQ,
  ) {
    const call = await this.mentorAdminService.interviewMentor(req.user, mentorId, body);

    return BaseResponse.of(MentorAdminInterviewRESP.fromEntity(call, call.cid));
  }

  @Patch(':id/approvement')
  async approveMentor(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorAdminApproveREQ,
  ) {
    const call = await this.mentorAdminService.updateResultInterview(req.user, mentorId, body);

    return BaseResponse.of(call.id);
  }
}
</file>

<file path="src/domains/mentor/admin/mentor-admin.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from 'src/domains/audio-call/admin/audio-call-admin.module';
import { CommonModule } from 'src/services/common.module';
import { MentorAdminController } from './mentor-admin.controller';
import { MentorAdminService } from './mentor-admin.service';

@Module({
  imports: [CommonModule, AudioCallAdminModule],
  controllers: [MentorAdminController],
  providers: [MentorAdminService],
})
export class MentorAdminModule {}
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorAdminService } from './mentor-admin.service';

describe('MentorAdminService', () => {
  let service: MentorAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorAdminService],
    }).compile();

    service = module.get<MentorAdminService>(MentorAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/admin/mentor-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus, NotificationRelationType, NotificationType, RoomStatus } from '@prisma/client';
import { randomUUID } from 'crypto';
import { AudioCallAdminService } from 'src/domains/audio-call/admin/audio-call-admin.service';
import { AudioRoomGetPayload } from 'src/domains/audio-call/shared/types';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorGetPayload } from '../shared/types';
import { MentorAdminDetailDTO } from './dto/mentor-admin-detail.dto';
import { MentorAdminApproveREQ } from './request/mentor-admin-approve.request';
import { MentorAdminInterviewREQ } from './request/mentor-admin-interview.request';
import { MentorAdminListREQ } from './request/mentor-admin-list.request';
import { MentorAdminListRESP } from './response/mentor-admin-list.response';

@Injectable()
export class MentorAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly audioCallAdminService: AudioCallAdminService,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  /* API: List mentor */
  async list(query: MentorAdminListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorAdminListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorAdminListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const cv = await this.fileService.detail(mentor.fileId);

        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorAdminListRESP.fromEntity(
          mentor,
          { noOfSubscriptions, rateOfMentor: rateOfMentor._avg.mentorRating },
          thumbnail,
          cv,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findUniqueOrThrow(
      MentorAdminDetailDTO.toFindUnique(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorAdminDetailDTO.toFindManyAchievements(mentorId),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const cv = await this.fileService.detail(mentor.fileId);
    const data = { mentor, achievements, thumbnail, cv };

    return data;
  }

  /* API: Create interview with mentor */
  async interviewMentor(user: AuthUserDTO, mentorId: number, body: MentorAdminInterviewREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, accountId: true, status: true },
    });

    if (mentor.status == MentorStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.MENTOR_INTERVIEW_ACCEPTED);
    }

    const call = (await this.audioCallAdminService.createAudioCall(
      user,
      MentorAdminInterviewREQ.toAudioRoomCreateREQ(mentor.accountId, body),
    )) as AudioRoomGetPayload;

    //generate cid
    const cid = `${new Date().getTime()}-${call.id}-${randomUUID()}`;
    await this.transactionHost.tx.audioRoom.update({
      where: { id: call.id },
      data: { cid: cid },
      select: { id: true },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: call.id, type: NotificationRelationType.AUDIO_CALL },
      mentor.accountId,
      NotificationType.AUDIO_CALL_CREATED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return { cid: cid, ...call };
  }

  /* API: Approve or Reject Mentor after interview */
  @Transactional(TRANSACTION_TIMEOUT)
  async updateResultInterview(user: AuthUserDTO, id: number, body: MentorAdminApproveREQ) {
    //1. update mentor status
    const mentor = await this.transactionHost.tx.mentor.update(MentorAdminApproveREQ.toApprove(id, body, user));

    const onGoingInterview = await this.transactionHost.tx.audioRoom.findFirst({
      where: { status: RoomStatus.ONGOING, creatorId: user.accountId, Participants: { some: { accountId: mentor.accountId } } },
      select: { id: true },
    });

    if (onGoingInterview) {
      throw new ActionFailedException(ActionFailed.MENTOR_CANNOT_UPDATE_RESULT, MentorErrorMessages.MSG01);
    }

    //2. Deletes all scheduled interviews
    await this.transactionHost.tx.audioRoom.deleteMany({
      where: { status: RoomStatus.SCHEDULED, Participants: { some: { accountId: mentor.accountId } } },
    });

    await this.transactionHost.tx.audioRoomParticipant.updateMany({
      where: { accountId: mentor.accountId, AudioRoom: { creatorId: user.accountId } },
      data: { isInCall: false, isActive: false },
    });

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: mentor.id, type: NotificationRelationType.MENTOR },
      mentor.accountId,
      body.isApproved ? NotificationType.MENTOR_APPROVED : NotificationType.MENTOR_REJECTED,
    );
    runFunctionWithCondition(!!mentor, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return mentor;
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-create.request.ts">
import { AuthMentorAchievementREQ } from 'src/domains/auth/request/auth-mentor-register.request';

export class MentorClientAchievementCreateREQ extends AuthMentorAchievementREQ {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-achievement-update.request.ts">
import { AchievementType } from '@prisma/client';
import { IsEnum, IsOptional, IsString, MaxLength, ValidateIf } from 'class-validator';
import { isUndefined } from 'lodash';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parsePrismaDate } from 'src/shared/parsers/datetime.parse';
import { NameValidator } from 'src/shared/request-validator/account.validator';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { DateMonthYearCompare } from 'src/shared/request-validator/month-year-compare.request-validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class MentorClientAchievementUpdateREQ {
  @IdValidator()
  id: number;

  @NameValidator()
  @ValidateIf((o) => o.achievementType === AchievementType.CERTIFICATION)
  name?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  organization?: string; // Can be company or institution or certification body

  @BooleanValidator()
  @IsOptional()
  isCurrent?: boolean;

  @IsEnum(AchievementType)
  @IsOptional()
  achievementType?: AchievementType;

  @IsString()
  @MaxLength(255)
  @IsOptional()
  description?: string;

  @IsString()
  @IsOptional()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EXPERIENCE)
  position: string; // For experience

  @IsString()
  @MaxLength(255)
  @ValidateIf((o) => o.achievementType === AchievementType.EDUCATION)
  major?: string; // For education

  @OnlyDate()
  startDate?: string;

  @OnlyDate()
  @DateMonthYearCompare({ startField: 'startDate' })
  @ValidateIf((o) => !isUndefined(o.isCurrent) && o.isCurrent == false)
  endDate?: string;

  static ToUpdateByAchievementType(body: MentorClientAchievementUpdateREQ) {
    switch (body.achievementType) {
      case AchievementType.EXPERIENCE:
        return {
          organization: body.organization,
          description: body.description,
          position: body.position,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EXPERIENCE,
        };
      case AchievementType.EDUCATION:
        return {
          organization: body.organization,
          description: body.description,
          major: body.major,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.EDUCATION,
        };

      case AchievementType.CERTIFICATION:
        return {
          name: body.name,
          organization: body.organization,
          description: body.description,
          isCurrent: body.isCurrent,
          startDate: parsePrismaDate(body.startDate),
          endDate: parsePrismaDate(body.endDate),
          type: AchievementType.CERTIFICATION,
        };
      default:
        throw new ActionFailedException(ActionFailed.AUTH_ACHIEVEMENT_INVALID_TYPE);
    }
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-course-list.request.ts">
import { PickType } from '@nestjs/swagger';
import { CourseClientListREQ } from 'src/domains/course/factory/list/course-client-list.request';

export class MentorClientCourseListREQ extends PickType(CourseClientListREQ, ['courseStatus']) {}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-create.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleCreateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toCreate(id: number, body: MentorClientScheduleCreateREQ): Prisma.MentorScheduleCreateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        Mentor: connectRelation(id),
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-list.request.ts">
import { Prisma } from '@prisma/client';

export class MentorScheduleClientListREQ {
  static toFindMany(mentorId: number): Prisma.MentorScheduleFindManyArgs {
    return {
      where: { mentorId: mentorId },
      select: {
        id: true,
        dayOfWeek: true,
        startTime: true,
        endTime: true,
        Course: { select: { id: true, name: true, description: true } },
      },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-schedule-update.request.ts">
import { DayOfWeek, Prisma } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { HourMinValidator } from 'src/shared/request-validator/hour-min-format.validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class MentorClientScheduleUpdateREQ {
  @HourMinValidator()
  startTime: string;

  @HourMinValidator()
  endTime: string;

  @IsEnum(DayOfWeek)
  dayOfWeek: DayOfWeek;

  @IdValidator()
  @IsOptional()
  courseId?: number;

  static toUpdate(scheduleId: number, body: MentorClientScheduleUpdateREQ): Prisma.MentorScheduleUpdateArgs {
    const course = orUndefinedWithCondition(!!body.courseId, { Course: connectRelation(body.courseId) });

    return {
      where: { id: scheduleId },
      data: {
        dayOfWeek: body.dayOfWeek,
        startTime: body.startTime,
        endTime: body.endTime,
        ...course,
      },
      select: { id: true },
    };
  }
}
</file>

<file path="src/domains/mentor/client/request/mentor-client-update.request.ts">
import { AccountUpdateDTO } from 'src/domains/accounts/dto/account-update.dto';

export class MentorClientUpdateREQ extends AccountUpdateDTO {}
</file>

<file path="src/domains/mentor/client/response /mentor-schedule-list.response.ts">
import { Course } from '@prisma/client';
import { MentorScheduleCourseDetail, MentorScheduleGetPayload } from '../../shared/types';

export class MentorScheduleListRESP {
  dayOfWeek: string;
  timeRanges: { id: number; startTime: string; endTime: string; course: MentorScheduleCourseDetail }[] = [];

  static fromEntity(entities: MentorScheduleGetPayload[]): MentorScheduleListRESP[] {
    const response: MentorScheduleListRESP[] = [];

    entities.forEach((entity) => {
      const existed = response.find((item) => item.dayOfWeek === entity.dayOfWeek);
      const data = {
        id: entity.id,
        startTime: entity.startTime,
        endTime: entity.endTime,
        course: this.fromEntityWithCourse(entity.Course as Course),
      };

      if (existed) {
        existed.timeRanges.push(data);
      } else {
        response.push({ dayOfWeek: entity.dayOfWeek, timeRanges: [data] });
      }
    });

    return response;
  }

  static fromEntityWithCourse(course: Course): MentorScheduleCourseDetail {
    if (!course) return null;

    return {
      id: course.id,
      name: course.name,
      description: course.description,
    };
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientController', () => {
  let controller: MentorClientController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [MentorClientController],
      providers: [MentorClientService],
    }).compile();

    controller = module.get<MentorClientController>(MentorClientController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.controller.ts">
import { Body, Controller, Delete, Get, Param, ParseIntPipe, Patch, Post, Put, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Public } from 'src/domains/auth/auth-public.decorator';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { FeedbackClientService } from 'src/domains/feedback/client/feedback-client.service';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Controller('client/mentors')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.MENTOR)
export class MentorClientController {
  constructor(
    private readonly mentorClientService: MentorClientService,
    private readonly mentorSchduleService: MentorScheduleService,
    private readonly feedbackClientService: FeedbackClientService,
  ) {}

  @Get()
  @Public()
  async list(@Query() query: MentorClientListREQ) {
    const response = await this.mentorClientService.list(query);

    return PaginationResponse.ofWithTotal(response.mentorsDTO, response.count);
  }

  @Get('profile')
  async profile(@Req() req: AuthRequestDTO) {
    const response = await this.mentorClientService.getMentorByAccountId(req.user.accountId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Post('schedules')
  async createSchedule(@Req() req: AuthRequestDTO, @Body() body: MentorClientScheduleCreateREQ) {
    await this.mentorSchduleService.createScheduleByAccountId(req.user, body);

    return BaseResponse.ok();
  }

  @Get('schedules') async getSchedule(@Req() req: AuthRequestDTO) {
    const response = await this.mentorSchduleService.getSchedulesByAccountId(req.user.accountId);

    return BaseResponse.of(response);
  }

  @Public()
  @Get(':id/schedules')
  async getScheduleByMentorId(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorSchduleService.getSchedulesByMentorId(mentorId);

    return BaseResponse.of(response);
  }

  @Get(':mentorId/feedbacks')
  async listFeedbackByMentorId(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const data = await this.feedbackClientService.listFeedbackByMentorId(mentorId);

    return PaginationResponse.ofWithTotal(data.dtos, data.count);
  }

  @Put('schedules/:id') async updateSchedule(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) scheduleId: number,
    @Body() body: MentorClientScheduleUpdateREQ,
  ) {
    await this.mentorSchduleService.updateMentorSchedule(req.user, scheduleId, body);

    return BaseResponse.ok();
  }

  @Delete('schedules/:id') async deleteSchedule(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) scheduleId: number) {
    await this.mentorSchduleService.deleteScheduleById(req.user.accountId, scheduleId);

    return BaseResponse.ok();
  }

  @Get(':id')
  @Public()
  async detail(@Param('id', ParseIntPipe) mentorId: number) {
    const response = await this.mentorClientService.detail(mentorId);

    return BaseResponse.of(MentorClientDetailRESP.fromEntity(response.mentor, response.achievements, response.thumbnail));
  }

  @Roles(AccountType.MENTOR, AccountType.STUDENT)
  @Get(':id/courses')
  async getCoursesByMentorId(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) mentorId: number,
    @Query() query: MentorClientCourseListREQ,
  ) {
    const response = await this.mentorClientService.getCoursesByMentorId(mentorId, req.user, query);

    return BaseResponse.of(response);
  }

  @Patch(':id')
  async update(@Param('id', ParseIntPipe) mentorId: number, @Req() req: AuthRequestDTO, @Body() body: MentorClientUpdateREQ) {
    const response = await this.mentorClientService.update(mentorId, req.user, body);

    return BaseResponse.of(response.id);
  }

  @Post(':id/achievements')
  async addProfileAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementCreateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.addProfileAchievement(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Patch(':id/achievements')
  async updateAchievements(
    @Param('id', ParseIntPipe) mentorId: number,
    @Body() body: MentorClientAchievementUpdateREQ,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.updateAchievements(mentorId, body, req.user);

    return BaseResponse.of(response);
  }

  @Delete(':id/achievements/:achievementId')
  async deleteAchievement(
    @Param('id', ParseIntPipe) mentorId: number,
    @Param('achievementId', ParseIntPipe) achievementId: number,
    @Req() req: AuthRequestDTO,
  ) {
    const response = await this.mentorClientService.deleteAchievement(mentorId, achievementId, req.user);

    return BaseResponse.of(response);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-client.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { CourseClientModule } from 'src/domains/course/client/course-client.module';
import { FeedbackClientModule } from 'src/domains/feedback/client/feedback-client.module';
import { MentorClientController } from './mentor-client.controller';
import { MentorClientService } from './mentor-client.service';
import { MentorScheduleService } from './mentor-schedule.service';

@Module({
  imports: [AccountModule, CourseClientModule, FeedbackClientModule],
  controllers: [MentorClientController],
  providers: [MentorClientService, MentorScheduleService],
  exports: [MentorClientService],
})
export class MentorClientModule {}
</file>

<file path="src/domains/mentor/client/mentor-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { MentorClientService } from './mentor-client.service';

describe('MentorClientService', () => {
  let service: MentorClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [MentorClientService],
    }).compile();

    service = module.get<MentorClientService>(MentorClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/mentor/client/mentor-client.service.ts">
import { Injectable } from '@nestjs/common';
import { MentorStatus } from '@prisma/client';
import { AccountService } from 'src/domains/accounts/account.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { CourseClientService } from 'src/domains/course/client/course-client.service';
import { ImageService } from 'src/domains/image/image.service';
import { MentorClientDetailDTO } from 'src/domains/mentor/admin/dto/mentor-client-detail.dto';
import { MentorClientListREQ } from 'src/domains/mentor/admin/request/mentor-client-list.request';
import { MentorClientListRESP } from 'src/domains/mentor/admin/response/mentor-client-list.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { AccountErrorMessages, MentorErrorMessages } from 'src/shared/messages/error-messages';
import { MentorClientAchievementCreateREQ } from './request/mentor-client-achievement-create.request';
import { MentorClientAchievementUpdateREQ } from './request/mentor-client-achievement-update.request';
import { MentorClientCourseListREQ } from './request/mentor-client-course-list.request';
import { MentorClientUpdateREQ } from './request/mentor-client-update.request';

@Injectable()
export class MentorClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly accountService: AccountService,
    private readonly imageService: ImageService,
    private readonly courseClientService: CourseClientService,
  ) {}

  /* API: List All Mentor */
  async list(query: MentorClientListREQ) {
    const mentors = await this.transactionHost.tx.mentor.findMany(MentorClientListREQ.toFindMany(query));
    const count = await this.transactionHost.tx.mentor.count({ where: MentorClientListREQ.toQueryCondition(query) });

    const mentorsDTO = await Promise.all(
      mentors.map(async (mentor: MentorGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
        const noOfSubscriptions = await this.transactionHost.tx.subscription.count({
          where: { Course: { creatorId: mentor.accountId } },
        });

        const rateOfMentor = await this.transactionHost.tx.feedback.aggregate({
          where: { Subscription: { Course: { creatorId: mentor.accountId } } },
          _avg: { mentorRating: true },
        });

        return MentorClientListRESP.fromEntity(
          mentor,
          {
            noOfSubscriptions,
            rateOfMentor: rateOfMentor._avg.mentorRating,
          },
          thumbnail,
        );
      }),
    );

    return { mentorsDTO, count };
  }

  /* API: Update Mentor */
  async update(mentorId: number, user: AuthUserDTO, body: MentorClientUpdateREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    await this.accountService.updateAccount(user, body);

    return mentor;
  }

  /* API: Update achievements by mentor id */
  async updateAchievements(mentorId: number, body: MentorClientAchievementUpdateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.MENTOR_NOT_FOUND, MentorErrorMessages.MSG04);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(body.id)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement && currentAchievement.id !== body.id) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.update({
      where: { id: body.id },
      data: MentorClientAchievementUpdateREQ.ToUpdateByAchievementType(body),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Add achievements by mentor id */
  async addProfileAchievement(mentorId: number, body: MentorClientAchievementCreateREQ, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findUnique({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true },
    });

    if (!mentor) throw new ActionFailedException(ActionFailed.MENTOR_NOT_BELONG_TO_THIS_ACCOUNT, MentorErrorMessages.MSG02);

    const currentAchievement = await this.transactionHost.tx.profileAchievement.findFirst({
      where: { mentorId: mentor.id, isCurrent: true },
      select: { id: true },
    });

    if (body.isCurrent && currentAchievement) {
      await this.transactionHost.tx.profileAchievement.update({
        where: { id: currentAchievement.id },
        data: { isCurrent: false },
      });
    }

    const achievement = await this.transactionHost.tx.profileAchievement.create({
      data: MentorClientAchievementCreateREQ.ToCreateByAchievementType(body, mentorId),
      select: { id: true },
    });

    return { mentorId: mentor.id, achievementId: achievement.id };
  }

  /* API: Delete achievements by mentor id */
  async deleteAchievement(mentorId: number, achievementId: number, user: AuthUserDTO) {
    const mentor = await this.transactionHost.tx.mentor.findFirst({
      where: { id: mentorId, accountId: user.accountId },
      select: { id: true, accountId: true, ProfileAchievements: { select: { id: true } } },
    });

    if (!mentor) {
      throw new ActionFailedException(ActionFailed.ACCOUNT_NOT_FOUND, AccountErrorMessages.MSG01);
    }

    const profileAchievementIds = mentor.ProfileAchievements.map((item) => item.id);

    if (!profileAchievementIds.includes(achievementId)) {
      throw new ActionFailedException(ActionFailed.MENTOR_PROFILE_ACHIEVEMENT_NOT_FOUND, MentorErrorMessages.MSG03);
    }

    await this.transactionHost.tx.profileAchievement.delete({ where: { id: achievementId } });

    return { mentorId: mentor.id, achievementId };
  }

  /* API: Mentor detail by mentor id */
  async detail(mentorId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindFirst(mentorId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getMentorByAccountId(accountId: number) {
    const mentor = (await this.transactionHost.tx.mentor.findFirstOrThrow(
      MentorClientDetailDTO.toFindByAccountId(accountId),
    )) as MentorGetPayload;

    const achievements = await this.transactionHost.tx.profileAchievement.findMany(
      MentorClientDetailDTO.toFindManyAchievements(mentor.id),
    );

    const thumbnail = await this.imageService.getImageOriginal(mentor.Account.avatarId);
    const data = { mentor, achievements, thumbnail };

    return data;
  }

  async getCoursesByMentorId(mentorId: number, user: AuthUserDTO, query: MentorClientCourseListREQ) {
    const mentor = await this.transactionHost.tx.mentor.findFirstOrThrow({
      where: { id: mentorId },
      select: { id: true, status: true, accountId: true },
    });

    console.log(' ~ MentorClientService ~ getCoursesByMentorId ~ mentor:', mentor);

    const isOwner = mentor.accountId === user.accountId;

    if (mentor.status !== MentorStatus.ACCEPTED) throw new ActionFailedException(ActionFailed.MENTOR_NOT_YET_ACCEPTED);

    return await this.courseClientService.getAllbyCreatorId(mentor.accountId, isOwner, query as any);
  }
}
</file>

<file path="src/domains/mentor/client/mentor-schedule.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { CourseStatus, MentorSchedule } from '@prisma/client';
import { isEmpty } from 'lodash';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { checkHourMinStartOverlap } from 'src/shared/helpers/common.helper';
import { MentorScheduleGetPayload } from '../shared/types';
import { MentorClientScheduleCreateREQ } from './request/mentor-client-schedule-create.request';
import { MentorScheduleClientListREQ } from './request/mentor-client-schedule-list.request';
import { MentorClientScheduleUpdateREQ } from './request/mentor-client-schedule-update.request';

import { SUBSCRIPTION_ACTIVE_STATUS } from 'src/shared/constants/subscription.constant';
import { MentorScheduleListRESP } from './response /mentor-schedule-list.response';

@Injectable()
export class MentorScheduleService {
  private readonly logger = new Logger(MentorScheduleService.name);
  constructor(private readonly transactionHost: TransactionHost) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createScheduleByAccountId(user: AuthUserDTO, body: MentorClientScheduleCreateREQ): Promise<any> {
    const existedMentor = await this.findMentorByAccountId(user.accountId);

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true, status: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
          else if (course.status !== CourseStatus.APPROVED) throw new ActionFailedException(ActionFailed.COURSE_NOT_AVAILABLE);
        });
    }

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    await this.checkOverlapSchedule(existedMentor.id, body);

    const schedule = await this.transactionHost.tx.mentorSchedule.create(
      MentorClientScheduleCreateREQ.toCreate(existedMentor.id, body),
    );

    return schedule;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async updateMentorSchedule(
    user: AuthUserDTO,
    scheduleId: number,
    body: MentorClientScheduleUpdateREQ,
  ): Promise<MentorSchedule> {
    const existedSchedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: scheduleId, Mentor: { accountId: user.accountId } },
      select: { mentorId: true },
    });

    if (body.courseId) {
      await this.transactionHost.tx.course
        .findUnique({
          where: { id: body.courseId, creatorId: user.accountId, status: CourseStatus.APPROVED },
          select: { id: true },
        })
        .then((course) => {
          if (!course) throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
        });
    }

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: user.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS }, mentorScheduleId: scheduleId },
      select: { id: true },
    });

    if (subscriptions.length > 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);

    if (!this.checkOneHourFromStartTime(body.startTime, body.endTime))
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_TIME_NOT_UNDER_ONE_HOUR);

    const existedSchedulesExcludeCurrId = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: existedSchedule.mentorId, dayOfWeek: body.dayOfWeek, id: { not: scheduleId } },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedulesExcludeCurrId)) {
      const isOverlap = existedSchedulesExcludeCurrId.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }

    // Step 3: Update schedule
    const schedule = await this.transactionHost.tx.mentorSchedule.update(
      MentorClientScheduleUpdateREQ.toUpdate(scheduleId, body),
    );

    return schedule;
  }

  async getSchedulesByAccountId(accountId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.findMentorByAccountId(accountId);

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async getSchedulesByMentorId(mentorId: number): Promise<MentorScheduleListRESP[]> {
    const mentor = await this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { id: mentorId },
      select: { id: true },
    });

    const schedules = (await this.transactionHost.tx.mentorSchedule.findMany(
      MentorScheduleClientListREQ.toFindMany(mentor.id),
    )) as MentorScheduleGetPayload[];

    return MentorScheduleListRESP.fromEntity(schedules);
  }

  async deleteScheduleById(accountId: number, scheduleId: number): Promise<void> {
    const mentor = await this.findMentorByAccountId(accountId);

    const numberOfDeleted = await this.transactionHost.tx
      .$executeRaw`DELETE FROM "mentor_schedules" WHERE id = ${scheduleId} AND "mentor_id" = ${mentor.id}`;

    if (numberOfDeleted <= 0) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_NOT_FOUND);
  }

  private checkOneHourFromStartTime(startTime: string, endTime: string): boolean {
    const hour1 = Number(startTime.split(':')[0] ?? 0) + Number(startTime.split(':')[1] ?? 0) / 60;
    const hour2 = Number(endTime.split(':')[0] ?? 0) + Number(endTime.split(':')[1] ?? 0) / 60;

    return hour2 - hour1 >= 1;
  }

  private async findMentorByAccountId(accountId: number) {
    return this.transactionHost.tx.mentor.findUniqueOrThrow({
      where: { accountId },
      select: { id: true },
    });
  }

  private async checkOverlapSchedule(mentorId: number, body: MentorClientScheduleCreateREQ) {
    const existedSchedules = await this.transactionHost.tx.mentorSchedule.findMany({
      where: { mentorId: mentorId, dayOfWeek: body.dayOfWeek },
      select: { id: true, startTime: true, endTime: true },
    });

    if (!isEmpty(existedSchedules)) {
      const isOverlap = existedSchedules.some((schedule) =>
        checkHourMinStartOverlap(schedule.startTime, schedule.endTime, body.startTime, body.endTime),
      );

      if (isOverlap) throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_OVERLAP);
    }
  }
}
</file>

<file path="src/domains/mentor/shared/enums.ts">
export enum MentorAdminListSortableFields {
  NAME = 'name',
  EMAIL = 'email',
  PHONE_NUMBER = 'phoneNumber',
  CREATED_AT = 'createdAt',
}
</file>

<file path="src/domains/mentor/shared/types.ts">
import { Prisma } from '@prisma/client';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';

export type MentorGetPayload = Prisma.MentorGetPayload<{
  include: {
    Account: true;
  };
}>;

export type MentorScheduleGetPayload = Prisma.MentorScheduleGetPayload<{
  include: {
    Course: true;
    Mentor: true;
  };
}>;

export type ProfileAchievementGetPayload = Prisma.ProfileAchievementGetPayload<unknown>;

export type MentorScheduleCourseDetail = Pick<CourseClientDetailRESP, 'id' | 'name' | 'description'>;
</file>

<file path="src/domains/mentor/mentor.module.ts">
import { Module } from '@nestjs/common';
import { MentorAdminModule } from './admin/mentor-admin.module';
import { MentorClientModule } from './client/mentor-client.module';

@Module({
  imports: [MentorClientModule, MentorAdminModule],
})
export class MentorModule {}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil Myliwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
