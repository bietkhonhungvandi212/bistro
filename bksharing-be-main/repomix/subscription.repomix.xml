This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T18:02:19.518Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  domains/
    subscription/
      client/
        subscription-client.controller.ts
        subscription-client.module.ts
        subscription-client.service.spec.ts
        subscription-client.service.ts
      dto/
        request/
          subscription-admin-list.request.ts
          subscription-create.request.ts
          subscription-mentor-approve.ts
          subscription-payment-create.ts
        response/
          subscription-admin-list.response.ts
          subscription-detail.response.ts
          subscription-list.response.ts
      helper/
        subcription-create.helper.ts
        subscription-approve.helper.ts
        subscription-common.helper.ts
        subscription-detail.helper.ts
        subscription-list.helper.ts
        subscription-make-payment.helper.ts
      shared/
        types.ts
      subscription-admin/
        subscription-admin.controller.spec.ts
        subscription-admin.controller.ts
        subscription-admin.module.ts
        subscription-admin.service.spec.ts
        subscription-admin.service.ts
      subscription.module.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/domains/subscription/client/subscription-client.controller.ts">
import { Body, Controller, Get, Param, ParseIntPipe, Patch, Post, Put, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { BaseResponse } from 'src/shared/generics/base.response';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionClientService } from './subscription-client.service';

@Controller('client/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
export class SubscriptionClientController {
  constructor(private readonly subscriptionClientService: SubscriptionClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByAccount(req.user);

    return BaseResponse.of(subscriptions);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number, @Req() req: AuthRequestDTO) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionClientService.getSubscriptionDetailWithAccount(
      req.user,
      id,
    );

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }

  @Patch(':id/cancel')
  @Roles(AccountType.STUDENT)
  async cancel(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) id: number) {
    await this.subscriptionClientService.cancel(req.user, id);

    return BaseResponse.ok();
  }

  @Get('mentors/:mentorId')
  @Roles(AccountType.STUDENT)
  async listByMentor(@Param('mentorId', ParseIntPipe) mentorId: number) {
    const subscriptions = await this.subscriptionClientService.listSubscriptionByMentorId(mentorId);

    return BaseResponse.of(subscriptions);
  }

  @Post('courses/:courseId')
  @Roles(AccountType.STUDENT)
  async createSubscription(
    @Req() req: AuthRequestDTO,
    @Param('courseId', ParseIntPipe) courseId: number,
    @Body() body: SubscriptionCreateREQ,
  ) {
    const subscription = await this.subscriptionClientService.create(req.user, courseId, body);

    return BaseResponse.of({ subscriptionId: subscription.id });
  }

  @Post(':id/payments')
  @Roles(AccountType.STUDENT)
  async createPayment(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) id: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.makePayment(req.user, id, {
      ...body,
      ipAddr: req.ip,
    });

    return BaseResponse.of(payment);
  }

  @Put(':id/payments')
  async continue(
    @Req() req: AuthRequestDTO,
    @Param('id', ParseIntPipe) subscriptionId: number,
    @Body() body: SubscriptionPaymentCreateREQ,
  ) {
    const payment = await this.subscriptionClientService.continue(req.user, subscriptionId, { ...body, ipAddr: req.ip });

    return BaseResponse.of(payment);
  }

  @Patch('approvement')
  @Roles(AccountType.MENTOR)
  async approveSubscription(@Req() req: AuthRequestDTO, @Body() body: SubscriptionMentorApproveREQ) {
    const subscriptionId = await this.subscriptionClientService.approve(req.user, body);

    return BaseResponse.of({ subscriptionId: subscriptionId });
  }
}
</file>

<file path="src/domains/subscription/client/subscription-client.module.ts">
import { forwardRef, Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { AudioCallModule } from 'src/domains/audio-call/audio-call.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { PaymentClientModule } from 'src/domains/payment/client/payment-client.module';
import { SubscriptionClientController } from './subscription-client.controller';
import { SubscriptionClientService } from './subscription-client.service';

@Module({
  imports: [forwardRef(() => MentorClientModule), AccountModule, PaymentClientModule, AudioCallModule],
  controllers: [SubscriptionClientController],
  providers: [SubscriptionClientService],
  exports: [SubscriptionClientService],
})
export class SubscriptionClientModule {}
</file>

<file path="src/domains/subscription/client/subscription-client.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionClientService } from './subscription-client.service';

describe('SubscriptionClientService', () => {
  let service: SubscriptionClientService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionClientService],
    }).compile();

    service = module.get<SubscriptionClientService>(SubscriptionClientService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/client/subscription-client.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { Cron } from '@nestjs/schedule';
import {
  AccountType,
  Course,
  CourseStatus,
  NotificationRelationType,
  NotificationType,
  PaymentStatus,
  RoomStatus,
  SubscriptionStatus,
} from '@prisma/client';
import { isEmpty } from 'lodash';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AudioCallService } from 'src/domains/audio-call/audio-call.service';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { NotificationHelper } from 'src/domains/notification/helper/notification-common.helper';
import { NotificationAppHandlerPayload, NotificationChannel } from 'src/domains/notification/shared/types';
import { PaymentClientService } from 'src/domains/payment/client/payment-client.service';
import { EventEmitterService } from 'src/services/event-emitter/event-emitter.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { DAY_OF_WEEK } from 'src/shared/constants/date.constant';
import { IS_ACTIVE_NESTED, TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import {
  EXPIRED_PENDING_SUBSCRIPTION,
  EXPIRED_SUBSCRIPTION_AFTER_APPROVED,
  SUBSCRIPTION_ACTIVE_STATUS,
  SUBSCRIPTION_NOT_CANCELED_STATUS,
  SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO,
} from 'src/shared/constants/subscription.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch, runFunctionWithCondition } from 'src/shared/helpers/common.helper';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { getDayOfWeek, parseDateToHyphen, parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';
import { SubscriptionPaymentCreateREQ } from '../dto/request/subscription-payment-create';
import { SubscriptionListRESP } from '../dto/response/subscription-list.response';
import { SubscriptionCreateHelper } from '../helper/subcription-create.helper';
import { SubscriptionApproveHelper } from '../helper/subscription-approve.helper';
import { parseBookingDateTimeToEpoch } from '../helper/subscription-common.helper';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionClientService {
  private readonly logger = new Logger(SubscriptionClientService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
    private readonly audioCallService: AudioCallService,
    private readonly eventEmitterService: EventEmitterService,
  ) {}

  @Cron('0 0 * * * *', {
    name: 'handle-expired-pending-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.PENDING },
      select: {
        mentorScheduleId: true,
        status: true,
        createdAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const createdAt = parseEpoch(subscription.createdAt);

        if (now - createdAt > EXPIRED_PENDING_SUBSCRIPTION) {
          this.logger.warn(
            `ðŸš€ ~ SubscriptionClientService ~ Cron ~ handleExpiredSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because mentor not reponse after 2 days`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: { status: SubscriptionStatus.EXPIRED, canceledAt: nowEpoch() },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 * * * *', {
    name: 'handle-expired-paid-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleExpiredApprovedSubscription() {
    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { status: SubscriptionStatus.ACCEPTED },
      select: {
        mentorScheduleId: true,
        status: true,
        approvedAt: true,
        id: true,
      },
    });

    if (isEmpty(subscriptions)) return;

    await Promise.all(
      subscriptions.map(async (subscription) => {
        const now = nowEpoch();
        const approvedAt = parseEpoch(subscription.approvedAt);

        if (now - approvedAt > EXPIRED_SUBSCRIPTION_AFTER_APPROVED) {
          this.logger.warn(
            `ðŸš€ ~ SubscriptionClientService ~ Cron ~ handleExpiredApprovedSubscription ~ subscription with ${subscription.id} was canceled at ${parseEpochToDate(nowEpoch())} because student not paid after 1 day`,
          );

          const updatedSubscription = await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.EXPIRED,
              Payment: { update: { status: PaymentStatus.EXPIRED } },
              canceledAt: nowEpoch(),
            },
            select: { id: true, accountId: true, Course: { select: { creatorId: true } }, status: true },
          });

          for (const accountId of [updatedSubscription.accountId, updatedSubscription.Course.creatorId]) {
            const payload = NotificationHelper.makeAppNotificationPayload(
              { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
              accountId,
              NotificationType.SUBSCRIPTION_EXPIRED,
            );
            runFunctionWithCondition(!!updatedSubscription, () => {
              this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
            });
          }
        }
      }),
    );
  }

  @Cron('0 0 0 * * *', {
    name: 'handle-suspended-course-subscription',
    timeZone: 'Asia/Ho_Chi_Minh',
  })
  async handleSuspendedCourseSubscription() {
    const courses = await this.transactionHost.tx.course.findMany({
      where: { status: CourseStatus.SUSPENDED, ...IS_ACTIVE_NESTED },
      select: { id: true, status: true },
    });

    await Promise.all(
      courses.map(async (course) => {
        const subscriptions = await this.transactionHost.tx.subscription.findMany({
          where: { courseId: course.id, status: SubscriptionStatus.ACTIVE, ...IS_ACTIVE_NESTED },
          select: { id: true, audioRoomId: true, Payment: { select: { id: true } } },
        });

        for (const subscription of subscriptions) {
          await this.transactionHost.tx.subscription.update({
            where: { id: subscription.id },
            data: {
              status: SubscriptionStatus.CANCELED,
              canceledAt: nowEpoch(),
              AudioRoom: { update: { status: RoomStatus.FINISHED } },
              Payment: { update: { status: PaymentStatus.REFUNDED } },
            },
            select: { id: true },
          });

          //TODO: Refund money to student
        }
      }),
    );
  }

  async listSubscriptionByAccount(user: AuthUserDTO) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(SubscriptionListHelper.toFindManyWithAccount(user));

    return Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData =
          user.accountType !== AccountType.MENTOR
            ? await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId)
            : null;

        return SubscriptionListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          orNullWithCondition(!!subscription.AudioRoom, {
            status: subscription.AudioRoom?.status,
            cid: subscription.AudioRoom?.cid,
          }),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );
  }

  async listSubscriptionByMentorId(mentorId: number) {
    const { mentor } = await this.mentorClientService.detail(mentorId);

    const subscriptions = await this.transactionHost.tx.subscription.findMany({
      where: { Course: { creatorId: mentor.accountId }, status: { in: SUBSCRIPTION_ACTIVE_STATUS } },
      select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true, status: true },
    });

    return subscriptions.map((subscription) => {
      return {
        id: subscription.id,
        status: subscription.status,
        courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
        courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      };
    });
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async create(user: AuthUserDTO, courseId: number, body: SubscriptionCreateREQ): Promise<any> {
    const course = (await this.transactionHost.tx.course.findUniqueOrThrow({
      where: { id: courseId },
      select: { id: true, startDate: true, endDate: true, price: true, creatorId: true },
    })) as Course;

    const existedSubscriptions = (await this.transactionHost.tx.subscription.findMany(
      SubscriptionCreateHelper.toFindManyByAccountId(user.accountId),
    )) as SubscriptionGetPlayload[];

    // 1. Check for active subscription by the user for the same course
    const existedAccountSubscriptions = existedSubscriptions.filter((subscription) => subscription.Course.id === course.id);

    if (!isEmpty(existedAccountSubscriptions) && SUBSCRIPTION_ACTIVE_STATUS.includes(existedAccountSubscriptions[0]?.status)) {
      this.logger.error(`ðŸš€ ~ SubscriptionClientService ~ create ~ there are same courses subscribed which are ACTIVE`);
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_FOR_THIS_COURSE_STILL_ACTIVE);
    } else if (!isEmpty(existedAccountSubscriptions)) {
      //TODO: Uncomment this code when the feature is ready
      // const now = nowEpoch();
      // const lastSubscriptionInActive =
      //   parseEpoch(existedAccountSubscriptions[0].rejectedAt) || parseEpoch(existedAccountSubscriptions[0].canceledAt);
      //
      // const isStillBanned = now - lastSubscriptionInActive > EXPIRED_PENDING_SUBSCRIPTION;
      // if (lastSubscriptionInActive && isStillBanned) {
      //   this.logger.log(
      //     `ðŸš€ ~ SubscriptionClientService ~ create ~ the user with account id ${user.accountId} can not subscribe to this course with course id ${course.id}`,
      //   );
      //   throw new ActionFailedException(ActionFailed.SUBSRIPTION_NOT_ALLOW_NEXT_7_DAYS);
      // }
    }

    // 2. Check for mentor schedule conflicts
    const schedule = await this.transactionHost.tx.mentorSchedule.findFirstOrThrow({
      where: { id: body.mentorScheduleId, Mentor: { Account: { id: course.creatorId } } },
    });

    const conflictSchedule = await this.transactionHost.tx.subscription.findFirst({
      where: {
        status: { in: SUBSCRIPTION_ACTIVE_STATUS },
        mentorScheduleId: body.mentorScheduleId,
        courseAccessStartAt: parseBookingDateTimeToEpoch(body.date, schedule.startTime),
      },
      select: { id: true },
    });

    // Check if schedule is already booked
    if (conflictSchedule) {
      this.logger.error(
        `ðŸš€ ~ SubscriptionClientService ~ create ~ This schedule has been booked with the subscription id ${conflictSchedule.id}`,
      );
      throw new ActionFailedException(ActionFailed.MENTOR_SCHEDULE_IS_BOOKED);
    }

    //3. Check for overlapping subscriptions with other mentors
    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const isNotMentorSubscriptionActive = existedSubscriptions.some((subscription) => {
      if (
        SUBSCRIPTION_ACTIVE_STATUS.includes(subscription.status) &&
        subscription.Course.creatorId !== course.creatorId &&
        Number(parseEpoch(subscription.courseAccessStartAt)) === courseAccessStartAt
      ) {
        this.logger.error(
          `ðŸš€ ~ SubscriptionClientService ~ isNotMentorSubscriptionActive ~ This subscription has been scheduled overlap with the subscription id ${subscription.id} and the course id ${subscription.Course.id}`,
        );
        return true;
      }
    });

    if (isNotMentorSubscriptionActive) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_ACTIVE_OVERLAP_SCHEDULE);
    }

    const parsedDate = parseDateToHyphen(body.date);
    const dayOfWeek = getDayOfWeek(parsedDate);
    this.logger.log(`ðŸš€ ~ SubscriptionClientService ~ create ~ the date ${body.date} is ${DAY_OF_WEEK[dayOfWeek]}`);
    this.logger.log(`ðŸš€ ~ SubscriptionClientService ~ create ~ the schedule day is ${schedule.dayOfWeek}`);

    if (schedule.dayOfWeek !== DAY_OF_WEEK[dayOfWeek]) {
      throw new ActionFailedException(
        ActionFailed.MENTOR_SCHEDULE_NOT_HAVE_SAME_DAY_OF_WEEK,
        `the schedule day is ${schedule.dayOfWeek} but you choose ${DAY_OF_WEEK[dayOfWeek]}`,
      );
    }

    const subscription = await this.transactionHost.tx.subscription.create(
      SubscriptionCreateHelper.toCreate(user, course, schedule, body),
    );

    //Notification: send notification to mentor
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: subscription.id, type: NotificationRelationType.SUBSCRIPTION },
      course.creatorId,
      NotificationType.SUBSCRIPTION_CREATED,
    );
    runFunctionWithCondition(!!subscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return subscription;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async approve(courseCreator: AuthUserDTO, body: SubscriptionMentorApproveREQ) {
    await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      select: { id: true },
    });

    const updatedSubscription = await this.transactionHost.tx.subscription.update(
      SubscriptionApproveHelper.toApprove(body, courseCreator),
    );

    //Notification: send notification to student
    const payload = NotificationHelper.makeAppNotificationPayload(
      { id: updatedSubscription.id, type: NotificationRelationType.SUBSCRIPTION },
      updatedSubscription.accountId,
      body.isApproved ? NotificationType.SUBSCRIPTION_APPROVED : NotificationType.SUBSCRIPTION_REJECTED,
    );
    runFunctionWithCondition(!!updatedSubscription, () => {
      this.eventEmitterService.emit<NotificationAppHandlerPayload>(NotificationChannel.APP, payload);
    });

    return updatedSubscription.id;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async makePayment(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { originalPrice: true, status: true, accountId: true },
    })) as SubscriptionGetPlayload;

    if (subscription.status !== SubscriptionStatus.ACCEPTED)
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_MAKE_PAYMENT,
        `Subscription status is ${subscription.status}`,
      );

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const { payment, url } = await this.paymentClientService.create(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  async continue(user: AuthUserDTO, subscriptionId: number, body: SubscriptionPaymentCreateREQ) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: { id: true, originalPrice: true, status: true, accountId: true, approvedAt: true },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    const now = nowEpoch();
    if (
      now - parseEpoch(subscription.approvedAt) > EXPIRED_SUBSCRIPTION_AFTER_APPROVED ||
      subscription.status === SubscriptionStatus.EXPIRED
    ) {
      this.logger.warn(
        `ðŸš€ ~ PaymentClientService ~ verify ~ Subscription ${subscription.id} expired because not make payment after approved around 1 day`,
      );

      // throw new ActionFailedException(ActionFailed.SUBSCRIPTION_EXPIRED_AS_NOT_MAKE_PAYMENT);
    } else if (subscription.status !== SubscriptionStatus.ACCEPTED) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_AVAILABLE);
    }

    const { payment, url } = await this.paymentClientService.continue(
      {
        subscriptionId: subscriptionId,
        amount: Number(subscription.originalPrice),
        description: body.message,
      },
      body.ipAddr,
    );

    return { payment, url };
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancel(user: AuthUserDTO, subscriptionId: number) {
    const subscription = await this.transactionHost.tx.subscription.findUniqueOrThrow({
      where: { id: subscriptionId },
      select: {
        status: true,
        accountId: true,
        mentorScheduleId: true,
        audioRoomId: true,
        Course: { select: { creatorId: true } },
      },
    });

    if (subscription.accountId !== user.accountId) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);

    if (SUBSCRIPTION_NOT_CANCELED_STATUS.includes(subscription.status)) {
      throw new ActionFailedException(
        ActionFailed.SUBSCRIPTION_NOT_CANCEL,
        `Subscription status in ${SUBSCRIPTION_NOT_CANCELED_STATUS} can not be canceled`,
      );
    }

    if (SUBSCRIPTION_STATUS_CANCEL_CALL_AUDIO.includes(subscription.status)) {
      await this.audioCallService.cancelCall(subscription.audioRoomId);
    }

    await this.transactionHost.tx.subscription.update({
      where: { id: subscriptionId },
      data: {
        status: subscription.status === SubscriptionStatus.ACTIVE ? SubscriptionStatus.ENDED : SubscriptionStatus.CANCELED,
        canceledAt: nowEpoch(),
      },
    });
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetailWithAccount(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    if (subscription.Account.id !== user.accountId && user.accountType === AccountType.STUDENT) {
      throw new ActionFailedException(ActionFailed.SUBSCRIPTION_NOT_BELONG_TO_USER);
    } else if (subscription.Course.creatorId !== user.accountId && user.accountType === AccountType.MENTOR) {
      throw new ActionFailedException(ActionFailed.COURSE_NOT_BELONG_TO_THIS_ACCOUNT);
    }

    return { subscription, mentorData, studentInfo };
  }

  async detail(user: AuthUserDTO, subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUniqueWithAccount(user, subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/dto/request/subscription-admin-list.request.ts">
import { SubscriptionStatus, WageStatus } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { NameValidator } from 'src/shared/request-validator/account.validator';

export class SubscriptionAdminListREQ extends PaginationREQ {
  @NameValidator()
  @IsOptional()
  mentorName?: string;

  @NameValidator()
  @IsOptional()
  courseName?: string;

  @NameValidator()
  @IsOptional()
  studentName?: string;

  @IsEnum(SubscriptionStatus)
  @IsOptional()
  status?: SubscriptionStatus;

  @IsEnum(WageStatus)
  @IsOptional()
  wageStatus?: WageStatus;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-create.request.ts">
import { IsOptional, IsString, MaxLength } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';
import { OnlyDate } from 'src/shared/request-validator/only-date.request-validator';

export class SubscriptionCreateREQ {
  @OnlyDate()
  date: string;

  @IdValidator()
  mentorScheduleId: number;

  @IsString()
  @MaxLength(500)
  message: string;

  @IsString()
  @IsOptional()
  ipAddr: string;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-mentor-approve.ts">
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class SubscriptionMentorApproveREQ {
  @IdValidator()
  subscriptionId: number;

  @BooleanValidator()
  isApproved: boolean;
}
</file>

<file path="src/domains/subscription/dto/request/subscription-payment-create.ts">
import { IsOptional, IsString } from 'class-validator';

export class SubscriptionPaymentCreateREQ {
  @IsString()
  message: string;

  @IsString()
  @IsOptional()
  ipAddr?: string;
}
</file>

<file path="src/domains/subscription/dto/response/subscription-admin-list.response.ts">
import { SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { SubscriptionMentorListRESP } from '../../shared/types';

export class SubscriptionAdminListRESP {
  id: string;
  status: SubscriptionStatus;
  wageStatus: SubscriptionStatus;
  originalPrice: number;
  courseAccessStartAt: Date;
  courseAccessEndAt: Date;
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  course: { id: number; name: string };

  static fromEntity(
    subscription: any,
    studentInfo: AccountRESP,
    mentorInfo: SubscriptionMentorListRESP,
  ): SubscriptionAdminListRESP {
    return {
      id: subscription.id,
      status: subscription.status,
      wageStatus: subscription.wageStatus,
      originalPrice: subscription.originalPrice,
      courseAccessStartAt: parseEpoch(subscription.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(subscription.courseAccessEndAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      course: { id: subscription.Course.id, name: subscription.Course.name },
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-detail.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus, WageStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { CourseClientDetailRESP } from 'src/domains/course/client/response/course-client-detail.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { MentorGetPayload } from 'src/domains/mentor/shared/types';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionGetPlayload, SubscriptionReportRESP } from '../../shared/types';

export class SubscriptionDetailRESP {
  id: number;
  status: SubscriptionStatus;
  wageStatus: WageStatus;
  orginalPrice: number;
  message: string;
  courseAccessStartAt: number;
  courseAccessEndAt: number;
  course: Pick<CourseClientDetailRESP, 'id' | 'name' | 'status' | 'description'>;
  mentor: Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;
  student: AccountRESP;
  audiCall?: { status: RoomStatus; cid: string };
  report?: SubscriptionReportRESP;
  payment?: { status: PaymentStatus; price: number };

  static fromEntity(
    e: SubscriptionGetPlayload,
    mentor: MentorGetPayload,
    student: AccountRESP,
    thumbnail?: ImageRESP,
  ): SubscriptionDetailRESP {
    return {
      id: e.id,
      status: e.status,
      wageStatus: e.wageStatus,
      orginalPrice: parseDecimalNumber(e.originalPrice),
      message: e.message,
      courseAccessStartAt: parseEpoch(e.courseAccessStartAt),
      courseAccessEndAt: parseEpoch(e.courseAccessEndAt),
      course: { id: e.Course.id, name: e.Course.name, status: e.Course.status, description: e.Course.description },
      mentor: { id: mentor.id, accountId: mentor.accountId, name: mentor.Account.name, thumbnail: thumbnail },
      payment: orNullWithCondition(!!e.Payment, {
        status: e.Payment?.status,
        price: parseDecimalNumber(e.Payment?.price),
      }),
      audiCall: orNullWithCondition(!!e.AudioRoom, {
        status: e.AudioRoom?.status,
        cid: e.AudioRoom?.cid,
      }),
      report: orNullWithCondition(!!e.Report, {
        id: e.Report?.id,
        type: e.Report?.type,
        description: e.Report?.description,
        status: e.Report?.status,
        resolution: e.Report?.resolution,
      }),
      student: student,
    };
  }
}
</file>

<file path="src/domains/subscription/dto/response/subscription-list.response.ts">
import { PaymentStatus, RoomStatus, SubscriptionStatus } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { parseDecimalNumber, parseEpoch } from 'src/shared/parsers/common.parser';
import { orNullWithCondition } from 'src/shared/parsers/io.parser';
import {
  SubscriptionFeedbackRESP,
  SubscriptionGetPlayload,
  SubscriptionMentorListRESP,
  SubscriptionReportRESP,
} from '../../shared/types';

export class SubscriptionListRESP {
  id: number;
  status: SubscriptionStatus;
  originalPrice: number;
  courseStartAt: string;
  courseEndAt: string;
  course: { id: number; name: string };
  mentorInfo: SubscriptionMentorListRESP;
  studentInfo: AccountRESP;
  audiCall: { status: RoomStatus; cid: string };
  payment?: { id: true; status: PaymentStatus; price: number };
  feedback?: SubscriptionFeedbackRESP;
  report?: SubscriptionReportRESP;
  canceledAt?: string;
  approvedAt?: string;
  rejectedAt?: string;

  static fromEntity(
    subcription: SubscriptionGetPlayload,
    studentInfo: AccountRESP,
    audiCall: { status: RoomStatus; cid: string },
    mentorInfo?: SubscriptionMentorListRESP,
  ): SubscriptionListRESP {
    return {
      id: subcription.id,
      status: subcription.status,
      originalPrice: parseDecimalNumber(subcription.originalPrice),
      courseStartAt: parseEpoch(subcription.courseAccessStartAt),
      courseEndAt: parseEpoch(subcription.courseAccessEndAt),
      canceledAt: parseEpoch(subcription.canceledAt),
      approvedAt: parseEpoch(subcription.approvedAt),
      rejectedAt: parseEpoch(subcription.rejectedAt),
      studentInfo: studentInfo,
      mentorInfo: mentorInfo,
      report: orNullWithCondition(!!subcription.Report, {
        id: subcription.Report?.id,
        type: subcription.Report?.type,
        description: subcription.Report?.description,
        status: subcription.Report?.status,
        resolution: subcription.Report?.resolution,
      }),
      course: { id: subcription.Course.id, name: subcription.Course.name },
      audiCall: audiCall,
      payment: orNullWithCondition(!!subcription.Payment, {
        id: subcription.Payment?.id,
        status: subcription.Payment?.status,
        price: parseDecimalNumber(subcription.Payment?.price),
      }),
      feedback: orNullWithCondition(!!subcription.Feedback, {
        id: subcription.Feedback?.id,
        courseRating: subcription.Feedback?.courseRating,
        mentorRating: subcription.Feedback?.mentorRating,
        courseReview: subcription.Feedback?.courseReview,
        mentorReview: subcription.Feedback?.mentorReview,
      }),
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subcription-create.helper.ts">
import {
  Course,
  MentorSchedule,
  NotificationRelationType,
  NotificationScope,
  NotificationType,
  Prisma,
  Subscription,
  SubscriptionStatus,
} from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { NotificationAppHandlerPayload } from 'src/domains/notification/shared/types';
import { getNotificationMessage } from 'src/shared/constants/notification.constant';
import { SortOrder } from 'src/shared/enums/query.enum';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { SubscriptionCreateREQ } from '../dto/request/subscription-create.request';
import { parseBookingDateTimeToEpoch } from './subscription-common.helper';

export class SubscriptionCreateHelper {
  static toCreate(
    user: AuthUserDTO,
    course: Course,
    schedule: MentorSchedule,
    body: SubscriptionCreateREQ,
  ): Prisma.SubscriptionCreateArgs {
    if (!course) return;

    const courseAccessStartAt = parseBookingDateTimeToEpoch(body.date, schedule.startTime);
    const courseAccessEndAt = parseBookingDateTimeToEpoch(body.date, schedule.endTime);

    return {
      data: {
        message: body.message,
        originalPrice: course.price,
        status: SubscriptionStatus.PENDING,
        courseAccessEndAt: courseAccessEndAt,
        courseAccessStartAt: courseAccessStartAt,
        Course: connectRelation(course.id),
        Account: connectRelation(user.accountId),
        MentorSchedule: connectRelation(body.mentorScheduleId),
      },
      select: { id: true },
    };
  }

  static toFindMany(courseId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Course: { id: courseId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toFindManyByAccountId(accountId: number): Prisma.SubscriptionFindManyArgs {
    return {
      where: { Account: { id: accountId } },
      select: {
        id: true,
        accountId: true,
        status: true,
        createdAt: true,
        canceledAt: true,
        rejectedAt: true,
        mentorScheduleId: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true } },
      },
      orderBy: { createdAt: SortOrder.DESC },
    };
  }

  static toCreateNotification(subcription: Subscription, targetAccountId: number): NotificationAppHandlerPayload {
    return {
      notificationREQ: {
        relationId: subcription.id,
        relationType: NotificationRelationType.SUBSCRIPTION,
        type: NotificationType.SUBSCRIPTION_CREATED,
        scopes: [NotificationScope.INDIVIDUAL],
        targetAccountId: targetAccountId,
      },
      data: {
        title: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).title,
        topic: NotificationType.SUBSCRIPTION_CREATED,
        body: getNotificationMessage(NotificationType.SUBSCRIPTION_CREATED).content,
      },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-approve.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { SubscriptionMentorApproveREQ } from '../dto/request/subscription-mentor-approve';

export class SubscriptionApproveHelper {
  static toApprove(body: SubscriptionMentorApproveREQ, courseCreator: AuthUserDTO): Prisma.SubscriptionUpdateArgs {
    const timeUpdate = body.isApproved ? { approvedAt: nowEpoch() } : { rejectedAt: nowEpoch() };

    return {
      where: { id: body.subscriptionId, Course: { creatorId: courseCreator.accountId } },
      data: {
        status: body.isApproved ? SubscriptionStatus.ACCEPTED : SubscriptionStatus.REJECTED,
        ...timeUpdate,
      },
      select: { id: true, accountId: true, status: true },
    };
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-common.helper.ts">
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { parseDateTimeToEpochV2 } from 'src/shared/parsers/datetime.parse';

export const parseBookingDateTimeToEpoch = (date: string, time: string) => {
  const [day, month, year] = date.split('/');
  const [hour, minute] = time.split(':');

  if (!time) throw new ActionFailedException(ActionFailed.DATE_TIME_INVALID);

  const dateAfterParse = new Date(`${year}-${month}-${day}T${hour}:${minute}:00.00Z`);

  const epoch = parseDateTimeToEpochV2(dateAfterParse.toISOString());

  const now = Date.now();

  if (epoch < now) throw new ActionFailedException(ActionFailed.SUBSCRIPTION_DATE_REGISTERED_MUST_AFTER_NOW);

  return epoch;
};

export const compareDateFromEpoch = (epoch1: number, epoch2: number) => {
  const date1 = new Date(epoch1);
  const date2 = new Date(epoch2);

  return (
    date1.getDate() === date2.getDate() && date1.getMonth() === date2.getMonth() && date1.getFullYear() === date2.getFullYear()
  );
};
</file>

<file path="src/domains/subscription/helper/subscription-detail.helper.ts">
import { AccountType, Prisma, ReportStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class SubscriptionDetailHelper {
  static toFindUnique(subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: { select: { id: true, type: true, description: true, status: true, resolution: true } },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindUniqueWithAccount(user: AuthUserDTO, subscriptionId: number): Prisma.SubscriptionFindUniqueArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: { id: subscriptionId },
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        message: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, creatorId: true, name: true, status: true, description: true } },
        Account: { select: { id: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true },
        },
        Payment: { select: { status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
      },
    };
  }

  static toFindByAccount(user: AuthUserDTO, id: number): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT:
        return {
          accountId: user.accountId,
          id: id,
        };

      case AccountType.MENTOR:
        return {
          Course: {
            creatorId: user.accountId,
          },
          id: id,
        };
      case AccountType.ADMIN:
        return {};
      default:
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-list.helper.ts">
import { AccountType, Prisma, ReportStatus } from '.prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { leanObject, parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';

export class SubscriptionListHelper {
  static toFindMany(): Prisma.SubscriptionFindManyArgs {
    return {
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs {
    const reportCondition =
      user.accountType === AccountType.MENTOR
        ? {
            where: { status: ReportStatus.RESOLVED },
          }
        : undefined;

    return {
      where: SubscriptionListHelper.toFilterByAccount(user),
      select: {
        id: true,
        status: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        canceledAt: true,
        approvedAt: true,
        rejectedAt: true,
        Course: { select: { id: true, name: true, creatorId: true } },
        Payment: { select: { id: true, status: true, price: true } },
        AudioRoom: { select: { status: true, cid: true } },
        Report: {
          ...reportCondition,
          select: { id: true, type: true, description: true, status: true, resolution: true, createdAt: true },
        },
        Feedback: { select: { id: true, courseRating: true, mentorRating: true, courseReview: true, mentorReview: true } },
        Account: { select: { id: true } },
      },
    };
  }

  static toFindManyWithCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs {
    const condition = SubscriptionListHelper.toFilterByCondition(query);
    return {
      where: condition,
      ...QueryPagingHelper.queryPaging(query),
      orderBy: defaultSortDesc,
      select: {
        id: true,
        status: true,
        wageStatus: true,
        originalPrice: true,
        courseAccessStartAt: true,
        courseAccessEndAt: true,
        Account: { select: { id: true, name: true } },
        Course: { select: { id: true, name: true, Creator: { select: { id: true, name: true } } } },
      },
    };
  }

  static toFilterByCondition(query: SubscriptionAdminListREQ): Prisma.SubscriptionFindManyArgs['where'] {
    const studentName = orUndefinedWithCondition(!!query.studentName, {
      Account: parsePrismaSearch('name', query.studentName),
    });

    const mentorName = orUndefinedWithCondition(!!query.mentorName, {
      Course: {
        Creator: parsePrismaSearch('name', query.mentorName),
      },
    });

    const courseName = orUndefinedWithCondition(!!query.courseName, {
      Course: parsePrismaSearch('name', query.courseName),
    });

    return leanObject({
      ...studentName,
      ...mentorName,
      ...courseName,
      status: query.status,
      wageStatus: query.wageStatus,
    });
  }

  static toFilterByAccount(user: AuthUserDTO): Prisma.SubscriptionFindManyArgs['where'] {
    switch (user.accountType) {
      case AccountType.STUDENT: {
        return { accountId: user.accountId };
      }
      case AccountType.MENTOR: {
        return {
          Course: { creatorId: user.accountId },
        };
      }
      default:
        return;
    }
  }
}
</file>

<file path="src/domains/subscription/helper/subscription-make-payment.helper.ts">
import { Prisma, SubscriptionStatus } from '@prisma/client';
import { Nil } from 'src/shared/generics/type.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseEpochToDate } from 'src/shared/parsers/datetime.parse';
import { orUndefinedWithCondition } from 'src/shared/parsers/io.parser';

export class SubscriptionMakePaymentHelper {
  static toActivate(
    subscriptionId: number,
    subscriptionStatus: SubscriptionStatus,
    callId: number,
  ): Prisma.SubscriptionUpdateArgs {
    const audioRoom = orUndefinedWithCondition(subscriptionStatus === SubscriptionStatus.ACTIVE, {
      AudioRoom: connectRelation(callId),
    });

    return {
      where: { id: subscriptionId },
      data: { status: subscriptionStatus, ...audioRoom },
      select: { id: true },
    };
  }

  static parseAudioCallStartsAt(epoch: Nil<number>): string {
    if (!epoch) return;
    const [year, month, day, hour, minute, second] = parseEpochToDate(epoch)
      .split(/[-:\s]/)
      .map((value) => parseInt(value, 10));

    console.log(year, month, day, hour, minute, second); // Output: 2024 12 16 19 0 0

    // parse date time in this format DD/MM/YY to YYYY-MM-dd
    const parsedDate = `${day}/${month}/${year} ${hour}:${minute}:${second}`;
    return parsedDate;
  }
}
</file>

<file path="src/domains/subscription/shared/types.ts">
import { Prisma } from '@prisma/client';
import { FeedbackListRESP } from 'src/domains/feedback/response/feedback-list.response';
import { MentorClientDetailRESP } from 'src/domains/mentor/admin/response/mentor-client-detail.response';
import { ReportDetailRESP } from 'src/domains/report/response/report-detail.response';

export type SubscriptionGetPlayload = Prisma.SubscriptionGetPayload<{
  include: { Course: true; Account: true; Payment: true; AudioRoom: true; Feedback: true; Report: true };
}>;

export type SubscriptionMentorListRESP = Pick<MentorClientDetailRESP, 'id' | 'name' | 'thumbnail' | 'accountId'>;

export type SubscriptionFeedbackRESP = Pick<
  FeedbackListRESP,
  'id' | 'courseRating' | 'mentorRating' | 'courseReview' | 'mentorReview'
>;

export type SubscriptionReportRESP = Pick<ReportDetailRESP, 'id' | 'type' | 'description' | 'status' | 'resolution'>;
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminController', () => {
  let controller: SubscriptionAdminController;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [SubscriptionAdminController],
      providers: [SubscriptionAdminService],
    }).compile();

    controller = module.get<SubscriptionAdminController>(SubscriptionAdminController);
  });

  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionDetailRESP } from '../dto/response/subscription-detail.response';
import { SubscriptionAdminService } from './subscription-admin.service';

@Controller('admin/subscriptions')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class SubscriptionAdminController {
  constructor(private readonly subscriptionAdminService: SubscriptionAdminService) {}

  @Get()
  async listSubscription(@Query() query: SubscriptionAdminListREQ) {
    const { subscriptionDtos, count } = await this.subscriptionAdminService.listSubscription(query);

    return PaginationResponse.ofWithTotal(subscriptionDtos, count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) id: number) {
    const { subscription, mentorData, studentInfo } = await this.subscriptionAdminService.getSubscriptionDetail(id);

    return SubscriptionDetailRESP.fromEntity(
      subscription,
      mentorData.mentor,
      AccountRESP.fromEntity(
        {
          ...studentInfo.account,
          dob: String(studentInfo.account.dob),
        },
        studentInfo.thumbnail,
      ),
      mentorData.thumbnail,
    );
  }
}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.module.ts">
import { Module } from '@nestjs/common';
import { AccountModule } from 'src/domains/accounts/accounts.module';
import { MentorClientModule } from 'src/domains/mentor/client/mentor-client.module';
import { SubscriptionAdminController } from './subscription-admin.controller';
import { SubscriptionAdminService } from './subscription-admin.service';

@Module({
  imports: [AccountModule, MentorClientModule],
  controllers: [SubscriptionAdminController],
  providers: [SubscriptionAdminService],
})
export class SubscriptionAdminModule {}
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { SubscriptionAdminService } from './subscription-admin.service';

describe('SubscriptionAdminService', () => {
  let service: SubscriptionAdminService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [SubscriptionAdminService],
    }).compile();

    service = module.get<SubscriptionAdminService>(SubscriptionAdminService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/subscription/subscription-admin/subscription-admin.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import { AccountService } from 'src/domains/accounts/account.service';
import { AccountRESP } from 'src/domains/accounts/response/account.response';
import { MentorClientService } from 'src/domains/mentor/client/mentor-client.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { SubscriptionAdminListREQ } from '../dto/request/subscription-admin-list.request';
import { SubscriptionAdminListRESP } from '../dto/response/subscription-admin-list.response';
import { SubscriptionDetailHelper } from '../helper/subscription-detail.helper';
import { SubscriptionListHelper } from '../helper/subscription-list.helper';
import { SubscriptionGetPlayload } from '../shared/types';

@Injectable()
export class SubscriptionAdminService {
  private readonly logger = new Logger(SubscriptionAdminService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    // private readonly paymentClientService: PaymentClientService,
    private readonly mentorClientService: MentorClientService,
    private readonly accountService: AccountService,
  ) {}

  async listSubscription(query: SubscriptionAdminListREQ) {
    const subscriptions = await this.transactionHost.tx.subscription.findMany(
      SubscriptionListHelper.toFindManyWithCondition(query),
    );

    const count = await this.transactionHost.tx.subscription.count({
      where: SubscriptionListHelper.toFilterByCondition(query),
    });

    const subscriptionDtos = await Promise.all(
      subscriptions.map(async (subscription: SubscriptionGetPlayload) => {
        const studentInfo = await this.accountService.getMe(subscription.Account.id);

        const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);

        return SubscriptionAdminListRESP.fromEntity(
          subscription,
          AccountRESP.fromEntity(
            {
              ...studentInfo.account,
              dob: String(studentInfo.account.dob),
            },
            studentInfo.thumbnail,
          ),
          {
            id: mentorData?.mentor.id,
            accountId: mentorData?.mentor.accountId,
            name: mentorData?.mentor.Account.name,
            thumbnail: mentorData?.thumbnail,
          },
        );
      }),
    );

    return { subscriptionDtos, count };
  }

  /**
   * Get subscription details
   */
  async getSubscriptionDetail(subscriptionId: number) {
    const subscription = (await this.transactionHost.tx.subscription.findUniqueOrThrow(
      SubscriptionDetailHelper.toFindUnique(subscriptionId),
    )) as SubscriptionGetPlayload;

    const mentorData = await this.mentorClientService.getMentorByAccountId(subscription.Course.creatorId);
    const studentInfo = await this.accountService.getMe(subscription.Account.id);

    return { subscription, mentorData, studentInfo };
  }
}
</file>

<file path="src/domains/subscription/subscription.module.ts">
import { Module } from '@nestjs/common';
import { SubscriptionClientModule } from './client/subscription-client.module';
import { SubscriptionAdminModule } from './subscription-admin/subscription-admin.module';

@Module({
  imports: [SubscriptionClientModule, SubscriptionAdminModule],
})
export class SubscriptionModule {}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil MyÅ›liwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
