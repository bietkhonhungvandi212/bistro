This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-18T18:04:07.387Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
- Pay special attention to the Repository Description. These contain important context and guidelines specific to this project.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>
<user_provided_header>
Custom header information for the packed file.
</user_provided_header>

For more information about Repomix, visit: https://github.com/yamadashy/repomix
</additional_info>

</file_summary>

<repository_structure>
src/
  domains/
    audio-call/
      admin/
        dto/
          audio-call-admin-detail.dto.ts
          participant-dto.ts
        request/
          audio-call-admin-create.request.ts
          audio-call-admin-list.request.ts
        response/
          audio-call-admin-detail.response.ts
          audio-call-admin-list.response.ts
        audio-call-admin.controller.ts
        audio-call-admin.module.ts
        audio-call-admin.service.ts
      base/
        audio-call-list-base.request.ts
      client/
        request/
          audio-call-client-list.request.ts
        audio-call-client.controller.ts
        audio-call-client.module.ts
        audio-call-client.service.ts
      dto/
        audio-call-end.dto.ts
        audio-call-join.dto.ts
        audio-call-start.dto.ts
      response/
        audio-call-participant-history.response.ts
      shared/
        helpers.ts
        types.ts
      audio-call.controller.ts
      audio-call.gateway.ts
      audio-call.module.ts
      audio-call.service.spec.ts
      audio-call.service.ts
README.md
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="src/domains/audio-call/admin/dto/audio-call-admin-detail.dto.ts">
import { AudioRoomType, Prisma, RoomStatus } from '@prisma/client';

export class AudioCallAdminDetailDTO {
  id: number;
  name: string;
  title: string;
  cid: string;
  status: RoomStatus;
  type: AudioRoomType;
  startsAt: string;
  roomUrl: string;
  duration: string;
  isPublic: boolean;
  creator: { id: number; name: string };
  custom: Record<string, any>;

  static toFindFirst(roomId: number): Prisma.AudioRoomFindFirstOrThrowArgs {
    return {
      where: { id: roomId },
      select: {
        id: true,
        title: true,
        cid: true,
        status: true,
        isPublic: true,
        type: true,
        startsAt: true,
        roomUrl: true,
        duration: true,
        Creator: { select: { id: true, name: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/dto/participant-dto.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { IsEnum, IsOptional } from 'class-validator';
import { IdValidator } from 'src/shared/request-validator/id.validator';

export class AudioRoomParticipantDTO {
  @IdValidator()
  accountId: number;

  @IsEnum(ParticipantAudioRoomRole)
  @IsOptional()
  role?: ParticipantAudioRoomRole;

  @IsOptional()
  custom?: Record<string, any>;
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-create.request.ts">
import { AudioRoomType, ParticipantAudioRoomRole, Prisma, RoomStatus } from '@prisma/client';
import { Type } from 'class-transformer';
import { ArrayMaxSize, ArrayMinSize, IsArray, IsEnum, IsJSON, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { parseDateTimeRequestToEpoch } from 'src/shared/parsers/datetime.parse';
import { DateTimeValidator } from 'src/shared/request-validator/date-time.request.validator';
import { AudioRoomParticipantDTO } from '../dto/participant-dto';

export class AudioCallAdminCreateREQ {
  @IsString()
  title: string;

  @IsEnum(AudioRoomType)
  type: AudioRoomType;

  @IsString()
  @DateTimeValidator()
  startsAt: string;

  @IsArray()
  @Type(() => AudioRoomParticipantDTO)
  @ArrayMaxSize(COMMON_CONSTANT.ARRAY_MAX_SIZE)
  @ArrayMinSize(COMMON_CONSTANT.ARRAY_MIN_SIZE)
  members: AudioRoomParticipantDTO[];

  @IsString()
  @IsOptional()
  roomUrl?: string;

  @IsEnum(RoomStatus)
  status: RoomStatus;

  @IsJSON()
  @IsOptional()
  metadata?: Record<string, any>;

  static toCreateInput(user: AuthUserDTO, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log('ðŸš€ ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(user.accountId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: user.accountId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }

  static toCreateMemberInput(ownerId: number, body: AudioCallAdminCreateREQ): Prisma.AudioRoomCreateArgs {
    const members = body.members.map((member: AudioRoomParticipantDTO) => ({
      role: member.role ? member.role : ParticipantAudioRoomRole.USER,
      accountId: member.accountId,
    }));

    console.log('ðŸš€ ~ AudioCallAdminCreateREQ ~ members ~ members:', members);
    const startsAt = parseDateTimeRequestToEpoch(body.startsAt);

    if (startsAt < Date.now()) {
      throw new ActionFailedException(ActionFailed.AUDIO_CALL_STARTS_AT_INVALID);
    }

    return {
      data: {
        title: body.title,
        type: body.type,
        roomUrl: body.roomUrl,
        metadata: body.metadata,
        status: body.status,
        startsAt: parseDateTimeRequestToEpoch(body.startsAt),
        Creator: connectRelation(ownerId),
        Participants: {
          createMany: {
            data: [...members, { role: ParticipantAudioRoomRole.ADMIN, accountId: ownerId }],
          },
        },
      },
      select: { id: true, startsAt: true, creatorId: true, Participants: { select: { accountId: true, role: true } } },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/request/audio-call-admin-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallAdminListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallAdminListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-detail.response.ts">
import { AccountType, AudioRoomType, Gender, RoomStatus } from '@prisma/client';
import { FileRESP } from 'src/domains/file/response/file.response';
import { ImageRESP } from 'src/domains/image/response/image.response';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { parseDateToEpoch } from 'src/shared/parsers/datetime.parse';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../../shared/types';

export class AudioRoomParticipantRESP {
  id: number;
  name: string;
  gender: Gender;
  dob: string;
  accountType: AccountType;
  thumbnail?: ImageRESP;
  cv?: FileRESP;

  static fromEntity(entity: AudioRoomParticipantGetPayload, thumbnail?: ImageRESP, cv?: FileRESP): AudioRoomParticipantRESP {
    return {
      id: entity.Account.id,
      name: entity.Account.name,
      gender: entity.Account.gender,
      accountType: entity.Account.accountType,
      dob: String(parseDateToEpoch(entity.Account.dob)),
      thumbnail: thumbnail,
      cv: cv,
    };
  }
}

export class AudioCallAdminDetailRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminDetailRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      participants: participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/response/audio-call-admin-list.response.ts">
import { AudioRoomType, RoomStatus } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomGetPayload } from '../../shared/types';
import { AudioRoomParticipantRESP } from './audio-call-admin-detail.response';

export class AudioCallAdminListRESP {
  id: number;
  title: string;
  status: RoomStatus;
  type: AudioRoomType;
  isPublic: boolean;
  duration: number;
  createdAt: string;
  startsAt: string;
  activeParticipantCount: number;
  cid: string;
  participants: AudioRoomParticipantRESP[];

  static fromEntity(entity: AudioRoomGetPayload, participants: AudioRoomParticipantRESP[]): AudioCallAdminListRESP {
    return {
      id: entity.id,
      title: entity.title,
      status: entity.status,
      type: entity.type,
      isPublic: entity.isPublic,
      duration: Number(entity.duration),
      createdAt: parseEpoch(entity.createdAt),
      startsAt: parseEpoch(entity.startsAt),
      cid: entity.cid,
      activeParticipantCount: entity.activeParticipantCount,
      participants,
    };
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { BaseResponse } from 'src/shared/generics/base.response';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AuthJwtGuard } from '../../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../../auth/dto/auth-request.dto';
import { AudioCallAdminService } from './audio-call-admin.service';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';

@Controller('admin/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.ADMIN)
export class AudioCallAdminController {
  constructor(private readonly audioCallAdminService: AudioCallAdminService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallAdminListREQ) {
    const data = await this.audioCallAdminService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }

  @Get(':id')
  async detail(@Param('id', ParseIntPipe) roomId: number) {
    const room = await this.audioCallAdminService.detail(roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallAdminController } from './audio-call-admin.controller';
import { AudioCallAdminService } from './audio-call-admin.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallAdminController],
  providers: [AudioCallAdminService],
  exports: [AudioCallAdminService],
})
export class AudioCallAdminModule {}
</file>

<file path="src/domains/audio-call/admin/audio-call-admin.service.ts">
import { Injectable } from '@nestjs/common';
import { FileService } from 'src/domains/file/file.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { AuthUserDTO } from '../../auth/dto/auth-user.dto';
import { ImageService } from '../../image/image.service';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallAdminDetailDTO } from './dto/audio-call-admin-detail.dto';
import { AudioCallAdminCreateREQ } from './request/audio-call-admin-create.request';
import { AudioCallAdminListREQ } from './request/audio-call-admin-list.request';
import { AudioCallAdminDetailRESP } from './response/audio-call-admin-detail.response';
import { AudioCallAdminListRESP } from './response/audio-call-admin-list.response';

@Injectable()
export class AudioCallAdminService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async createAudioCall(user: AuthUserDTO, body: AudioCallAdminCreateREQ) {
    const call = await this.transactionHost.tx.audioRoom.create(AudioCallAdminCreateREQ.toCreateInput(user, body));
    console.log('ðŸš€ ~ AudioCallAdminService ~ createAudioCall ~ call:', call);

    return call;
  }

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallAdminListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          true,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }

  async detail(roomId: number) {
    const call = (await this.transactionHost.tx.audioRoom.findFirstOrThrow(
      AudioCallAdminDetailDTO.toFindFirst(roomId),
    )) as AudioRoomGetPayload;

    const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
      AudioCallAdminDetailDTO.toFindManyParticipants(roomId),
    )) as AudioRoomParticipantGetPayload[];

    const participantDTOs = await participantMapper(
      participants,
      this.imageService,
      this.fileService,
      this.transactionHost,
      true,
    );

    return AudioCallAdminDetailRESP.fromEntity(call, participantDTOs);
  }

  // @Transactional(TRANSACTION_TIMEOUT)
  // async joinAudioCall(user: AuthUserDTO, roomId: number) {
  //   const call = await this.transactionHost.tx.audioRoom.findFirstOrThrow({
  //     where: { id: roomId },
  //     select: { id: true, status: true, isPublic: true, Participants: { select: { accountId: true, isInCall: true } } },
  //   });

  //   const isPartipatedOrInCall = call.Participants.some(
  //     (participant) => participant.accountId === user.accountId && !participant.isInCall,
  //   );

  //   if (!call.isPublic && !isPartipatedOrInCall) {
  //     throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN);
  //   }

  //   if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
  //     throw new ActionFailedException(ActionFailed.CALL_INVALID);
  //   }

  //   const updatedCall = await this.transactionHost.tx.audioRoom.update({
  //     where: { id: roomId },
  //     data: { activeParticipantCount: { increment: isPartipatedOrInCall ? 0 : COMMON_CONSTANT.DEFAULT_INCREMENT } },
  //     select: { id: true },
  //   });

  //   await this.transactionHost.tx.audioRoomParticipant.upsert({
  //     where: { roomId_accountId: { roomId: updatedCall.id, accountId: user.accountId } },
  //     create: {
  //       isInCall: true,
  //       role: ParticipantAudioRoomRole.USER,
  //       Account: connectRelation(user.accountId),
  //       AudioRoom: connectRelation(updatedCall.id),
  //     },
  //     update: { isInCall: true, joinedAt: nowEpoch() },
  //     select: { roomId: true },
  //   });

  //   return updatedCall;
  // }
}
</file>

<file path="src/domains/audio-call/base/audio-call-list-base.request.ts">
import { AccountType, AudioRoomType, Prisma, RoomStatus } from '@prisma/client';
import { IsEnum, IsOptional, IsString } from 'class-validator';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { PaginationREQ } from 'src/shared/generics/pagination.request';
import { parsePrismaSearch } from 'src/shared/parsers/common.parser';
import { BooleanValidator } from 'src/shared/request-validator/boolean.request-validator';

export class AudioCallBaseListREQ extends PaginationREQ {
  @IsString()
  @IsOptional()
  title?: string;

  @IsEnum(AudioRoomType)
  @IsOptional()
  type?: AudioRoomType;

  @IsOptional()
  @BooleanValidator()
  isPublic?: boolean;

  @IsEnum(RoomStatus)
  @IsOptional()
  status?: RoomStatus;

  static toFilterByAccount(user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    if (!user) return;
    switch (user.accountType) {
      case AccountType.ADMIN:
        return {};
      case AccountType.MENTOR:
        return {
          OR: [{ Creator: { id: user.accountId } }, { Participants: { some: { accountId: user.accountId } } }],
        };
      case AccountType.STUDENT:
        return {
          isPublic: false,
          Participants: {
            some: { accountId: user.accountId },
          },
        };
      default:
        throw new ActionFailedException(ActionFailed.ACCOUNT_INVALID_ROLE);
    }
  }

  static toQueryCondition(query: AudioCallBaseListREQ, user: AuthUserDTO): Prisma.AudioRoomWhereInput {
    const filtetByAccount = this.toFilterByAccount(user);
    return {
      AND: [filtetByAccount, parsePrismaSearch('title', query.title)],
      type: query.type,
      isPublic: query.isPublic,
      status: query.status,
    };
  }
}
</file>

<file path="src/domains/audio-call/client/request/audio-call-client-list.request.ts">
import { Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { QueryPagingHelper } from 'src/shared/helpers/pagination.helper';
import { defaultSortDesc } from 'src/shared/helpers/query.helper';
import { AudioCallBaseListREQ } from '../../base/audio-call-list-base.request';

export class AudioCallClientListREQ extends AudioCallBaseListREQ {
  static toFindMany(query: AudioCallClientListREQ, user: AuthUserDTO): Prisma.AudioRoomFindManyArgs {
    const condition = AudioCallBaseListREQ.toQueryCondition(query, user);
    return {
      where: condition,
      orderBy: defaultSortDesc,
      ...QueryPagingHelper.queryPaging(query),
      select: {
        id: true,
        title: true,
        status: true,
        cid: true,
        type: true,
        startsAt: true,
        isPublic: true,
        duration: true,
        createdAt: true,
        activeParticipantCount: true,
        Participants: { select: { accountId: true, role: true, isInCall: true } },
      },
    };
  }

  static toFindManyParticipants(roomId: number): Prisma.AudioRoomParticipantFindManyArgs {
    return {
      where: { roomId },
      select: {
        Account: { select: { id: true, name: true, gender: true, dob: true, avatarId: true, accountType: true } },
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.controller.ts">
import { Controller, Get, Query, Req, UseGuards } from '@nestjs/common';
import { AccountType } from '@prisma/client';
import { AuthJwtGuard } from 'src/domains/auth/auth-jwt.guard';
import { Roles } from 'src/domains/auth/auth-role.decorator';
import { AuthRoleGuard } from 'src/domains/auth/auth-role.guard';
import { AuthRequestDTO } from 'src/domains/auth/dto/auth-request.dto';
import { PaginationResponse } from 'src/shared/generics/pagination.response';
import { AudioCallClientService } from './audio-call-client.service';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Controller('client/audio-call')
@UseGuards(AuthJwtGuard, AuthRoleGuard)
@Roles(AccountType.STUDENT, AccountType.MENTOR)
export class AudioCallClientController {
  constructor(private readonly audioCallClientService: AudioCallClientService) {}

  @Get()
  async list(@Req() req: AuthRequestDTO, @Query() query: AudioCallClientListREQ) {
    const data = await this.audioCallClientService.list(req.user, query);

    return PaginationResponse.ofWithTotal(data.callDTOs, data.count);
  }
}
</file>

<file path="src/domains/audio-call/client/audio-call-client.module.ts">
import { Module } from '@nestjs/common';
import { CommonModule } from 'src/services/common.module';
import { AudioCallClientController } from './audio-call-client.controller';
import { AudioCallClientService } from './audio-call-client.service';

@Module({
  imports: [CommonModule],
  controllers: [AudioCallClientController],
  providers: [AudioCallClientService],
})
export class AudioCallClientModule {}
</file>

<file path="src/domains/audio-call/client/audio-call-client.service.ts">
import { Injectable } from '@nestjs/common';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { AudioCallAdminListREQ } from '../admin/request/audio-call-admin-list.request';
import { AudioCallAdminListRESP } from '../admin/response/audio-call-admin-list.response';
import { participantMapper } from '../shared/helpers';
import { AudioRoomGetPayload, AudioRoomParticipantGetPayload } from '../shared/types';
import { AudioCallClientListREQ } from './request/audio-call-client-list.request';

@Injectable()
export class AudioCallClientService {
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
    private readonly fileService: FileService,
  ) {}

  async list(user: AuthUserDTO, query: AudioCallAdminListREQ) {
    const calls = await this.transactionHost.tx.audioRoom.findMany(AudioCallClientListREQ.toFindMany(query, user));
    const count = await this.transactionHost.tx.audioRoom.count({ where: AudioCallAdminListREQ.toQueryCondition(query, user) });

    const callDTOs = await Promise.all(
      calls.map(async (call: AudioRoomGetPayload) => {
        const participants = (await this.transactionHost.tx.audioRoomParticipant.findMany(
          AudioCallAdminListREQ.toFindManyParticipants(call.id),
        )) as AudioRoomParticipantGetPayload[];
        const participantDtos = await participantMapper(
          participants,
          this.imageService,
          this.fileService,
          this.transactionHost,
          false,
        );

        return AudioCallAdminListRESP.fromEntity(call, participantDtos);
      }),
    );
    const data = { callDTOs, count };

    return data;
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-end.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';

export class AudioCallEndDTO {
  static toEnd(roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.FINISHED,
        Participants: {
          updateMany: {
            where: { roomId },
            data: addUpdationTimestamps({ isInCall: false }),
          },
        },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-join.dto.ts">
import { ParticipantAudioRoomRole, Prisma } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';
import { addCreationTimestamps, addUpdationTimestamps } from 'src/shared/helpers/add-timestamp.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';

export class AudioCallJoinDTO {
  static toUpsertParticipant(user: AuthUserDTO, roomId: number): Prisma.AudioRoomParticipantUpsertArgs {
    return {
      where: { roomId_accountId: { roomId: roomId, accountId: user.accountId } },
      create: addCreationTimestamps({
        isInCall: true,
        role: ParticipantAudioRoomRole.USER,
        Account: connectRelation(user.accountId),
        AudioRoom: connectRelation(roomId),
      }),

      update: addUpdationTimestamps({
        isInCall: true,
      }),
      select: { roomId: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/dto/audio-call-start.dto.ts">
import { Prisma, RoomStatus } from '@prisma/client';
import { AuthUserDTO } from 'src/domains/auth/dto/auth-user.dto';

export class AudioCallStartDTO {
  static toStart(user: AuthUserDTO, roomId: number): Prisma.AudioRoomUpdateArgs {
    return {
      where: { id: roomId },
      data: {
        status: RoomStatus.ONGOING,
        // Participants: {
        //   update: {
        //     where: { roomId_accountId: { roomId, accountId: user.accountId } },
        //     data: addUpdationTimestamps({ joinedAt: nowEpoch(), isInCall: true }),
        //   },
        // },
      },
      select: { id: true, status: true },
    };
  }
}
</file>

<file path="src/domains/audio-call/response/audio-call-participant-history.response.ts">
import { ParticipantAudioRoomRole } from '@prisma/client';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AudioRoomActivityHistoryGetPayload, AudioRoomParticipantAccount } from '../shared/types';

export class AudioCallParticipantHistoryRESP {
  id: number;
  joinedAt: string;
  leftAt: string;
  AudioParticipant: { accountId: number; role: ParticipantAudioRoomRole } & AudioRoomParticipantAccount;

  static fromEntity(
    e: AudioRoomActivityHistoryGetPayload,
    account: AudioRoomParticipantAccount,
  ): AudioCallParticipantHistoryRESP {
    return {
      id: e.id,
      joinedAt: parseEpoch(e.joinedAt),
      leftAt: parseEpoch(e.leftAt),
      AudioParticipant: {
        accountId: e.AudioRoomParticipant.accountId,
        name: account.name,
        thumbnail: account.thumbnail,
        role: e.AudioRoomParticipant.role,
      },
    };
  }
}
</file>

<file path="src/domains/audio-call/shared/helpers.ts">
import { FileService } from 'src/domains/file/file.service';
import { ImageService } from 'src/domains/image/image.service';
import { AudioRoomParticipantRESP } from '../admin/response/audio-call-admin-detail.response';
import { AudioRoomParticipantGetPayload } from './types';

export const participantMapper = async (
  participants: AudioRoomParticipantGetPayload[],
  imageService: ImageService,
  fileService: FileService,
  transactionHost: any,
  isCvPublic: boolean = false,
): Promise<AudioRoomParticipantRESP[]> => {
  return await Promise.all(
    participants.map(async (participant: AudioRoomParticipantGetPayload) => {
      const thumbnail = await imageService.getImageOriginal(participant.Account.avatarId);
      let cv: any;
      if (participant.Account.accountType === 'MENTOR') {
        const mentor = await transactionHost.tx.mentor.findFirst({
          where: { accountId: participant.Account.id },
          select: {
            fileId: true,
          },
        });

        cv = isCvPublic ? await fileService.detail(mentor.fileId) : null;
      }

      return AudioRoomParticipantRESP.fromEntity(participant, thumbnail, cv);
    }),
  );
};
</file>

<file path="src/domains/audio-call/shared/types.ts">
import { Prisma } from '@prisma/client';
import { AccountRESP } from 'src/domains/accounts/response/account.response';

export type AudioRoomParticipantAccount = Pick<AccountRESP, 'name' | 'thumbnail'>;

export type AudioRoomGetPayload = Prisma.AudioRoomGetPayload<{
  include: {
    Participants: true;
    Creator: true;
    Subscription: true;
  };
}>;

export type AudioRoomParticipantGetPayload = Prisma.AudioRoomParticipantGetPayload<{
  include: { Account: true; AudioRoom: true; AudioRoomActivityHistories: true };
}>;

export type AudioRoomActivityHistoryGetPayload = Prisma.AudioRoomActivityHistoryGetPayload<{
  include: { AudioRoomParticipant: true };
}>;

export type AudioRoomSessionParticipantLeave = {
  call_cid: string;
  participant: { user: { id: number } };
};
</file>

<file path="src/domains/audio-call/audio-call.controller.ts">
import { Controller, Get, Param, ParseIntPipe, Patch, Req, UseGuards } from '@nestjs/common';
import { BaseResponse } from 'src/shared/generics/base.response';
import { AuthJwtGuard } from '../auth/auth-jwt.guard';
import { AuthRequestDTO } from '../auth/dto/auth-request.dto';
import { AudioCallService } from './audio-call.service';

@Controller('audio-call')
@UseGuards(AuthJwtGuard)
export class AudioCallController {
  constructor(private readonly AudioCallService: AudioCallService) {}

  @Get(':id/histories')
  async histories(@Param('id', ParseIntPipe) roomId: number) {
    const histories = await this.AudioCallService.getAudioCallHistory(roomId);
    return BaseResponse.of(histories);
  }

  @Patch(':id/join')
  async join(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.joinAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/leave')
  async leave(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.leaveAudioCall(req.user.accountId, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/start')
  async start(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.startAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }

  @Patch(':id/end')
  async end(@Req() req: AuthRequestDTO, @Param('id', ParseIntPipe) roomId: number) {
    const room = await this.AudioCallService.endAudioCall(req.user, roomId);
    return BaseResponse.of(room);
  }
}
</file>

<file path="src/domains/audio-call/audio-call.gateway.ts">
import { Injectable, Logger } from '@nestjs/common';
import { OnEvent } from '@nestjs/event-emitter';
import { AudioCallChannel } from 'src/shared/constants/event.constant';
import { AudioCallService } from './audio-call.service';
import { AudioRoomSessionParticipantLeave } from './shared/types';

@Injectable()
export class AudioCallGateway {
  private readonly logger = new Logger(AudioCallGateway.name);
  constructor(private readonly audioCallService: AudioCallService) {}

  @OnEvent(AudioCallChannel.LEAVE_CALL)
  async handleParticipantSessionLeave(payload: AudioRoomSessionParticipantLeave) {
    const cid = payload.call_cid;
    this.logger.log('ðŸš€ ~ AudioCallGateway ~ handleParticipantSessionLeave ~ cid:', cid);

    const roomId = cid.split('-')[1];
    if (!payload) {
      return;
    }

    await this.audioCallService.leaveAudioCall(Number(payload.participant.user.id), Number(roomId));
  }
}
</file>

<file path="src/domains/audio-call/audio-call.module.ts">
import { Module } from '@nestjs/common';
import { AudioCallAdminModule } from './admin/audio-call-admin.module';
import { AudioCallController } from './audio-call.controller';
import { AudioCallGateway } from './audio-call.gateway';
import { AudioCallService } from './audio-call.service';
import { AudioCallClientModule } from './client/audio-call-client.module';

@Module({
  imports: [AudioCallAdminModule, AudioCallClientModule],
  controllers: [AudioCallController],
  providers: [AudioCallService, AudioCallGateway],
  exports: [AudioCallService],
})
export class AudioCallModule {}
</file>

<file path="src/domains/audio-call/audio-call.service.spec.ts">
import { Test, TestingModule } from '@nestjs/testing';
import { AudioCallService } from './admin/audio-call-admin.service';

describe('AudioCallService', () => {
  let service: AudioCallService;

  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [AudioCallService],
    }).compile();

    service = module.get<AudioCallService>(AudioCallService);
  });

  it('should be defined', () => {
    expect(service).toBeDefined();
  });
});
</file>

<file path="src/domains/audio-call/audio-call.service.ts">
import { Injectable, Logger } from '@nestjs/common';
import {
  AudioRoomParticipant,
  AudioRoomType,
  ParticipantAudioRoomRole,
  RoomStatus,
  SubscriptionStatus,
  WageStatus,
} from '@prisma/client';
import { TransactionHost } from 'src/services/prisma/transactions/transaction-host';
import { Transactional } from 'src/services/prisma/transactions/transactional.decorator';
import { AUDIO_ROOM_CONSTANT, AudioRoomActivity } from 'src/shared/constants/audio-room.constant';
import { COMMON_CONSTANT } from 'src/shared/constants/common.constant';
import { TRANSACTION_TIMEOUT } from 'src/shared/constants/prisma.constant';
import { ActionFailed, ActionFailedException } from 'src/shared/exceptions/action-failed.exception';
import { nowEpoch } from 'src/shared/helpers/common.helper';
import { asyncSome } from 'src/shared/helpers/function.helper';
import { connectRelation } from 'src/shared/helpers/prisma.helper';
import { AudioCallErrorMessages } from 'src/shared/messages/error-messages';
import { parseEpoch } from 'src/shared/parsers/common.parser';
import { AuthUserDTO } from '../auth/dto/auth-user.dto';
import { ImageService } from '../image/image.service';
import { AudioCallEndDTO } from './dto/audio-call-end.dto';
import { AudioCallJoinDTO } from './dto/audio-call-join.dto';
import { AudioCallStartDTO } from './dto/audio-call-start.dto';
import { AudioCallParticipantHistoryRESP } from './response/audio-call-participant-history.response';
import { AudioRoomActivityHistoryGetPayload, AudioRoomGetPayload } from './shared/types';

@Injectable()
export class AudioCallService {
  private readonly logger = new Logger(AudioCallService.name);
  constructor(
    private readonly transactionHost: TransactionHost,
    private readonly imageService: ImageService,
  ) {}

  @Transactional(TRANSACTION_TIMEOUT)
  async getAudioCallHistory(audioRoomId: number) {
    await this.checkExistedRoom(audioRoomId);
    const histories = await this.transactionHost.tx.audioRoomActivityHistory.findMany({
      where: { AudioRoomParticipant: { roomId: audioRoomId } },
      select: {
        id: true,
        joinedAt: true,
        leftAt: true,
        AudioRoomParticipant: { select: { accountId: true, role: true } },
      },
    });

    return await Promise.all(
      histories.map(async (history: AudioRoomActivityHistoryGetPayload) => {
        const thumbnail = await this.imageService.getImageOriginal(history.AudioRoomParticipant.accountId);
        const account = await this.transactionHost.tx.account.findFirst({
          where: { id: history.AudioRoomParticipant.accountId },
          select: { name: true },
        });

        return AudioCallParticipantHistoryRESP.fromEntity(history, {
          name: account.name,
          thumbnail,
        });
      }),
    );
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async startAudioCall(user: AuthUserDTO, roomId: number) {
    console.log('ðŸš€ ~ AudioCallService ~ startAudioCall ~ user:', user.accountId);
    /* Check existed call */
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const havePermissionToStart = await asyncSome<AudioRoomParticipant>(call.Participants, async (participant) => {
      const isInOtherCall = await this.checkAccountInCall(participant.accountId, roomId);
      console.log('ðŸš€ ~ AudioCallService ~ havePermissionToStart ~ isInOtherCall:', isInOtherCall);

      const tmp =
        participant.accountId === user.accountId &&
        participant.role === ParticipantAudioRoomRole.ADMIN &&
        !participant.isInCall &&
        !isInOtherCall;

      return tmp;
    });

    if (!havePermissionToStart) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG02);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* Update status of call & participant started call */
    const updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallStartDTO.toStart(user, roomId));

    //TODO: Implement push notification to all participants

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async endAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    /* Check user is belong to participant list and user has role 'ADMIN' */
    const canEndCall = call.Participants.some(
      (participant) => participant.accountId === user.accountId && participant.role === ParticipantAudioRoomRole.ADMIN,
    );

    if (!canEndCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_NOT_HAVE_PERMISSION, AudioCallErrorMessages.MSG03);
    }

    /* Check status of audio call */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const now = nowEpoch();
    let updatedCall: any;
    if (call.Subscription) {
      const courseAccessStartAt = parseEpoch(call.Subscription.courseAccessStartAt);
      const courseAccessEndAt = parseEpoch(call.Subscription.courseAccessEndAt);

      if (now > courseAccessStartAt && now < courseAccessEndAt) {
        throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      } else {
        const subcription = await this.transactionHost.tx.subscription.update({
          where: { id: call.Subscription.id },
          data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
          select: { id: true },
        });

        this.logger.log(`ðŸš€ ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      }

      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      // if (now > courseAccessStartAt && now < courseAccessEndAt) {
      //   throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_CANCEL, AudioCallErrorMessages.MSG07);
      // } else if (now < courseAccessStartAt) {
      //   this.logger.log(`ðŸš€ ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      //   updatedCall = await this.transactionHost.tx.audioRoomParticipant.updateMany({
      //     where: { roomId: roomId, isInCall: true },
      //     data: { isInCall: false },
      //   });
      // } else {
      //   const subcription = await this.transactionHost.tx.subscription.update({
      //     where: { id: call.Subscription.id },
      //     data: { status: SubscriptionStatus.ENDED, wageStatus: WageStatus.FULL_WAGE },
      //     select: { id: true },
      //   });

      //   this.logger.log(`ðŸš€ ~ AudioCallService ~ endAudioCall ~ the subscription with id ${subcription.id} ended `);
      //   updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));
      // }

      /* Update status of call & participant started call */
      this.logger.log(`ðŸš€ ~ AudioCallService ~ endAudioCall ~ the subscription with id ${call.Subscription.id} have started`);
      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    } else if (call.type === AudioRoomType.INTERVIEW) {
      updatedCall = await this.transactionHost.tx.audioRoom.update(AudioCallEndDTO.toEnd(roomId));

      await this.transactionHost.tx.audioRoomParticipant.updateMany({
        where: { roomId: roomId, isInCall: true },
        data: { isInCall: false },
      });
    }

    const callId = updatedCall ? updatedCall.id : roomId;

    await this.transactionHost.tx.audioRoomActivityHistory.updateMany({
      where: { AudioRoomParticipant: { roomId: callId }, leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT },
      data: { leftAt: nowEpoch() },
    });

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async joinAudioCall(user: AuthUserDTO, roomId: number) {
    const call = await this.checkExistedRoom(roomId);
    const isInCall = await this.checkAccountInCall(user.accountId, roomId);

    const isPartipated = call.Participants.some(
      (participant) => participant.accountId === user.accountId && !participant.isInCall,
    );

    if (isInCall) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG05);
    } else if (!call.isPublic && !isPartipated) {
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_JOIN, AudioCallErrorMessages.MSG06);
    }

    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { increment: COMMON_CONSTANT.DEFAULT_INCREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.upsert(AudioCallJoinDTO.toUpsertParticipant(user, roomId));
    await this.createPaticipantHistory(user.accountId, updatedCall.id, AudioRoomActivity.JOIN);

    return updatedCall;
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async leaveAudioCall(accountId: number, roomId: number) {
    /* Check existed audio room */
    const call = await this.checkExistedRoom(roomId);
    const participants = await this.getAllParticipants(roomId);

    /* Check if user is joinning the audio room */
    const isPartipated = participants.some((participant) => participant.accountId === accountId && participant.isInCall);

    if (!isPartipated) {
      this.logger.error(`ðŸš€ ~ AudioCallService ~ leaveAudioCall ~ the user with id ${accountId} is not in call`);
      throw new ActionFailedException(ActionFailed.CALL_AUDIO_CAN_NOT_LEAVE);
    }

    /* Check the status of room */
    if (call.status === (RoomStatus.FINISHED || RoomStatus.CANCELLED)) {
      this.logger.error(`ðŸš€ ~ AudioCallService ~ leaveAudioCall ~ the call status is invalid`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    /* We must decrement the number of participant */
    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { activeParticipantCount: { decrement: COMMON_CONSTANT.DEFAULT_DECREMENT } },
      select: { id: true },
    });

    await this.transactionHost.tx.audioRoomParticipant.update({
      where: { roomId_accountId: { roomId: updatedCall.id, accountId: accountId } },
      data: { isInCall: false },
      select: { roomId: true },
    });

    await this.createPaticipantHistory(accountId, updatedCall.id, AudioRoomActivity.LEAVE);

    return updatedCall;
  }

  async createPaticipantHistory(accountId: number, roomId: number, type: AudioRoomActivity) {
    if (!accountId || !roomId) {
      this.logger.error(`ðŸš€ ~ AudioCallService ~ createPaticipantHistory ~ invalid accountId or roomId`);
      throw new ActionFailedException(ActionFailed.CALL_INVALID);
    }

    const participant = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: { accountId, roomId },
      select: { id: true },
    });

    if (!participant) {
      this.logger.error(`ðŸš€ ~ AudioCallService ~ createPaticipantHistory ~ the participant is not existed`);
      throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_NOT_FOUND);
    }

    //Find the lastest record of participant
    const lastestRecord = await this.transactionHost.tx.audioRoomActivityHistory.findFirst({
      where: { leftAt: AUDIO_ROOM_CONSTANT.DEFAULT_VALUE_LEFT_AT, audioRoomParticipantId: participant.id },
      select: { id: true },
    });
    this.logger.log('ðŸš€ ~ AudioCallService ~ createPaticipantHistory ~ lastestRecord:', lastestRecord);

    if (type === AudioRoomActivity.JOIN) {
      //If the lastest record is existed with joinedAt but not leftAt
      // then the user is already in call
      if (lastestRecord) {
        throw new ActionFailedException(ActionFailed.CALL_PARTICIPANT_JOINED, AudioCallErrorMessages.MSG08);
      }

      await this.transactionHost.tx.audioRoomActivityHistory.create({
        data: {
          AudioRoomParticipant: connectRelation(participant.id),
          joinedAt: nowEpoch(),
        },
      });
    } else {
      // If the lastest record is existed with joinedAt but not leftAt
      // Then we will update the leftAt field
      await this.transactionHost.tx.audioRoomActivityHistory.update({
        where: { id: lastestRecord.id },
        data: { leftAt: nowEpoch() },
      });
    }
  }

  @Transactional(TRANSACTION_TIMEOUT)
  async cancelCall(roomId: number) {
    const call = await this.checkExistedRoom(roomId);

    if (call.status === RoomStatus.FINISHED || call.status === RoomStatus.ONGOING) {
      throw new ActionFailedException(ActionFailed.CALL_INVALID, AudioCallErrorMessages.MSG04);
    }

    const updatedCall = await this.transactionHost.tx.audioRoom.update({
      where: { id: roomId },
      data: { status: RoomStatus.CANCELLED },
      select: { id: true },
    });

    return updatedCall;
  }

  private async checkExistedRoom(roomId: number): Promise<AudioRoomGetPayload> {
    const call = (await this.transactionHost.tx.audioRoom.findFirst({
      where: { id: roomId },
      select: {
        id: true,
        status: true,
        type: true,
        isPublic: true,
        Subscription: { select: { id: true, courseAccessStartAt: true, courseAccessEndAt: true } },
        Participants: { select: { accountId: true, isInCall: true, role: true } },
        activeParticipantCount: true,
      },
    })) as AudioRoomGetPayload;

    if (!call) {
      throw new ActionFailedException(ActionFailed.CALL_NOT_FOUND);
    }

    return call;
  }

  private async checkAccountInCall(accountId: number, roomId: number): Promise<boolean> {
    const call = await this.transactionHost.tx.audioRoomParticipant.findFirst({
      where: {
        accountId,
        isInCall: true,
        roomId: { not: roomId },
        AudioRoom: { status: RoomStatus.ONGOING },
      },
      select: { roomId: true },
    });

    console.log('ðŸš€ ~ AudioCallService ~ checkAccountInCall ~ isInCall:', call);

    return !!call;
  }

  private async getAllParticipants(roomId: number) {
    const participants = await this.transactionHost.tx.audioRoomParticipant.findMany({
      where: { roomId },
      select: { accountId: true, role: true, isInCall: true },
    });

    return participants;
  }
}
</file>

<file path="README.md">
<p align="center">
  <a href="http://nestjs.com/" target="blank"><img src="https://nestjs.com/img/logo-small.svg" width="120" alt="Nest Logo" /></a>
</p>

[circleci-image]: https://img.shields.io/circleci/build/github/nestjs/nest/master?token=abc123def456
[circleci-url]: https://circleci.com/gh/nestjs/nest

  <p align="center">A progressive <a href="http://nodejs.org" target="_blank">Node.js</a> framework for building efficient and scalable server-side applications.</p>
    <p align="center">
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/v/@nestjs/core.svg" alt="NPM Version" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/l/@nestjs/core.svg" alt="Package License" /></a>
<a href="https://www.npmjs.com/~nestjscore" target="_blank"><img src="https://img.shields.io/npm/dm/@nestjs/common.svg" alt="NPM Downloads" /></a>
<a href="https://circleci.com/gh/nestjs/nest" target="_blank"><img src="https://img.shields.io/circleci/build/github/nestjs/nest/master" alt="CircleCI" /></a>
<a href="https://coveralls.io/github/nestjs/nest?branch=master" target="_blank"><img src="https://coveralls.io/repos/github/nestjs/nest/badge.svg?branch=master#9" alt="Coverage" /></a>
<a href="https://discord.gg/G7Qnnhy" target="_blank"><img src="https://img.shields.io/badge/discord-online-brightgreen.svg" alt="Discord"/></a>
<a href="https://opencollective.com/nest#backer" target="_blank"><img src="https://opencollective.com/nest/backers/badge.svg" alt="Backers on Open Collective" /></a>
<a href="https://opencollective.com/nest#sponsor" target="_blank"><img src="https://opencollective.com/nest/sponsors/badge.svg" alt="Sponsors on Open Collective" /></a>
  <a href="https://paypal.me/kamilmysliwiec" target="_blank"><img src="https://img.shields.io/badge/Donate-PayPal-ff3f59.svg" alt="Donate us"/></a>
    <a href="https://opencollective.com/nest#sponsor"  target="_blank"><img src="https://img.shields.io/badge/Support%20us-Open%20Collective-41B883.svg" alt="Support us"></a>
  <a href="https://twitter.com/nestframework" target="_blank"><img src="https://img.shields.io/twitter/follow/nestframework.svg?style=social&label=Follow" alt="Follow us on Twitter"></a>
</p>
  <!--[![Backers on Open Collective](https://opencollective.com/nest/backers/badge.svg)](https://opencollective.com/nest#backer)
  [![Sponsors on Open Collective](https://opencollective.com/nest/sponsors/badge.svg)](https://opencollective.com/nest#sponsor)-->

## Description

[Nest](https://github.com/nestjs/nest) framework TypeScript starter repository.

## Project setup

```bash
$ yarn install
```

## Compile and run the project

```bash
# development
$ yarn run start

# watch mode
$ yarn run start:dev

# production mode
$ yarn run start:prod
```

## Run tests

```bash
# unit tests
$ yarn run test

# e2e tests
$ yarn run test:e2e

# test coverage
$ yarn run test:cov
```

## Resources

Check out a few resources that may come in handy when working with NestJS:

- Visit the [NestJS Documentation](https://docs.nestjs.com) to learn more about the framework.
- For questions and support, please visit our [Discord channel](https://discord.gg/G7Qnnhy).
- To dive deeper and get more hands-on experience, check out our official video [courses](https://courses.nestjs.com/).
- Visualize your application graph and interact with the NestJS application in real-time using [NestJS Devtools](https://devtools.nestjs.com).
- Need help with your project (part-time to full-time)? Check out our official [enterprise support](https://enterprise.nestjs.com).
- To stay in the loop and get updates, follow us on [X](https://x.com/nestframework) and [LinkedIn](https://linkedin.com/company/nestjs).
- Looking for a job, or have a job to offer? Check out our official [Jobs board](https://jobs.nestjs.com).

## Support

Nest is an MIT-licensed open source project. It can grow thanks to the sponsors and support by the amazing backers. If you'd like to join them, please [read more here](https://docs.nestjs.com/support).

## Stay in touch

- Author - [Kamil MyÅ›liwiec](https://twitter.com/kammysliwiec)
- Website - [https://nestjs.com](https://nestjs.com/)
- Twitter - [@nestframework](https://twitter.com/nestframework)

## License

Nest is [MIT licensed](https://github.com/nestjs/nest/blob/master/LICENSE).
# bksharing-be
</file>

</repository_files>
